const t7 = Object.freeze({
});
function e4(t) {
    return null == t;
}
function n2(t) {
    return null != t;
}
function o3(t) {
    return !0 === t;
}
function r3(t) {
    return "string" == typeof t || "number" == typeof t || "symbol" == typeof t || "boolean" == typeof t;
}
function s(t) {
    return null !== t && "object" == typeof t;
}
const i3 = Object.prototype.toString;
function a(t) {
    return "[object Object]" === i3.call(t);
}
function c(t) {
    const e = parseFloat(String(t));
    return e >= 0 && Math.floor(e) === e && isFinite(t);
}
function l(t) {
    return n2(t) && "function" == typeof t.then && "function" == typeof t.catch;
}
function u2(t) {
    return null == t ? "" : Array.isArray(t) || a(t) && t.toString === i3 ? JSON.stringify(t, null, 2) : String(t);
}
function f(t) {
    const e = parseFloat(t);
    return isNaN(e) ? t : e;
}
function d(t, e) {
    const n = Object.create(null), o = t.split(",");
    for(let t1 = 0; t1 < o.length; t1++)n[o[t1]] = !0;
    return e ? (t)=>n[t.toLowerCase()]
     : (t)=>n[t]
    ;
}
const p = d("slot,component", !0), h = d("key,ref,slot,slot-scope,is");
function m(t, e) {
    if (t.length) {
        const n = t.indexOf(e);
        if (n > -1) return t.splice(n, 1);
    }
}
const y = Object.prototype.hasOwnProperty;
function g(t, e) {
    return y.call(t, e);
}
function v(t) {
    const e = Object.create(null);
    return function(n) {
        return e[n] || (e[n] = t(n));
    };
}
const $ = /-(\w)/g, _ = v((t)=>t.replace($, (t, e)=>e ? e.toUpperCase() : ""
    )
), b = v((t)=>t.charAt(0).toUpperCase() + t.slice(1)
), w = /\B([A-Z])/g, C = v((t)=>t.replace(w, "-$1").toLowerCase()
);
const x = Function.prototype.bind ? function(t, e) {
    return t.bind(e);
} : function(t, e) {
    function n(n) {
        const o = arguments.length;
        return o ? o > 1 ? t.apply(e, arguments) : t.call(e, n) : t.call(e);
    }
    return n._length = t.length, n;
};
function k(t, e) {
    e = e || 0;
    let n = t.length - e;
    const o = new Array(n);
    for(; n--;)o[n] = t[n + e];
    return o;
}
function A(t, e) {
    for(const n in e)t[n] = e[n];
    return t;
}
function O(t) {
    const e = {
    };
    for(let n = 0; n < t.length; n++)t[n] && A(e, t[n]);
    return e;
}
function S1(t, e, n) {
}
const T1 = (t, e, n)=>!1
, N = (t)=>t
;
function E(t, e) {
    if (t === e) return !0;
    const n = s(t), o = s(e);
    if (!n || !o) return !n && !o && String(t) === String(e);
    try {
        const n1 = Array.isArray(t), o1 = Array.isArray(e);
        if (n1 && o1) return t.length === e.length && t.every((t, n)=>E(t, e[n])
        );
        if (t instanceof Date && e instanceof Date) return t.getTime() === e.getTime();
        if (n1 || o1) return !1;
        {
            const n = Object.keys(t), o = Object.keys(e);
            return n.length === o.length && n.every((n)=>E(t[n], e[n])
            );
        }
    } catch (t1) {
        return !1;
    }
}
function j(t, e) {
    for(let n = 0; n < t.length; n++)if (E(t[n], e)) return n;
    return -1;
}
function D(t) {
    let e = !1;
    return function() {
        e || (e = !0, t.apply(this, arguments));
    };
}
const L = "data-server-rendered", I = [
    "component",
    "directive",
    "filter"
], M = [
    "beforeCreate",
    "created",
    "beforeMount",
    "mounted",
    "beforeUpdate",
    "updated",
    "beforeDestroy",
    "destroyed",
    "activated",
    "deactivated",
    "errorCaptured",
    "serverPrefetch"
];
var F = {
    optionMergeStrategies: Object.create(null),
    silent: !1,
    productionTip: !1,
    devtools: !1,
    performance: !1,
    errorHandler: null,
    warnHandler: null,
    ignoredElements: [],
    keyCodes: Object.create(null),
    isReservedTag: T1,
    isReservedAttr: T1,
    isUnknownElement: T1,
    getTagNamespace: S1,
    parsePlatformTagName: N,
    mustUseProp: T1,
    async: !0,
    _lifecycleHooks: M
};
const P = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
function R(t) {
    const e = (t + "").charCodeAt(0);
    return 36 === e || 95 === e;
}
function H(t, e, n, o) {
    Object.defineProperty(t, e, {
        value: n,
        enumerable: !!o,
        writable: !0,
        configurable: !0
    });
}
const B1 = new RegExp(`[^${P.source}.$_\\d]`);
const U1 = "__proto__" in {
}, V = "undefined" != typeof window, z = "undefined" != typeof WXEnvironment && !!WXEnvironment.platform, K = z && WXEnvironment.platform.toLowerCase(), J = V && window.navigator.userAgent.toLowerCase(), q = J && /msie|trident/.test(J), W = J && J.indexOf("msie 9.0") > 0, Z = J && J.indexOf("edge/") > 0, G = (J && J.indexOf("android"), J && /iphone|ipad|ipod|ios/.test(J) || "ios" === K), X = (J && /chrome\/\d+/.test(J), J && /phantomjs/.test(J), J && J.match(/firefox\/(\d+)/)), Y = {
}.watch;
let Q, tt = !1;
if (V) try {
    const t1 = {
    };
    Object.defineProperty(t1, "passive", {
        get () {
            tt = !0;
        }
    }), window.addEventListener("test-passive", null, t1);
} catch (t2) {
}
const et = ()=>(void 0 === Q && (Q = !V && !z && "undefined" != typeof global && global.process && "server" === global.process.env.VUE_ENV), Q)
, nt = V && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
function ot(t) {
    return "function" == typeof t && /native code/.test(t.toString());
}
const rt = "undefined" != typeof Symbol && ot(Symbol) && "undefined" != typeof Reflect && ot(Reflect.ownKeys);
let st;
st = "undefined" != typeof Set && ot(Set) ? Set : class {
    constructor(){
        this.set = Object.create(null);
    }
    has(t) {
        return !0 === this.set[t];
    }
    add(t) {
        this.set[t] = !0;
    }
    clear() {
        this.set = Object.create(null);
    }
};
let it = S1, at = 0;
class ct {
    constructor(){
        this.id = at++, this.subs = [];
    }
    addSub(t) {
        this.subs.push(t);
    }
    removeSub(t) {
        m(this.subs, t);
    }
    depend() {
        ct.target && ct.target.addDep(this);
    }
    notify() {
        const t = this.subs.slice();
        for(let e = 0, n = t.length; e < n; e++)t[e].update();
    }
}
ct.target = null;
const lt = [];
function ut(t) {
    lt.push(t), ct.target = t;
}
function ft() {
    lt.pop(), ct.target = lt[lt.length - 1];
}
class dt {
    constructor(t3, e1, n1, o1, r1, s1, i1, a1){
        this.tag = t3, this.data = e1, this.children = n1, this.text = o1, this.elm = r1, this.ns = void 0, this.context = s1, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = e1 && e1.key, this.componentOptions = i1, this.componentInstance = void 0, this.parent = void 0, this.raw = !1, this.isStatic = !1, this.isRootInsert = !0, this.isComment = !1, this.isCloned = !1, this.isOnce = !1, this.asyncFactory = a1, this.asyncMeta = void 0, this.isAsyncPlaceholder = !1;
    }
    get child() {
        return this.componentInstance;
    }
}
const pt = (t = "")=>{
    const e = new dt;
    return e.text = t, e.isComment = !0, e;
};
function ht(t) {
    return new dt(void 0, void 0, void 0, String(t));
}
function mt(t) {
    const e = new dt(t.tag, t.data, t.children && t.children.slice(), t.text, t.elm, t.context, t.componentOptions, t.asyncFactory);
    return e.ns = t.ns, e.isStatic = t.isStatic, e.key = t.key, e.isComment = t.isComment, e.fnContext = t.fnContext, e.fnOptions = t.fnOptions, e.fnScopeId = t.fnScopeId, e.asyncMeta = t.asyncMeta, e.isCloned = !0, e;
}
const yt = Array.prototype, gt = Object.create(yt);
[
    "push",
    "pop",
    "shift",
    "unshift",
    "splice",
    "sort",
    "reverse"
].forEach(function(t) {
    const e = yt[t];
    H(gt, t, function(...n) {
        const o = e.apply(this, n), r = this.__ob__;
        let s;
        switch(t){
            case "push":
            case "unshift":
                s = n;
                break;
            case "splice":
                s = n.slice(2);
        }
        return s && r.observeArray(s), r.dep.notify(), o;
    });
});
const vt = Object.getOwnPropertyNames(gt);
let $t = !0;
function _t(t) {
    $t = t;
}
class bt {
    constructor(t4){
        var e2;
        this.value = t4, this.dep = new ct, this.vmCount = 0, H(t4, "__ob__", this), Array.isArray(t4) ? (U1 ? (e2 = gt, t4.__proto__ = e2) : (function(t, e, n) {
            for(let o = 0, r = n.length; o < r; o++){
                const r = n[o];
                H(t, r, e[r]);
            }
        })(t4, gt, vt), this.observeArray(t4)) : this.walk(t4);
    }
    walk(t) {
        const e = Object.keys(t);
        for(let n = 0; n < e.length; n++)Ct(t, e[n]);
    }
    observeArray(t) {
        for(let e = 0, n = t.length; e < n; e++)wt(t[e]);
    }
}
function wt(t, e) {
    if (!s(t) || t instanceof dt) return;
    let n;
    return g(t, "__ob__") && t.__ob__ instanceof bt ? n = t.__ob__ : $t && !et() && (Array.isArray(t) || a(t)) && Object.isExtensible(t) && !t._isVue && (n = new bt(t)), e && n && n.vmCount++, n;
}
function Ct(t, e, n, o, r) {
    const s = new ct, i = Object.getOwnPropertyDescriptor(t, e);
    if (i && !1 === i.configurable) return;
    const a = i && i.get, c = i && i.set;
    a && !c || 2 !== arguments.length || (n = t[e]);
    let l = !r && wt(n);
    Object.defineProperty(t, e, {
        enumerable: !0,
        configurable: !0,
        get: function() {
            const e = a ? a.call(t) : n;
            return ct.target && (s.depend(), l && (l.dep.depend(), Array.isArray(e) && (function t(e) {
                for(let n, o = 0, r = e.length; o < r; o++)(n = e[o]) && n.__ob__ && n.__ob__.dep.depend(), Array.isArray(n) && t(n);
            })(e))), e;
        },
        set: function(e) {
            const o = a ? a.call(t) : n;
            e === o || e != e && o != o || a && !c || (c ? c.call(t, e) : n = e, l = !r && wt(e), s.notify());
        }
    });
}
function xt(t, e, n) {
    if (Array.isArray(t) && c(e)) return t.length = Math.max(t.length, e), t.splice(e, 1, n), n;
    if (e in t && !(e in Object.prototype)) return t[e] = n, n;
    const o = t.__ob__;
    return t._isVue || o && o.vmCount ? n : o ? (Ct(o.value, e, n), o.dep.notify(), n) : (t[e] = n, n);
}
function kt(t, e) {
    if (Array.isArray(t) && c(e)) return void t.splice(e, 1);
    const n = t.__ob__;
    t._isVue || n && n.vmCount || g(t, e) && (delete t[e], n && n.dep.notify());
}
const At = F.optionMergeStrategies;
function Ot(t, e) {
    if (!e) return t;
    let n, o, r;
    const s = rt ? Reflect.ownKeys(e) : Object.keys(e);
    for(let i = 0; i < s.length; i++)"__ob__" !== (n = s[i]) && (o = t[n], r = e[n], g(t, n) ? o !== r && a(o) && a(r) && Ot(o, r) : xt(t, n, r));
    return t;
}
function St(t, e, n) {
    return n ? function() {
        const o = "function" == typeof e ? e.call(n, n) : e, r = "function" == typeof t ? t.call(n, n) : t;
        return o ? Ot(o, r) : r;
    } : e ? t ? function() {
        return Ot("function" == typeof e ? e.call(this, this) : e, "function" == typeof t ? t.call(this, this) : t);
    } : e : t;
}
function Tt1(t, e) {
    const n = e ? t ? t.concat(e) : Array.isArray(e) ? e : [
        e
    ] : t;
    return n ? (function(t) {
        const e = [];
        for(let n = 0; n < t.length; n++)-1 === e.indexOf(t[n]) && e.push(t[n]);
        return e;
    })(n) : n;
}
function Nt(t, e, n, o) {
    const r = Object.create(t || null);
    return e ? A(r, e) : r;
}
At.data = function(t, e, n) {
    return n ? St(t, e, n) : e && "function" != typeof e ? t : St(t, e);
}, M.forEach((t)=>{
    At[t] = Tt1;
}), I.forEach(function(t) {
    At[t + "s"] = Nt;
}), At.watch = function(t, e, n, o) {
    if (t === Y && (t = void 0), e === Y && (e = void 0), !e) return Object.create(t || null);
    if (!t) return e;
    const r = {
    };
    A(r, t);
    for(const t5 in e){
        let n = r[t5];
        const o = e[t5];
        n && !Array.isArray(n) && (n = [
            n
        ]), r[t5] = n ? n.concat(o) : Array.isArray(o) ? o : [
            o
        ];
    }
    return r;
}, At.props = At.methods = At.inject = At.computed = function(t, e, n, o) {
    if (!t) return e;
    const r = Object.create(null);
    return A(r, t), e && A(r, e), r;
}, At.provide = St;
const Et = function(t, e) {
    return void 0 === e ? t : e;
};
function jt(t6, e, n) {
    if ("function" == typeof e && (e = e.options), (function(t, e) {
        const n = t.props;
        if (!n) return;
        const o = {
        };
        let r, s, i;
        if (Array.isArray(n)) for(r = n.length; r--;)"string" == typeof (s = n[r]) && (o[i = _(s)] = {
            type: null
        });
        else if (a(n)) for(const t5 in n)s = n[t5], o[i = _(t5)] = a(s) ? s : {
            type: s
        };
        t.props = o;
    })(e), (function(t, e) {
        const n = t.inject;
        if (!n) return;
        const o = t.inject = {
        };
        if (Array.isArray(n)) for(let t5 = 0; t5 < n.length; t5++)o[n[t5]] = {
            from: n[t5]
        };
        else if (a(n)) for(const t8 in n){
            const e = n[t8];
            o[t8] = a(e) ? A({
                from: t8
            }, e) : {
                from: e
            };
        }
    })(e), (function(t) {
        const e = t.directives;
        if (e) for(const t5 in e){
            const n = e[t5];
            "function" == typeof n && (e[t5] = {
                bind: n,
                update: n
            });
        }
    })(e), !e._base && (e.extends && (t6 = jt(t6, e.extends, n)), e.mixins)) for(let o = 0, r = e.mixins.length; o < r; o++)t6 = jt(t6, e.mixins[o], n);
    const o2 = {
    };
    let r2;
    for(r2 in t6)s(r2);
    for(r2 in e)g(t6, r2) || s(r2);
    function s(r) {
        const s = At[r] || Et;
        o2[r] = s(t6[r], e[r], n, r);
    }
    return o2;
}
function Dt(t, e, n, o) {
    if ("string" != typeof n) return;
    const r = t[e];
    if (g(r, n)) return r[n];
    const s = _(n);
    if (g(r, s)) return r[s];
    const i = b(s);
    return g(r, i) ? r[i] : r[n] || r[s] || r[i];
}
function Lt1(t, e, n, o) {
    const r = e[t], s = !g(n, t);
    let i = n[t];
    const a = Pt(Boolean, r.type);
    if (a > -1) {
        if (s && !g(r, "default")) i = !1;
        else if ("" === i || i === C(t)) {
            const t = Pt(String, r.type);
            (t < 0 || a < t) && (i = !0);
        }
    }
    if (void 0 === i) {
        i = (function(t, e, n) {
            if (!g(e, "default")) return;
            const o = e.default;
            if (t && t.$options.propsData && void 0 === t.$options.propsData[n] && void 0 !== t._props[n]) return t._props[n];
            return "function" == typeof o && "Function" !== Mt(e.type) ? o.call(t) : o;
        })(o, r, t);
        const e = $t;
        _t(!0), wt(i), _t(e);
    }
    return i;
}
const It = /^\s*function (\w+)/;
function Mt(t) {
    const e = t && t.toString().match(It);
    return e ? e[1] : "";
}
function Ft(t, e) {
    return Mt(t) === Mt(e);
}
function Pt(t, e) {
    if (!Array.isArray(e)) return Ft(e, t) ? 0 : -1;
    for(let n = 0, o = e.length; n < o; n++)if (Ft(e[n], t)) return n;
    return -1;
}
function Rt(t, e, n) {
    ut();
    try {
        if (e) {
            let o = e;
            for(; o = o.$parent;){
                const r = o.$options.errorCaptured;
                if (r) for(let s = 0; s < r.length; s++)try {
                    if (!1 === r[s].call(o, t, e, n)) return;
                } catch (t5) {
                    Bt(t5, o, "errorCaptured hook");
                }
            }
        }
        Bt(t, e, n);
    } finally{
        ft();
    }
}
function Ht(t, e, n, o, r) {
    let s;
    try {
        (s = n ? t.apply(e, n) : t.call(e)) && !s._isVue && l(s) && !s._handled && (s.catch((t)=>Rt(t, o, r + " (Promise/async)")
        ), s._handled = !0);
    } catch (t5) {
        Rt(t5, o, r);
    }
    return s;
}
function Bt(t, e, n) {
    if (F.errorHandler) try {
        return F.errorHandler.call(null, t, e, n);
    } catch (e3) {
        e3 !== t && Ut(e3, null, "config.errorHandler");
    }
    Ut(t, e, n);
}
function Ut(t, e, n) {
    if (!V && !z || "undefined" == typeof console) throw t;
    console.error(t);
}
let Vt = !1;
const zt = [];
let Kt, Jt = !1;
function qt() {
    Jt = !1;
    const t = zt.slice(0);
    zt.length = 0;
    for(let e = 0; e < t.length; e++)t[e]();
}
if ("undefined" != typeof Promise && ot(Promise)) {
    const t = Promise.resolve();
    Kt = ()=>{
        t.then(qt), G && setTimeout(S1);
    }, Vt = !0;
} else if (q || "undefined" == typeof MutationObserver || !ot(MutationObserver) && "[object MutationObserverConstructor]" !== MutationObserver.toString()) Kt = "undefined" != typeof setImmediate && ot(setImmediate) ? ()=>{
    setImmediate(qt);
} : ()=>{
    setTimeout(qt, 0);
};
else {
    let t = 1;
    const e = new MutationObserver(qt), n = document.createTextNode(String(t));
    e.observe(n, {
        characterData: !0
    }), Kt = ()=>{
        t = (t + 1) % 2, n.data = String(t);
    }, Vt = !0;
}
function Wt(t, e) {
    let n;
    if (zt.push(()=>{
        if (t) try {
            t.call(e);
        } catch (t5) {
            Rt(t5, e, "nextTick");
        }
        else n && n(e);
    }), Jt || (Jt = !0, Kt()), !t && "undefined" != typeof Promise) return new Promise((t)=>{
        n = t;
    });
}
const Zt = new st;
function Gt(t) {
    !function t(e, n) {
        let o, r;
        const i = Array.isArray(e);
        if (!i && !s(e) || Object.isFrozen(e) || e instanceof dt) return;
        if (e.__ob__) {
            const t = e.__ob__.dep.id;
            if (n.has(t)) return;
            n.add(t);
        }
        if (i) for(o = e.length; o--;)t(e[o], n);
        else for(r = Object.keys(e), o = r.length; o--;)t(e[r[o]], n);
    }(t, Zt), Zt.clear();
}
const Xt = v((t)=>{
    const e = "&" === t.charAt(0), n = "~" === (t = e ? t.slice(1) : t).charAt(0), o = "!" === (t = n ? t.slice(1) : t).charAt(0);
    return {
        name: t = o ? t.slice(1) : t,
        once: n,
        capture: o,
        passive: e
    };
});
function Yt(t, e) {
    function n() {
        const t = n.fns;
        if (!Array.isArray(t)) return Ht(t, null, arguments, e, "v-on handler");
        {
            const n = t.slice();
            for(let t5 = 0; t5 < n.length; t5++)Ht(n[t5], null, arguments, e, "v-on handler");
        }
    }
    return n.fns = t, n;
}
function Qt(t, n, r, s, i, a) {
    let c, l, u, f, d;
    for(c in t)l = u = t[c], f = n[c], d = Xt(c), e4(u) || (e4(f) ? (e4(u.fns) && (u = t[c] = Yt(u, a)), o3(d.once) && (u = t[c] = i(d.name, u, d.capture)), r(d.name, u, d.capture, d.passive, d.params)) : u !== f && (f.fns = u, t[c] = f));
    for(c in n)e4(t[c]) && s((d = Xt(c)).name, n[c], d.capture);
}
function te(t, r, s) {
    let i;
    t instanceof dt && (t = t.data.hook || (t.data.hook = {
    }));
    const a = t[r];
    function c() {
        s.apply(this, arguments), m(i.fns, c);
    }
    e4(a) ? i = Yt([
        c
    ]) : n2(a.fns) && o3(a.merged) ? (i = a).fns.push(c) : i = Yt([
        a,
        c
    ]), i.merged = !0, t[r] = i;
}
function ee(t, e, o, r, s) {
    if (n2(e)) {
        if (g(e, o)) return t[o] = e[o], s || delete e[o], !0;
        if (g(e, r)) return t[o] = e[r], s || delete e[r], !0;
    }
    return !1;
}
function ne(t) {
    return r3(t) ? [
        ht(t)
    ] : Array.isArray(t) ? (function t(s, i) {
        const a = [];
        let c, l, u, f;
        for(c = 0; c < s.length; c++)e4(l = s[c]) || "boolean" == typeof l || (u = a.length - 1, f = a[u], Array.isArray(l) ? l.length > 0 && (oe((l = t(l, `${i || ""}_${c}`))[0]) && oe(f) && (a[u] = ht(f.text + l[0].text), l.shift()), a.push.apply(a, l)) : r3(l) ? oe(f) ? a[u] = ht(f.text + l) : "" !== l && a.push(ht(l)) : oe(l) && oe(f) ? a[u] = ht(f.text + l.text) : (o3(s._isVList) && n2(l.tag) && e4(l.key) && n2(i) && (l.key = `__vlist${i}_${c}__`), a.push(l)));
        return a;
    })(t) : void 0;
}
function oe(t) {
    return n2(t) && n2(t.text) && !1 === t.isComment;
}
function re(t, e) {
    if (t) {
        const n = Object.create(null), o = rt ? Reflect.ownKeys(t) : Object.keys(t);
        for(let r = 0; r < o.length; r++){
            const s = o[r];
            if ("__ob__" === s) continue;
            const i = t[s].from;
            let a = e;
            for(; a;){
                if (a._provided && g(a._provided, i)) {
                    n[s] = a._provided[i];
                    break;
                }
                a = a.$parent;
            }
            if (!a && "default" in t[s]) {
                const o = t[s].default;
                n[s] = "function" == typeof o ? o.call(e) : o;
            }
        }
        return n;
    }
}
function se(t, e) {
    if (!t || !t.length) return {
    };
    const n = {
    };
    for(let o = 0, r = t.length; o < r; o++){
        const r = t[o], s = r.data;
        if (s && s.attrs && s.attrs.slot && delete s.attrs.slot, r.context !== e && r.fnContext !== e || !s || null == s.slot) (n.default || (n.default = [])).push(r);
        else {
            const t = s.slot, e = n[t] || (n[t] = []);
            "template" === r.tag ? e.push.apply(e, r.children || []) : e.push(r);
        }
    }
    for(const t5 in n)n[t5].every(ie) && delete n[t5];
    return n;
}
function ie(t) {
    return t.isComment && !t.asyncFactory || " " === t.text;
}
function ae(t) {
    return t.isComment && t.asyncFactory;
}
function ce(e, n, o) {
    let r;
    const s = Object.keys(n).length > 0, i = e ? !!e.$stable : !s, a = e && e.$key;
    if (e) {
        if (e._normalized) return e._normalized;
        if (i && o && o !== t7 && a === o.$key && !s && !o.$hasNormal) return o;
        r = {
        };
        for(const t5 in e)e[t5] && "$" !== t5[0] && (r[t5] = le(n, t5, e[t5]));
    } else r = {
    };
    for(const t in n)t in r || (r[t] = ue(n, t));
    return e && Object.isExtensible(e) && (e._normalized = r), H(r, "$stable", i), H(r, "$key", a), H(r, "$hasNormal", s), r;
}
function le(t, e, n) {
    const o = function() {
        let t = arguments.length ? n.apply(null, arguments) : n({
        }), e = (t = t && "object" == typeof t && !Array.isArray(t) ? [
            t
        ] : ne(t)) && t[0];
        return t && (!e || 1 === t.length && e.isComment && !ae(e)) ? void 0 : t;
    };
    return n.proxy && Object.defineProperty(t, e, {
        get: o,
        enumerable: !0,
        configurable: !0
    }), o;
}
function ue(t, e) {
    return ()=>t[e]
    ;
}
function fe(t, e) {
    let o, r, i, a, c;
    if (Array.isArray(t) || "string" == typeof t) for(o = new Array(t.length), r = 0, i = t.length; r < i; r++)o[r] = e(t[r], r);
    else if ("number" == typeof t) for(o = new Array(t), r = 0; r < t; r++)o[r] = e(r + 1, r);
    else if (s(t)) if (rt && t[Symbol.iterator]) {
        o = [];
        const n = t[Symbol.iterator]();
        let r = n.next();
        for(; !r.done;)o.push(e(r.value, o.length)), r = n.next();
    } else for(a = Object.keys(t), o = new Array(a.length), r = 0, i = a.length; r < i; r++)c = a[r], o[r] = e(t[c], c, r);
    return n2(o) || (o = []), o._isVList = !0, o;
}
function de(t, e, n, o) {
    const r = this.$scopedSlots[t];
    let s;
    r ? (n = n || {
    }, o && (n = A(A({
    }, o), n)), s = r(n) || ("function" == typeof e ? e() : e)) : s = this.$slots[t] || ("function" == typeof e ? e() : e);
    const i = n && n.slot;
    return i ? this.$createElement("template", {
        slot: i
    }, s) : s;
}
function pe(t) {
    return Dt(this.$options, "filters", t) || N;
}
function he(t, e) {
    return Array.isArray(t) ? -1 === t.indexOf(e) : t !== e;
}
function me(t, e, n, o, r) {
    const s = F.keyCodes[e] || n;
    return r && o && !F.keyCodes[e] ? he(r, o) : s ? he(s, t) : o ? C(o) !== e : void 0 === t;
}
function ye(t, e, n, o, r) {
    if (n) if (s(n)) {
        let s;
        Array.isArray(n) && (n = O(n));
        for(const i in n){
            if ("class" === i || "style" === i || h(i)) s = t;
            else {
                const n = t.attrs && t.attrs.type;
                s = o || F.mustUseProp(e, n, i) ? t.domProps || (t.domProps = {
                }) : t.attrs || (t.attrs = {
                });
            }
            const a = _(i), c = C(i);
            if (!(a in s || c in s) && (s[i] = n[i], r)) {
                (t.on || (t.on = {
                }))[`update:${i}`] = function(t) {
                    n[i] = t;
                };
            }
        }
    } else ;
    return t;
}
function ge(t, e) {
    const n = this._staticTrees || (this._staticTrees = []);
    let o = n[t];
    return o && !e ? o : ($e(o = n[t] = this.$options.staticRenderFns[t].call(this._renderProxy, null, this), `__static__${t}`, !1), o);
}
function ve(t, e, n) {
    return $e(t, `__once__${e}${n ? `_${n}` : ""}`, !0), t;
}
function $e(t, e, n) {
    if (Array.isArray(t)) for(let o = 0; o < t.length; o++)t[o] && "string" != typeof t[o] && _e(t[o], `${e}_${o}`, n);
    else _e(t, e, n);
}
function _e(t, e, n) {
    t.isStatic = !0, t.key = e, t.isOnce = n;
}
function be(t, e) {
    if (e) if (a(e)) {
        const n = t.on = t.on ? A({
        }, t.on) : {
        };
        for(const t5 in e){
            const o = n[t5], r = e[t5];
            n[t5] = o ? [].concat(o, r) : r;
        }
    } else ;
    return t;
}
function we(t, e, n, o) {
    e = e || {
        $stable: !n
    };
    for(let o2 = 0; o2 < t.length; o2++){
        const r = t[o2];
        Array.isArray(r) ? we(r, e, n) : r && (r.proxy && (r.fn.proxy = !0), e[r.key] = r.fn);
    }
    return o && (e.$key = o), e;
}
function Ce(t, e) {
    for(let n = 0; n < e.length; n += 2){
        const o = e[n];
        "string" == typeof o && o && (t[e[n]] = e[n + 1]);
    }
    return t;
}
function xe(t, e) {
    return "string" == typeof t ? e + t : t;
}
function ke(t) {
    t._o = ve, t._n = f, t._s = u2, t._l = fe, t._t = de, t._q = E, t._i = j, t._m = ge, t._f = pe, t._k = me, t._b = ye, t._v = ht, t._e = pt, t._u = we, t._g = be, t._d = Ce, t._p = xe;
}
function Ae(e, n, r, s, i) {
    const a = i.options;
    let c;
    g(s, "_uid") ? (c = Object.create(s))._original = s : (c = s, s = s._original);
    const l = o3(a._compiled), u = !l;
    this.data = e, this.props = n, this.children = r, this.parent = s, this.listeners = e.on || t7, this.injections = re(a.inject, s), this.slots = ()=>(this.$slots || ce(e.scopedSlots, this.$slots = se(r, s)), this.$slots)
    , Object.defineProperty(this, "scopedSlots", {
        enumerable: !0,
        get () {
            return ce(e.scopedSlots, this.slots());
        }
    }), l && (this.$options = a, this.$slots = this.slots(), this.$scopedSlots = ce(e.scopedSlots, this.$slots)), a._scopeId ? this._c = (t, e, n, o)=>{
        const r = Ie(c, t, e, n, o, u);
        return r && !Array.isArray(r) && (r.fnScopeId = a._scopeId, r.fnContext = s), r;
    } : this._c = (t, e, n, o)=>Ie(c, t, e, n, o, u)
    ;
}
function Oe(t, e, n, o, r) {
    const s = mt(t);
    return s.fnContext = n, s.fnOptions = o, e.slot && ((s.data || (s.data = {
    })).slot = e.slot), s;
}
function Se(t, e) {
    for(const n in e)t[_(n)] = e[n];
}
ke(Ae.prototype);
const Te = {
    init (t, e) {
        if (t.componentInstance && !t.componentInstance._isDestroyed && t.data.keepAlive) {
            const e = t;
            Te.prepatch(e, e);
        } else {
            (t.componentInstance = (function(t, e) {
                const o = {
                    _isComponent: !0,
                    _parentVnode: t,
                    parent: e
                }, r = t.data.inlineTemplate;
                n2(r) && (o.render = r.render, o.staticRenderFns = r.staticRenderFns);
                return new t.componentOptions.Ctor(o);
            })(t, ze)).$mount(e ? t.elm : void 0, e);
        }
    },
    prepatch (e, n) {
        const o = n.componentOptions;
        !function(e, n, o, r, s) {
            const i = r.data.scopedSlots, a = e.$scopedSlots, c = !!(i && !i.$stable || a !== t7 && !a.$stable || i && e.$scopedSlots.$key !== i.$key || !i && e.$scopedSlots.$key), l = !!(s || e.$options._renderChildren || c);
            e.$options._parentVnode = r, e.$vnode = r, e._vnode && (e._vnode.parent = r);
            if (e.$options._renderChildren = s, e.$attrs = r.data.attrs || t7, e.$listeners = o || t7, n && e.$options.props) {
                _t(!1);
                const t = e._props, o = e.$options._propKeys || [];
                for(let r = 0; r < o.length; r++){
                    const s = o[r], i = e.$options.props;
                    t[s] = Lt1(s, i, n, e);
                }
                _t(!0), e.$options.propsData = n;
            }
            o = o || t7;
            const u = e.$options._parentListeners;
            e.$options._parentListeners = o, Ve(e, o, u), l && (e.$slots = se(s, r.context), e.$forceUpdate());
        }(n.componentInstance = e.componentInstance, o.propsData, o.listeners, n, o.children);
    },
    insert (t) {
        const { context: e , componentInstance: n  } = t;
        var o;
        n._isMounted || (n._isMounted = !0, We(n, "mounted")), t.data.keepAlive && (e._isMounted ? ((o = n)._inactive = !1, Ge.push(o)) : qe(n, !0));
    },
    destroy (t) {
        const { componentInstance: e  } = t;
        e._isDestroyed || (t.data.keepAlive ? (function t(e, n) {
            if (n && (e._directInactive = !0, Je(e))) return;
            if (!e._inactive) {
                e._inactive = !0;
                for(let n = 0; n < e.$children.length; n++)t(e.$children[n]);
                We(e, "deactivated");
            }
        })(e, !0) : e.$destroy());
    }
}, Ne = Object.keys(Te);
function Ee(r, i, a, c, u) {
    if (e4(r)) return;
    const f = a.$options._base;
    if (s(r) && (r = f.extend(r)), "function" != typeof r) return;
    let d;
    if (e4(r.cid) && void 0 === (r = (function(t6, r) {
        if (o3(t6.error) && n2(t6.errorComp)) return t6.errorComp;
        if (n2(t6.resolved)) return t6.resolved;
        const i = Fe;
        i && n2(t6.owners) && -1 === t6.owners.indexOf(i) && t6.owners.push(i);
        if (o3(t6.loading) && n2(t6.loadingComp)) return t6.loadingComp;
        if (i && !n2(t6.owners)) {
            const o = t6.owners = [
                i
            ];
            let a = !0, c = null, u = null;
            i.$on("hook:destroyed", ()=>m(o, i)
            );
            const f = (t)=>{
                for(let t5 = 0, e = o.length; t5 < e; t5++)o[t5].$forceUpdate();
                t && (o.length = 0, null !== c && (clearTimeout(c), c = null), null !== u && (clearTimeout(u), u = null));
            }, d = D((e)=>{
                t6.resolved = Pe(e, r), a ? o.length = 0 : f(!0);
            }), p = D((e)=>{
                n2(t6.errorComp) && (t6.error = !0, f(!0));
            }), h = t6(d, p);
            return s(h) && (l(h) ? e4(t6.resolved) && h.then(d, p) : l(h.component) && (h.component.then(d, p), n2(h.error) && (t6.errorComp = Pe(h.error, r)), n2(h.loading) && (t6.loadingComp = Pe(h.loading, r), 0 === h.delay ? t6.loading = !0 : c = setTimeout(()=>{
                c = null, e4(t6.resolved) && e4(t6.error) && (t6.loading = !0, f(!1));
            }, h.delay || 200)), n2(h.timeout) && (u = setTimeout(()=>{
                u = null, e4(t6.resolved) && p(null);
            }, h.timeout)))), a = !1, t6.loading ? t6.loadingComp : t6.resolved;
        }
    })(d = r, f))) return (function(t, e, n, o, r) {
        const s = pt();
        return s.asyncFactory = t, s.asyncMeta = {
            data: e,
            context: n,
            children: o,
            tag: r
        }, s;
    })(d, i, a, c, u);
    i = i || {
    }, yn(r), n2(i.model) && (function(t, e) {
        const o = t.model && t.model.prop || "value", r = t.model && t.model.event || "input";
        (e.attrs || (e.attrs = {
        }))[o] = e.model.value;
        const s = e.on || (e.on = {
        }), i = s[r], a = e.model.callback;
        n2(i) ? (Array.isArray(i) ? -1 === i.indexOf(a) : i !== a) && (s[r] = [
            a
        ].concat(i)) : s[r] = a;
    })(r.options, i);
    const p = function(t, o, r) {
        const s = o.options.props;
        if (e4(s)) return;
        const i = {
        }, { attrs: a , props: c  } = t;
        if (n2(a) || n2(c)) for(const t5 in s){
            const e = C(t5);
            ee(i, c, t5, e, !0) || ee(i, a, t5, e, !1);
        }
        return i;
    }(i, r);
    if (o3(r.options.functional)) return (function(e, o, r, s, i) {
        const a = e.options, c = {
        }, l = a.props;
        if (n2(l)) for(const e3 in l)c[e3] = Lt1(e3, l, o || t7);
        else n2(r.attrs) && Se(c, r.attrs), n2(r.props) && Se(c, r.props);
        const u = new Ae(r, c, i, s, e), f = a.render.call(null, u._c, u);
        if (f instanceof dt) return Oe(f, r, u.parent, a);
        if (Array.isArray(f)) {
            const t = ne(f) || [], e = new Array(t.length);
            for(let n = 0; n < t.length; n++)e[n] = Oe(t[n], r, u.parent, a);
            return e;
        }
    })(r, p, i, a, c);
    const h = i.on;
    if (i.on = i.nativeOn, o3(r.options.abstract)) {
        const t = i.slot;
        i = {
        }, t && (i.slot = t);
    }
    !function(t) {
        const e = t.hook || (t.hook = {
        });
        for(let t5 = 0; t5 < Ne.length; t5++){
            const n = Ne[t5], o = e[n], r = Te[n];
            o === r || o && o._merged || (e[n] = o ? je(r, o) : r);
        }
    }(i);
    const y = r.options.name || u;
    return new dt(`vue-component-${r.cid}${y ? `-${y}` : ""}`, i, void 0, void 0, void 0, a, {
        Ctor: r,
        propsData: p,
        listeners: h,
        tag: u,
        children: c
    }, d);
}
function je(t, e) {
    const n = (n, o)=>{
        t(n, o), e(n, o);
    };
    return n._merged = !0, n;
}
const Le = 2;
function Ie(t, i, a, c, l, u) {
    return (Array.isArray(a) || r3(a)) && (l = c, c = a, a = void 0), o3(u) && (l = Le), (function(t, r, i, a, c) {
        if (n2(i) && n2(i.__ob__)) return pt();
        n2(i) && n2(i.is) && (r = i.is);
        if (!r) return pt();
        Array.isArray(a) && "function" == typeof a[0] && ((i = i || {
        }).scopedSlots = {
            default: a[0]
        }, a.length = 0);
        c === 2 ? a = ne(a) : c === 1 && (a = (function(t) {
            for(let e = 0; e < t.length; e++)if (Array.isArray(t[e])) return Array.prototype.concat.apply([], t);
            return t;
        })(a));
        let l, u;
        if ("string" == typeof r) {
            let e;
            u = t.$vnode && t.$vnode.ns || F.getTagNamespace(r), l = F.isReservedTag(r) ? new dt(F.parsePlatformTagName(r), i, a, void 0, void 0, t) : i && i.pre || !n2(e = Dt(t.$options, "components", r)) ? new dt(r, i, a, void 0, void 0, t) : Ee(e, i, t, a, r);
        } else l = Ee(r, i, t, a);
        return Array.isArray(l) ? l : n2(l) ? (n2(u) && (function t(r, s, i) {
            r.ns = s;
            "foreignObject" === r.tag && (s = void 0, i = !0);
            if (n2(r.children)) for(let a = 0, c = r.children.length; a < c; a++){
                const c = r.children[a];
                n2(c.tag) && (e4(c.ns) || o3(i) && "svg" !== c.tag) && t(c, s, i);
            }
        })(l, u), n2(i) && (function(t) {
            s(t.style) && Gt(t.style);
            s(t.class) && Gt(t.class);
        })(i), l) : pt();
    })(t, i, a, c, l);
}
let Me, Fe = null;
function Pe(t, e) {
    return (t.__esModule || rt && "Module" === t[Symbol.toStringTag]) && (t = t.default), s(t) ? e.extend(t) : t;
}
function Re(t) {
    if (Array.isArray(t)) for(let e = 0; e < t.length; e++){
        const o = t[e];
        if (n2(o) && (n2(o.componentOptions) || ae(o))) return o;
    }
}
function He(t, e) {
    Me.$on(t, e);
}
function Be(t, e) {
    Me.$off(t, e);
}
function Ue(t, e) {
    const n = Me;
    return function o() {
        null !== e.apply(null, arguments) && n.$off(t, o);
    };
}
function Ve(t, e, n) {
    Me = t, Qt(e, n || {
    }, He, Be, Ue, t), Me = void 0;
}
let ze = null;
function Ke(t) {
    const e = ze;
    return ze = t, ()=>{
        ze = e;
    };
}
function Je(t) {
    for(; t && (t = t.$parent);)if (t._inactive) return !0;
    return !1;
}
function qe(t, e) {
    if (e) {
        if (t._directInactive = !1, Je(t)) return;
    } else if (t._directInactive) return;
    if (t._inactive || null === t._inactive) {
        t._inactive = !1;
        for(let e = 0; e < t.$children.length; e++)qe(t.$children[e]);
        We(t, "activated");
    }
}
function We(t, e) {
    ut();
    const n = t.$options[e], o = `${e} hook`;
    if (n) for(let e3 = 0, r = n.length; e3 < r; e3++)Ht(n[e3], t, null, t, o);
    t._hasHookEvent && t.$emit("hook:" + e), ft();
}
const Ze = [], Ge = [];
let Xe = {
}, Ye = !1, Qe = !1, tn = 0;
let en = 0, nn = Date.now;
if (V && !q) {
    const t = window.performance;
    t && "function" == typeof t.now && nn() > document.createEvent("Event").timeStamp && (nn = ()=>t.now()
    );
}
function on() {
    let t, e;
    for(en = nn(), Qe = !0, Ze.sort((t, e)=>t.id - e.id
    ), tn = 0; tn < Ze.length; tn++)(t = Ze[tn]).before && t.before(), e = t.id, Xe[e] = null, t.run();
    const n = Ge.slice(), o = Ze.slice();
    tn = Ze.length = Ge.length = 0, Xe = {
    }, Ye = Qe = !1, (function(t) {
        for(let e = 0; e < t.length; e++)t[e]._inactive = !0, qe(t[e], !0);
    })(n), (function(t) {
        let e = t.length;
        for(; e--;){
            const n = t[e], o = n.vm;
            o._watcher === n && o._isMounted && !o._isDestroyed && We(o, "updated");
        }
    })(o), nt && F.devtools && nt.emit("flush");
}
let rn = 0;
class sn {
    constructor(t5, e3, n3, o2, r2){
        this.vm = t5, r2 && (t5._watcher = this), t5._watchers.push(this), o2 ? (this.deep = !!o2.deep, this.user = !!o2.user, this.lazy = !!o2.lazy, this.sync = !!o2.sync, this.before = o2.before) : this.deep = this.user = this.lazy = this.sync = !1, this.cb = n3, this.id = ++rn, this.active = !0, this.dirty = this.lazy, this.deps = [], this.newDeps = [], this.depIds = new st, this.newDepIds = new st, this.expression = "", "function" == typeof e3 ? this.getter = e3 : (this.getter = (function(t) {
            if (B1.test(t)) return;
            const e = t.split(".");
            return function(t) {
                for(let n = 0; n < e.length; n++){
                    if (!t) return;
                    t = t[e[n]];
                }
                return t;
            };
        })(e3), this.getter || (this.getter = S1)), this.value = this.lazy ? void 0 : this.get();
    }
    get() {
        let t;
        ut(this);
        const e = this.vm;
        try {
            t = this.getter.call(e, e);
        } catch (t6) {
            if (!this.user) throw t6;
            Rt(t6, e, `getter for watcher "${this.expression}"`);
        } finally{
            this.deep && Gt(t), ft(), this.cleanupDeps();
        }
        return t;
    }
    addDep(t) {
        const e = t.id;
        this.newDepIds.has(e) || (this.newDepIds.add(e), this.newDeps.push(t), this.depIds.has(e) || t.addSub(this));
    }
    cleanupDeps() {
        let t = this.deps.length;
        for(; t--;){
            const e = this.deps[t];
            this.newDepIds.has(e.id) || e.removeSub(this);
        }
        let e = this.depIds;
        this.depIds = this.newDepIds, this.newDepIds = e, this.newDepIds.clear(), e = this.deps, this.deps = this.newDeps, this.newDeps = e, this.newDeps.length = 0;
    }
    update() {
        this.lazy ? this.dirty = !0 : this.sync ? this.run() : (function(t) {
            const e = t.id;
            if (null == Xe[e]) {
                if (Xe[e] = !0, Qe) {
                    let e = Ze.length - 1;
                    for(; e > tn && Ze[e].id > t.id;)e--;
                    Ze.splice(e + 1, 0, t);
                } else Ze.push(t);
                Ye || (Ye = !0, Wt(on));
            }
        })(this);
    }
    run() {
        if (this.active) {
            const t = this.get();
            if (t !== this.value || s(t) || this.deep) {
                const e = this.value;
                if (this.value = t, this.user) {
                    const n = `callback for watcher "${this.expression}"`;
                    Ht(this.cb, this.vm, [
                        t,
                        e
                    ], this.vm, n);
                } else this.cb.call(this.vm, t, e);
            }
        }
    }
    evaluate() {
        this.value = this.get(), this.dirty = !1;
    }
    depend() {
        let t = this.deps.length;
        for(; t--;)this.deps[t].depend();
    }
    teardown() {
        if (this.active) {
            this.vm._isBeingDestroyed || m(this.vm._watchers, this);
            let t = this.deps.length;
            for(; t--;)this.deps[t].removeSub(this);
            this.active = !1;
        }
    }
}
const an = {
    enumerable: !0,
    configurable: !0,
    get: S1,
    set: S1
};
function cn(t, e, n) {
    an.get = function() {
        return this[e][n];
    }, an.set = function(t) {
        this[e][n] = t;
    }, Object.defineProperty(t, n, an);
}
function ln(t) {
    t._watchers = [];
    const e = t.$options;
    e.props && (function(t, e) {
        const n = t.$options.propsData || {
        }, o = t._props = {
        }, r = t.$options._propKeys = [];
        t.$parent && _t(!1);
        for(const s in e){
            r.push(s);
            const i = Lt1(s, e, n, t);
            Ct(o, s, i), s in t || cn(t, "_props", s);
        }
        _t(!0);
    })(t, e.props), e.methods && (function(t, e) {
        t.$options.props;
        for(const n in e)t[n] = "function" != typeof e[n] ? S1 : x(e[n], t);
    })(t, e.methods), e.data ? (function(t) {
        let e = t.$options.data;
        a(e = t._data = "function" == typeof e ? function(t, e) {
            ut();
            try {
                return t.call(e, e);
            } catch (t6) {
                return Rt(t6, e, "data()"), {
                };
            } finally{
                ft();
            }
        }(e, t) : e || {
        }) || (e = {
        });
        const n = Object.keys(e), o = t.$options.props;
        t.$options.methods;
        let r = n.length;
        for(; r--;){
            const e = n[r];
            o && g(o, e) || R(e) || cn(t, "_data", e);
        }
        wt(e, !0);
    })(t) : wt(t._data = {
    }, !0), e.computed && (function(t, e) {
        const n = t._computedWatchers = Object.create(null), o = et();
        for(const r in e){
            const s = e[r], i = "function" == typeof s ? s : s.get;
            o || (n[r] = new sn(t, i || S1, S1, un)), r in t || fn(t, r, s);
        }
    })(t, e.computed), e.watch && e.watch !== Y && (function(t, e) {
        for(const n in e){
            const o = e[n];
            if (Array.isArray(o)) for(let e5 = 0; e5 < o.length; e5++)hn(t, n, o[e5]);
            else hn(t, n, o);
        }
    })(t, e.watch);
}
const un = {
    lazy: !0
};
function fn(t, e, n) {
    const o = !et();
    "function" == typeof n ? (an.get = o ? dn(e) : pn(n), an.set = S1) : (an.get = n.get ? o && !1 !== n.cache ? dn(e) : pn(n.get) : S1, an.set = n.set || S1), Object.defineProperty(t, e, an);
}
function dn(t) {
    return function() {
        const e = this._computedWatchers && this._computedWatchers[t];
        if (e) return e.dirty && e.evaluate(), ct.target && e.depend(), e.value;
    };
}
function pn(t) {
    return function() {
        return t.call(this, this);
    };
}
function hn(t, e, n, o) {
    return a(n) && (o = n, n = n.handler), "string" == typeof n && (n = t[n]), t.$watch(e, n, o);
}
let mn = 0;
function yn(t) {
    let e = t.options;
    if (t.super) {
        const n = yn(t.super);
        if (n !== t.superOptions) {
            t.superOptions = n;
            const o = function(t) {
                let e;
                const n = t.options, o = t.sealedOptions;
                for(const t6 in n)n[t6] !== o[t6] && (e || (e = {
                }), e[t6] = n[t6]);
                return e;
            }(t);
            o && A(t.extendOptions, o), (e = t.options = jt(n, t.extendOptions)).name && (e.components[e.name] = t);
        }
    }
    return e;
}
function gn(t) {
    this._init(t);
}
function vn(t) {
    t.cid = 0;
    let e = 1;
    t.extend = function(t) {
        t = t || {
        };
        const n = this, o = n.cid, r = t._Ctor || (t._Ctor = {
        });
        if (r[o]) return r[o];
        const s = t.name || n.options.name, i = function(t) {
            this._init(t);
        };
        return (i.prototype = Object.create(n.prototype)).constructor = i, i.cid = e++, i.options = jt(n.options, t), i.super = n, i.options.props && (function(t) {
            const e = t.options.props;
            for(const n in e)cn(t.prototype, "_props", n);
        })(i), i.options.computed && (function(t) {
            const e = t.options.computed;
            for(const n in e)fn(t.prototype, n, e[n]);
        })(i), i.extend = n.extend, i.mixin = n.mixin, i.use = n.use, I.forEach(function(t) {
            i[t] = n[t];
        }), s && (i.options.components[s] = i), i.superOptions = n.options, i.extendOptions = t, i.sealedOptions = A({
        }, i.options), r[o] = i, i;
    };
}
function $n(t) {
    return t && (t.Ctor.options.name || t.tag);
}
function _n(t, e) {
    return Array.isArray(t) ? t.indexOf(e) > -1 : "string" == typeof t ? t.split(",").indexOf(e) > -1 : (n = t, "[object RegExp]" === i3.call(n) && t.test(e));
    var n;
}
function bn(t, e) {
    const { cache: n , keys: o , _vnode: r  } = t;
    for(const t6 in n){
        const s = n[t6];
        if (s) {
            const i = s.name;
            i && !e(i) && wn(n, t6, o, r);
        }
    }
}
function wn(t, e, n, o) {
    const r = t[e];
    !r || o && r.tag === o.tag || r.componentInstance.$destroy(), t[e] = null, m(n, e);
}
!function(e) {
    e.prototype._init = function(e) {
        const n = this;
        n._uid = mn++, n._isVue = !0, e && e._isComponent ? (function(t, e) {
            const n = t.$options = Object.create(t.constructor.options), o = e._parentVnode;
            n.parent = e.parent, n._parentVnode = o;
            const r = o.componentOptions;
            n.propsData = r.propsData, n._parentListeners = r.listeners, n._renderChildren = r.children, n._componentTag = r.tag, e.render && (n.render = e.render, n.staticRenderFns = e.staticRenderFns);
        })(n, e) : n.$options = jt(yn(n.constructor), e || {
        }, n), n._renderProxy = n, n._self = n, (function(t) {
            const e = t.$options;
            let n = e.parent;
            if (n && !e.abstract) {
                for(; n.$options.abstract && n.$parent;)n = n.$parent;
                n.$children.push(t);
            }
            t.$parent = n, t.$root = n ? n.$root : t, t.$children = [], t.$refs = {
            }, t._watcher = null, t._inactive = null, t._directInactive = !1, t._isMounted = !1, t._isDestroyed = !1, t._isBeingDestroyed = !1;
        })(n), (function(t) {
            t._events = Object.create(null), t._hasHookEvent = !1;
            const e = t.$options._parentListeners;
            e && Ve(t, e);
        })(n), (function(e) {
            e._vnode = null, e._staticTrees = null;
            const n = e.$options, o = e.$vnode = n._parentVnode, r = o && o.context;
            e.$slots = se(n._renderChildren, r), e.$scopedSlots = t7, e._c = (t, n, o, r)=>Ie(e, t, n, o, r, !1)
            , e.$createElement = (t, n, o, r)=>Ie(e, t, n, o, r, !0)
            ;
            const s = o && o.data;
            Ct(e, "$attrs", s && s.attrs || t7, null, !0), Ct(e, "$listeners", n._parentListeners || t7, null, !0);
        })(n), We(n, "beforeCreate"), (function(t) {
            const e = re(t.$options.inject, t);
            e && (_t(!1), Object.keys(e).forEach((n)=>{
                Ct(t, n, e[n]);
            }), _t(!0));
        })(n), ln(n), (function(t) {
            const e = t.$options.provide;
            e && (t._provided = "function" == typeof e ? e.call(t) : e);
        })(n), We(n, "created"), n.$options.el && n.$mount(n.$options.el);
    };
}(gn), (function(t) {
    const e = {
        get: function() {
            return this._data;
        }
    }, n = {
        get: function() {
            return this._props;
        }
    };
    Object.defineProperty(t.prototype, "$data", e), Object.defineProperty(t.prototype, "$props", n), t.prototype.$set = xt, t.prototype.$delete = kt, t.prototype.$watch = function(t, e, n) {
        const o = this;
        if (a(e)) return hn(o, t, e, n);
        (n = n || {
        }).user = !0;
        const r = new sn(o, t, e, n);
        if (n.immediate) {
            const t = `callback for immediate watcher "${r.expression}"`;
            ut(), Ht(e, o, [
                r.value
            ], o, t), ft();
        }
        return function() {
            r.teardown();
        };
    };
})(gn), (function(t) {
    const e = /^hook:/;
    t.prototype.$on = function(t, n) {
        const o = this;
        if (Array.isArray(t)) for(let e5 = 0, r = t.length; e5 < r; e5++)o.$on(t[e5], n);
        else (o._events[t] || (o._events[t] = [])).push(n), e.test(t) && (o._hasHookEvent = !0);
        return o;
    }, t.prototype.$once = function(t, e) {
        const n = this;
        function o() {
            n.$off(t, o), e.apply(n, arguments);
        }
        return o.fn = e, n.$on(t, o), n;
    }, t.prototype.$off = function(t, e) {
        const n = this;
        if (!arguments.length) return n._events = Object.create(null), n;
        if (Array.isArray(t)) {
            for(let o = 0, r = t.length; o < r; o++)n.$off(t[o], e);
            return n;
        }
        const o = n._events[t];
        if (!o) return n;
        if (!e) return n._events[t] = null, n;
        let r, s = o.length;
        for(; s--;)if ((r = o[s]) === e || r.fn === e) {
            o.splice(s, 1);
            break;
        }
        return n;
    }, t.prototype.$emit = function(t) {
        const e = this;
        let n = e._events[t];
        if (n) {
            n = n.length > 1 ? k(n) : n;
            const o = k(arguments, 1), r = `event handler for "${t}"`;
            for(let t6 = 0, s = n.length; t6 < s; t6++)Ht(n[t6], e, o, e, r);
        }
        return e;
    };
})(gn), (function(t) {
    t.prototype._update = function(t, e) {
        const n = this, o = n.$el, r = n._vnode, s = Ke(n);
        n._vnode = t, n.$el = r ? n.__patch__(r, t) : n.__patch__(n.$el, t, e, !1), s(), o && (o.__vue__ = null), n.$el && (n.$el.__vue__ = n), n.$vnode && n.$parent && n.$vnode === n.$parent._vnode && (n.$parent.$el = n.$el);
    }, t.prototype.$forceUpdate = function() {
        const t = this;
        t._watcher && t._watcher.update();
    }, t.prototype.$destroy = function() {
        const t = this;
        if (t._isBeingDestroyed) return;
        We(t, "beforeDestroy"), t._isBeingDestroyed = !0;
        const e = t.$parent;
        !e || e._isBeingDestroyed || t.$options.abstract || m(e.$children, t), t._watcher && t._watcher.teardown();
        let n = t._watchers.length;
        for(; n--;)t._watchers[n].teardown();
        t._data.__ob__ && t._data.__ob__.vmCount--, t._isDestroyed = !0, t.__patch__(t._vnode, null), We(t, "destroyed"), t.$off(), t.$el && (t.$el.__vue__ = null), t.$vnode && (t.$vnode.parent = null);
    };
})(gn), (function(t) {
    ke(t.prototype), t.prototype.$nextTick = function(t) {
        return Wt(t, this);
    }, t.prototype._render = function() {
        const t = this, { render: e , _parentVnode: n  } = t.$options;
        let o;
        n && (t.$scopedSlots = ce(n.data.scopedSlots, t.$slots, t.$scopedSlots)), t.$vnode = n;
        try {
            Fe = t, o = e.call(t._renderProxy, t.$createElement);
        } catch (e5) {
            Rt(e5, t, "render"), o = t._vnode;
        } finally{
            Fe = null;
        }
        return Array.isArray(o) && 1 === o.length && (o = o[0]), o instanceof dt || (o = pt()), o.parent = n, o;
    };
})(gn);
const Cn = [
    String,
    RegExp,
    Array
];
var xn = {
    KeepAlive: {
        name: "keep-alive",
        abstract: !0,
        props: {
            include: Cn,
            exclude: Cn,
            max: [
                String,
                Number
            ]
        },
        methods: {
            cacheVNode () {
                const { cache: t , keys: e , vnodeToCache: n , keyToCache: o  } = this;
                if (n) {
                    const { tag: r , componentInstance: s , componentOptions: i  } = n;
                    t[o] = {
                        name: $n(i),
                        tag: r,
                        componentInstance: s
                    }, e.push(o), this.max && e.length > parseInt(this.max) && wn(t, e[0], e, this._vnode), this.vnodeToCache = null;
                }
            }
        },
        created () {
            this.cache = Object.create(null), this.keys = [];
        },
        destroyed () {
            for(const t in this.cache)wn(this.cache, t, this.keys);
        },
        mounted () {
            this.cacheVNode(), this.$watch("include", (t)=>{
                bn(this, (e)=>_n(t, e)
                );
            }), this.$watch("exclude", (t)=>{
                bn(this, (e)=>!_n(t, e)
                );
            });
        },
        updated () {
            this.cacheVNode();
        },
        render () {
            const t = this.$slots.default, e = Re(t), n = e && e.componentOptions;
            if (n) {
                const t = $n(n), { include: o , exclude: r  } = this;
                if (o && (!t || !_n(o, t)) || r && t && _n(r, t)) return e;
                const { cache: s , keys: i  } = this, a = null == e.key ? n.Ctor.cid + (n.tag ? `::${n.tag}` : "") : e.key;
                s[a] ? (e.componentInstance = s[a].componentInstance, m(i, a), i.push(a)) : (this.vnodeToCache = e, this.keyToCache = a), e.data.keepAlive = !0;
            }
            return e || t && t[0];
        }
    }
};
!function(t) {
    const e = {
        get: ()=>F
    };
    Object.defineProperty(t, "config", e), t.util = {
        warn: it,
        extend: A,
        mergeOptions: jt,
        defineReactive: Ct
    }, t.set = xt, t.delete = kt, t.nextTick = Wt, t.observable = (t)=>(wt(t), t)
    , t.options = Object.create(null), I.forEach((e)=>{
        t.options[e + "s"] = Object.create(null);
    }), t.options._base = t, A(t.options.components, xn), (function(t) {
        t.use = function(t) {
            const e = this._installedPlugins || (this._installedPlugins = []);
            if (e.indexOf(t) > -1) return this;
            const n = k(arguments, 1);
            return n.unshift(this), "function" == typeof t.install ? t.install.apply(t, n) : "function" == typeof t && t.apply(null, n), e.push(t), this;
        };
    })(t), (function(t) {
        t.mixin = function(t) {
            return this.options = jt(this.options, t), this;
        };
    })(t), vn(t), (function(t) {
        I.forEach((e)=>{
            t[e] = function(t, n) {
                return n ? ("component" === e && a(n) && (n.name = n.name || t, n = this.options._base.extend(n)), "directive" === e && "function" == typeof n && (n = {
                    bind: n,
                    update: n
                }), this.options[e + "s"][t] = n, n) : this.options[e + "s"][t];
            };
        });
    })(t);
}(gn), Object.defineProperty(gn.prototype, "$isServer", {
    get: et
}), Object.defineProperty(gn.prototype, "$ssrContext", {
    get () {
        return this.$vnode && this.$vnode.ssrContext;
    }
}), Object.defineProperty(gn, "FunctionalRenderContext", {
    value: Ae
}), gn.version = "2.6.14";
const kn = d("style,class"), An = d("input,textarea,option,select,progress"), On = (t, e, n)=>"value" === n && An(t) && "button" !== e || "selected" === n && "option" === t || "checked" === n && "input" === t || "muted" === n && "video" === t
, Sn = d("contenteditable,draggable,spellcheck"), Tn = d("events,caret,typing,plaintext-only"), Nn = (t, e)=>In(e) || "false" === e ? "false" : "contenteditable" === t && Tn(e) ? e : "true"
, En = d("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"), jn = "http://www.w3.org/1999/xlink", Dn = (t)=>":" === t.charAt(5) && "xlink" === t.slice(0, 5)
, Ln = (t)=>Dn(t) ? t.slice(6, t.length) : ""
, In = (t)=>null == t || !1 === t
;
function Mn(t) {
    let e = t.data, o = t, r = t;
    for(; n2(r.componentInstance);)(r = r.componentInstance._vnode) && r.data && (e = Fn(r.data, e));
    for(; n2(o = o.parent);)o && o.data && (e = Fn(e, o.data));
    return (function(t, e) {
        if (n2(t) || n2(e)) return Pn(t, Rn(e));
        return "";
    })(e.staticClass, e.class);
}
function Fn(t, e) {
    return {
        staticClass: Pn(t.staticClass, e.staticClass),
        class: n2(t.class) ? [
            t.class,
            e.class
        ] : e.class
    };
}
function Pn(t, e) {
    return t ? e ? t + " " + e : t : e || "";
}
function Rn(t) {
    return Array.isArray(t) ? (function(t) {
        let e, o = "";
        for(let r = 0, s = t.length; r < s; r++)n2(e = Rn(t[r])) && "" !== e && (o && (o += " "), o += e);
        return o;
    })(t) : s(t) ? (function(t) {
        let e = "";
        for(const n in t)t[n] && (e && (e += " "), e += n);
        return e;
    })(t) : "string" == typeof t ? t : "";
}
const Hn = {
    svg: "http://www.w3.org/2000/svg",
    math: "http://www.w3.org/1998/Math/MathML"
}, Bn = d("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"), Un = d("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", !0), Vn = (t)=>Bn(t) || Un(t)
;
function zn(t) {
    return Un(t) ? "svg" : "math" === t ? "math" : void 0;
}
const Kn = Object.create(null);
const Jn = d("text,number,password,search,email,tel,url");
function qn(t) {
    if ("string" == typeof t) {
        const e = document.querySelector(t);
        return e || document.createElement("div");
    }
    return t;
}
var Wn = Object.freeze({
    createElement: function(t, e) {
        const n = document.createElement(t);
        return "select" !== t ? n : (e.data && e.data.attrs && void 0 !== e.data.attrs.multiple && n.setAttribute("multiple", "multiple"), n);
    },
    createElementNS: function(t, e) {
        return document.createElementNS(Hn[t], e);
    },
    createTextNode: function(t) {
        return document.createTextNode(t);
    },
    createComment: function(t) {
        return document.createComment(t);
    },
    insertBefore: function(t, e, n) {
        t.insertBefore(e, n);
    },
    removeChild: function(t, e) {
        t.removeChild(e);
    },
    appendChild: function(t, e) {
        t.appendChild(e);
    },
    parentNode: function(t) {
        return t.parentNode;
    },
    nextSibling: function(t) {
        return t.nextSibling;
    },
    tagName: function(t) {
        return t.tagName;
    },
    setTextContent: function(t, e) {
        t.textContent = e;
    },
    setStyleScope: function(t, e) {
        t.setAttribute(e, "");
    }
}), Zn = {
    create (t, e) {
        Gn(e);
    },
    update (t, e) {
        t.data.ref !== e.data.ref && (Gn(t, !0), Gn(e));
    },
    destroy (t) {
        Gn(t, !0);
    }
};
function Gn(t, e) {
    const o = t.data.ref;
    if (!n2(o)) return;
    const r = t.context, s = t.componentInstance || t.elm, i = r.$refs;
    e ? Array.isArray(i[o]) ? m(i[o], s) : i[o] === s && (i[o] = void 0) : t.data.refInFor ? Array.isArray(i[o]) ? i[o].indexOf(s) < 0 && i[o].push(s) : i[o] = [
        s
    ] : i[o] = s;
}
const Xn = new dt("", {
}, []), Yn = [
    "create",
    "activate",
    "update",
    "remove",
    "destroy"
];
function Qn(t, r) {
    return t.key === r.key && t.asyncFactory === r.asyncFactory && (t.tag === r.tag && t.isComment === r.isComment && n2(t.data) === n2(r.data) && (function(t, e) {
        if ("input" !== t.tag) return !0;
        let o;
        const r = n2(o = t.data) && n2(o = o.attrs) && o.type, s = n2(o = e.data) && n2(o = o.attrs) && o.type;
        return r === s || Jn(r) && Jn(s);
    })(t, r) || o3(t.isAsyncPlaceholder) && e4(r.asyncFactory.error));
}
function to(t, e, o) {
    let r, s;
    const i = {
    };
    for(r = e; r <= o; ++r)n2(s = t[r].key) && (i[s] = r);
    return i;
}
var eo = {
    create: no,
    update: no,
    destroy: function(t) {
        no(t, Xn);
    }
};
function no(t, e) {
    (t.data.directives || e.data.directives) && (function(t, e) {
        const n = t === Xn, o = e === Xn, r = ro(t.data.directives, t.context), s = ro(e.data.directives, e.context), i = [], a = [];
        let c, l, u;
        for(c in s)l = r[c], u = s[c], l ? (u.oldValue = l.value, u.oldArg = l.arg, io(u, "update", e, t), u.def && u.def.componentUpdated && a.push(u)) : (io(u, "bind", e, t), u.def && u.def.inserted && i.push(u));
        if (i.length) {
            const o = ()=>{
                for(let n = 0; n < i.length; n++)io(i[n], "inserted", e, t);
            };
            n ? te(e, "insert", o) : o();
        }
        a.length && te(e, "postpatch", ()=>{
            for(let n = 0; n < a.length; n++)io(a[n], "componentUpdated", e, t);
        });
        if (!n) for(c in r)s[c] || io(r[c], "unbind", t, t, o);
    })(t, e);
}
const oo = Object.create(null);
function ro(t, e) {
    const n = Object.create(null);
    if (!t) return n;
    let o, r;
    for(o = 0; o < t.length; o++)(r = t[o]).modifiers || (r.modifiers = oo), n[so(r)] = r, r.def = Dt(e.$options, "directives", r.name);
    return n;
}
function so(t) {
    return t.rawName || `${t.name}.${Object.keys(t.modifiers || {
    }).join(".")}`;
}
function io(t, e, n, o, r) {
    const s = t.def && t.def[e];
    if (s) try {
        s(n.elm, t, n, o, r);
    } catch (o4) {
        Rt(o4, n.context, `directive ${t.name} ${e} hook`);
    }
}
var ao = [
    Zn,
    eo
];
function co(t, o) {
    const r = o.componentOptions;
    if (n2(r) && !1 === r.Ctor.options.inheritAttrs) return;
    if (e4(t.data.attrs) && e4(o.data.attrs)) return;
    let s, i, a;
    const c = o.elm, l = t.data.attrs || {
    };
    let u = o.data.attrs || {
    };
    for(s in n2(u.__ob__) && (u = o.data.attrs = A({
    }, u)), u)i = u[s], (a = l[s]) !== i && lo(c, s, i, o.data.pre);
    for(s in (q || Z) && u.value !== l.value && lo(c, "value", u.value), l)e4(u[s]) && (Dn(s) ? c.removeAttributeNS(jn, Ln(s)) : Sn(s) || c.removeAttribute(s));
}
function lo(t, e, n, o) {
    o || t.tagName.indexOf("-") > -1 ? uo(t, e, n) : En(e) ? In(n) ? t.removeAttribute(e) : (n = "allowfullscreen" === e && "EMBED" === t.tagName ? "true" : e, t.setAttribute(e, n)) : Sn(e) ? t.setAttribute(e, Nn(e, n)) : Dn(e) ? In(n) ? t.removeAttributeNS(jn, Ln(e)) : t.setAttributeNS(jn, e, n) : uo(t, e, n);
}
function uo(t, e, n) {
    if (In(n)) t.removeAttribute(e);
    else {
        if (q && !W && "TEXTAREA" === t.tagName && "placeholder" === e && "" !== n && !t.__ieph) {
            const e = (n)=>{
                n.stopImmediatePropagation(), t.removeEventListener("input", e);
            };
            t.addEventListener("input", e), t.__ieph = !0;
        }
        t.setAttribute(e, n);
    }
}
var fo = {
    create: co,
    update: co
};
function po(t, o) {
    const r = o.elm, s = o.data, i = t.data;
    if (e4(s.staticClass) && e4(s.class) && (e4(i) || e4(i.staticClass) && e4(i.class))) return;
    let a = Mn(o);
    const c = r._transitionClasses;
    n2(c) && (a = Pn(a, Rn(c))), a !== r._prevClass && (r.setAttribute("class", a), r._prevClass = a);
}
var ho = {
    create: po,
    update: po
};
const mo = /[\w).+\-_$\]]/;
function yo(t) {
    let e, n, o, r, s, i = !1, a = !1, c = !1, l = !1, u = 0, f = 0, d = 0, p = 0;
    for(o = 0; o < t.length; o++)if (n = e, e = t.charCodeAt(o), i) 39 === e && 92 !== n && (i = !1);
    else if (a) 34 === e && 92 !== n && (a = !1);
    else if (c) 96 === e && 92 !== n && (c = !1);
    else if (l) 47 === e && 92 !== n && (l = !1);
    else if (124 !== e || 124 === t.charCodeAt(o + 1) || 124 === t.charCodeAt(o - 1) || u || f || d) {
        switch(e){
            case 34:
                a = !0;
                break;
            case 39:
                i = !0;
                break;
            case 96:
                c = !0;
                break;
            case 40:
                d++;
                break;
            case 41:
                d--;
                break;
            case 91:
                f++;
                break;
            case 93:
                f--;
                break;
            case 123:
                u++;
                break;
            case 125:
                u--;
        }
        if (47 === e) {
            let e, n = o - 1;
            for(; n >= 0 && " " === (e = t.charAt(n)); n--);
            e && mo.test(e) || (l = !0);
        }
    } else void 0 === r ? (p = o + 1, r = t.slice(0, o).trim()) : h();
    function h() {
        (s || (s = [])).push(t.slice(p, o).trim()), p = o + 1;
    }
    if (void 0 === r ? r = t.slice(0, o).trim() : 0 !== p && h(), s) for(o = 0; o < s.length; o++)r = go(r, s[o]);
    return r;
}
function go(t, e) {
    const n = e.indexOf("(");
    if (n < 0) return `_f("${e}")(${t})`;
    {
        const o = e.slice(0, n), r = e.slice(n + 1);
        return `_f("${o}")(${t}${")" !== r ? "," + r : r}`;
    }
}
function vo(t, e) {
    console.error(`[Vue compiler]: ${t}`);
}
function $o(t, e) {
    return t ? t.map((t)=>t[e]
    ).filter((t)=>t
    ) : [];
}
function _o(t, e, n, o, r) {
    (t.props || (t.props = [])).push(To({
        name: e,
        value: n,
        dynamic: r
    }, o)), t.plain = !1;
}
function bo(t, e, n, o, r) {
    (r ? t.dynamicAttrs || (t.dynamicAttrs = []) : t.attrs || (t.attrs = [])).push(To({
        name: e,
        value: n,
        dynamic: r
    }, o)), t.plain = !1;
}
function wo(t, e, n, o) {
    t.attrsMap[e] = n, t.attrsList.push(To({
        name: e,
        value: n
    }, o));
}
function Co(t, e, n, o, r, s, i, a) {
    (t.directives || (t.directives = [])).push(To({
        name: e,
        rawName: n,
        value: o,
        arg: r,
        isDynamicArg: s,
        modifiers: i
    }, a)), t.plain = !1;
}
function xo(t, e, n) {
    return n ? `_p(${e},"${t}")` : t + e;
}
function ko(e, n, o, r, s, i, a, c) {
    let l;
    (r = r || t7).right ? c ? n = `(${n})==='click'?'contextmenu':(${n})` : "click" === n && (n = "contextmenu", delete r.right) : r.middle && (c ? n = `(${n})==='click'?'mouseup':(${n})` : "click" === n && (n = "mouseup")), r.capture && (delete r.capture, n = xo("!", n, c)), r.once && (delete r.once, n = xo("~", n, c)), r.passive && (delete r.passive, n = xo("&", n, c)), r.native ? (delete r.native, l = e.nativeEvents || (e.nativeEvents = {
    })) : l = e.events || (e.events = {
    });
    const u = To({
        value: o.trim(),
        dynamic: c
    }, a);
    r !== t7 && (u.modifiers = r);
    const f = l[n];
    Array.isArray(f) ? s ? f.unshift(u) : f.push(u) : l[n] = f ? s ? [
        u,
        f
    ] : [
        f,
        u
    ] : u, e.plain = !1;
}
function Ao(t, e, n) {
    const o = Oo(t, ":" + e) || Oo(t, "v-bind:" + e);
    if (null != o) return yo(o);
    if (!1 !== n) {
        const n = Oo(t, e);
        if (null != n) return JSON.stringify(n);
    }
}
function Oo(t, e, n) {
    let o;
    if (null != (o = t.attrsMap[e])) {
        const n = t.attrsList;
        for(let t6 = 0, o = n.length; t6 < o; t6++)if (n[t6].name === e) {
            n.splice(t6, 1);
            break;
        }
    }
    return n && delete t.attrsMap[e], o;
}
function So(t, e) {
    const n = t.attrsList;
    for(let t6 = 0, o = n.length; t6 < o; t6++){
        const o = n[t6];
        if (e.test(o.name)) return n.splice(t6, 1), o;
    }
}
function To(t, e) {
    return e && (null != e.start && (t.start = e.start), null != e.end && (t.end = e.end)), t;
}
function No(t, e, n) {
    const { number: o , trim: r  } = n || {
    };
    let s = "$$v";
    r && (s = "(typeof $$v === 'string'? $$v.trim(): $$v)"), o && (s = `_n(${s})`);
    const i = Eo(e, s);
    t.model = {
        value: `(${e})`,
        expression: JSON.stringify(e),
        callback: `function ($$v) {${i}}`
    };
}
function Eo(t, e) {
    const n = function(t) {
        if (t = t.trim(), jo = t.length, t.indexOf("[") < 0 || t.lastIndexOf("]") < jo - 1) return (Io = t.lastIndexOf(".")) > -1 ? {
            exp: t.slice(0, Io),
            key: '"' + t.slice(Io + 1) + '"'
        } : {
            exp: t,
            key: null
        };
        Do = t, Io = Mo = Fo = 0;
        for(; !Ro();)Ho(Lo = Po()) ? Uo(Lo) : 91 === Lo && Bo(Lo);
        return {
            exp: t.slice(0, Mo),
            key: t.slice(Mo + 1, Fo)
        };
    }(t);
    return null === n.key ? `${t}=${e}` : `$set(${n.exp}, ${n.key}, ${e})`;
}
let jo, Do, Lo, Io, Mo, Fo;
function Po() {
    return Do.charCodeAt(++Io);
}
function Ro() {
    return Io >= jo;
}
function Ho(t) {
    return 34 === t || 39 === t;
}
function Bo(t) {
    let e = 1;
    for(Mo = Io; !Ro();)if (Ho(t = Po())) Uo(t);
    else if (91 === t && e++, 93 === t && e--, 0 === e) {
        Fo = Io;
        break;
    }
}
function Uo(t) {
    const e = t;
    for(; !Ro() && (t = Po()) !== e;);
}
const Vo = "__r", zo = "__c";
let Ko;
function Jo(t, e, n) {
    const o = Ko;
    return function r() {
        null !== e.apply(null, arguments) && Zo(t, r, n, o);
    };
}
const qo = Vt && !(X && Number(X[1]) <= 53);
function Wo(t, e, n, o) {
    if (qo) {
        const t = en, n = e;
        e = n._wrapper = function(e) {
            if (e.target === e.currentTarget || e.timeStamp >= t || e.timeStamp <= 0 || e.target.ownerDocument !== document) return n.apply(this, arguments);
        };
    }
    Ko.addEventListener(t, e, tt ? {
        capture: n,
        passive: o
    } : n);
}
function Zo(t, e, n, o) {
    (o || Ko).removeEventListener(t, e._wrapper || e, n);
}
function Go(t, o) {
    if (e4(t.data.on) && e4(o.data.on)) return;
    const r = o.data.on || {
    }, s = t.data.on || {
    };
    Ko = o.elm, (function(t) {
        if (n2(t[Vo])) {
            const e = q ? "change" : "input";
            t[e] = [].concat(t[Vo], t[e] || []), delete t[Vo];
        }
        n2(t[zo]) && (t.change = [].concat(t[zo], t.change || []), delete t[zo]);
    })(r), Qt(r, s, Wo, Zo, Jo, o.context), Ko = void 0;
}
var Xo = {
    create: Go,
    update: Go
};
let Yo;
function Qo(t, o) {
    if (e4(t.data.domProps) && e4(o.data.domProps)) return;
    let r, s;
    const i = o.elm, a = t.data.domProps || {
    };
    let c = o.data.domProps || {
    };
    for(r in n2(c.__ob__) && (c = o.data.domProps = A({
    }, c)), a)r in c || (i[r] = "");
    for(r in c){
        if (s = c[r], "textContent" === r || "innerHTML" === r) {
            if (o.children && (o.children.length = 0), s === a[r]) continue;
            1 === i.childNodes.length && i.removeChild(i.childNodes[0]);
        }
        if ("value" === r && "PROGRESS" !== i.tagName) {
            i._value = s;
            const t = e4(s) ? "" : String(s);
            tr(i, t) && (i.value = t);
        } else if ("innerHTML" === r && Un(i.tagName) && e4(i.innerHTML)) {
            (Yo = Yo || document.createElement("div")).innerHTML = `<svg>${s}</svg>`;
            const t = Yo.firstChild;
            for(; i.firstChild;)i.removeChild(i.firstChild);
            for(; t.firstChild;)i.appendChild(t.firstChild);
        } else if (s !== a[r]) try {
            i[r] = s;
        } catch (t) {
        }
    }
}
function tr(t8, e) {
    return !t8.composing && ("OPTION" === t8.tagName || (function(t, e) {
        let n = !0;
        try {
            n = document.activeElement !== t;
        } catch (t6) {
        }
        return n && t.value !== e;
    })(t8, e) || (function(t, e) {
        const o = t.value, r = t._vModifiers;
        if (n2(r)) {
            if (r.number) return f(o) !== f(e);
            if (r.trim) return o.trim() !== e.trim();
        }
        return o !== e;
    })(t8, e));
}
var er = {
    create: Qo,
    update: Qo
};
const nr = v(function(t) {
    const e = {
    }, n = /:(.+)/;
    return t.split(/;(?![^(]*\))/g).forEach(function(t) {
        if (t) {
            const o = t.split(n);
            o.length > 1 && (e[o[0].trim()] = o[1].trim());
        }
    }), e;
});
function or(t) {
    const e = rr(t.style);
    return t.staticStyle ? A(t.staticStyle, e) : e;
}
function rr(t) {
    return Array.isArray(t) ? O(t) : "string" == typeof t ? nr(t) : t;
}
const sr = /^--/, ir = /\s*!important$/, ar = (t, e, n)=>{
    if (sr.test(e)) t.style.setProperty(e, n);
    else if (ir.test(n)) t.style.setProperty(C(e), n.replace(ir, ""), "important");
    else {
        const o = ur(e);
        if (Array.isArray(n)) for(let e5 = 0, r = n.length; e5 < r; e5++)t.style[o] = n[e5];
        else t.style[o] = n;
    }
}, cr = [
    "Webkit",
    "Moz",
    "ms"
];
let lr;
const ur = v(function(t) {
    if (lr = lr || document.createElement("div").style, "filter" !== (t = _(t)) && t in lr) return t;
    const e = t.charAt(0).toUpperCase() + t.slice(1);
    for(let t6 = 0; t6 < cr.length; t6++){
        const n = cr[t6] + e;
        if (n in lr) return n;
    }
});
function fr(t, o) {
    const r = o.data, s = t.data;
    if (e4(r.staticStyle) && e4(r.style) && e4(s.staticStyle) && e4(s.style)) return;
    let i, a;
    const c = o.elm, l = s.staticStyle, u = s.normalizedStyle || s.style || {
    }, f = l || u, d = rr(o.data.style) || {
    };
    o.data.normalizedStyle = n2(d.__ob__) ? A({
    }, d) : d;
    const p = function(t, e) {
        const n = {
        };
        let o;
        if (e) {
            let e = t;
            for(; e.componentInstance;)(e = e.componentInstance._vnode) && e.data && (o = or(e.data)) && A(n, o);
        }
        (o = or(t.data)) && A(n, o);
        let r = t;
        for(; r = r.parent;)r.data && (o = or(r.data)) && A(n, o);
        return n;
    }(o, !0);
    for(a in f)e4(p[a]) && ar(c, a, "");
    for(a in p)(i = p[a]) !== f[a] && ar(c, a, null == i ? "" : i);
}
var dr = {
    create: fr,
    update: fr
};
const pr = /\s+/;
function hr(t, e) {
    if (e && (e = e.trim())) if (t.classList) e.indexOf(" ") > -1 ? e.split(pr).forEach((e)=>t.classList.add(e)
    ) : t.classList.add(e);
    else {
        const n = ` ${t.getAttribute("class") || ""} `;
        n.indexOf(" " + e + " ") < 0 && t.setAttribute("class", (n + e).trim());
    }
}
function mr(t, e) {
    if (e && (e = e.trim())) if (t.classList) e.indexOf(" ") > -1 ? e.split(pr).forEach((e)=>t.classList.remove(e)
    ) : t.classList.remove(e), t.classList.length || t.removeAttribute("class");
    else {
        let n = ` ${t.getAttribute("class") || ""} `;
        const o = " " + e + " ";
        for(; n.indexOf(o) >= 0;)n = n.replace(o, " ");
        (n = n.trim()) ? t.setAttribute("class", n) : t.removeAttribute("class");
    }
}
function yr(t) {
    if (t) {
        if ("object" == typeof t) {
            const e = {
            };
            return !1 !== t.css && A(e, gr(t.name || "v")), A(e, t), e;
        }
        return "string" == typeof t ? gr(t) : void 0;
    }
}
const gr = v((t)=>({
        enterClass: `${t}-enter`,
        enterToClass: `${t}-enter-to`,
        enterActiveClass: `${t}-enter-active`,
        leaveClass: `${t}-leave`,
        leaveToClass: `${t}-leave-to`,
        leaveActiveClass: `${t}-leave-active`
    })
), vr = V && !W, $r = "transition", _r = "animation";
let br = "transition", wr = "transitionend", Cr = "animation", xr = "animationend";
vr && (void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (br = "WebkitTransition", wr = "webkitTransitionEnd"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (Cr = "WebkitAnimation", xr = "webkitAnimationEnd"));
const kr = V ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : (t)=>t()
;
function Ar(t) {
    kr(()=>{
        kr(t);
    });
}
function Or(t, e) {
    const n = t._transitionClasses || (t._transitionClasses = []);
    n.indexOf(e) < 0 && (n.push(e), hr(t, e));
}
function Sr(t, e) {
    t._transitionClasses && m(t._transitionClasses, e), mr(t, e);
}
function Tr(t, e, n) {
    const { type: o , timeout: r , propCount: s  } = Er(t, e);
    if (!o) return n();
    const i = o === $r ? wr : xr;
    let a = 0;
    const c = ()=>{
        t.removeEventListener(i, l), n();
    }, l = (e)=>{
        e.target === t && ++a >= s && c();
    };
    setTimeout(()=>{
        a < s && c();
    }, r + 1), t.addEventListener(i, l);
}
const Nr = /\b(transform|all)(,|$)/;
function Er(t, e) {
    const n = window.getComputedStyle(t), o = (n[br + "Delay"] || "").split(", "), r = (n[br + "Duration"] || "").split(", "), s = jr(o, r), i = (n[Cr + "Delay"] || "").split(", "), a = (n[Cr + "Duration"] || "").split(", "), c = jr(i, a);
    let l, u = 0, f = 0;
    return e === $r ? s > 0 && (l = $r, u = s, f = r.length) : e === _r ? c > 0 && (l = _r, u = c, f = a.length) : f = (l = (u = Math.max(s, c)) > 0 ? s > c ? $r : _r : null) ? l === $r ? r.length : a.length : 0, {
        type: l,
        timeout: u,
        propCount: f,
        hasTransform: l === $r && Nr.test(n[br + "Property"])
    };
}
function jr(t, e) {
    for(; t.length < e.length;)t = t.concat(t);
    return Math.max.apply(null, e.map((e, n)=>Dr(e) + Dr(t[n])
    ));
}
function Dr(t) {
    return 1000 * Number(t.slice(0, -1).replace(",", "."));
}
function Lr(t, o) {
    const r = t.elm;
    n2(r._leaveCb) && (r._leaveCb.cancelled = !0, r._leaveCb());
    const i = yr(t.data.transition);
    if (e4(i)) return;
    if (n2(r._enterCb) || 1 !== r.nodeType) return;
    const { css: a , type: c , enterClass: l , enterToClass: u , enterActiveClass: d , appearClass: p , appearToClass: h , appearActiveClass: m , beforeEnter: y , enter: g , afterEnter: v , enterCancelled: $ , beforeAppear: _ , appear: b , afterAppear: w , appearCancelled: C , duration: x  } = i;
    let k = ze, A = ze.$vnode;
    for(; A && A.parent;)k = A.context, A = A.parent;
    const O = !k._isMounted || !t.isRootInsert;
    if (O && !b && "" !== b) return;
    const S = O && p ? p : l, T = O && m ? m : d, N = O && h ? h : u, E = O && _ || y, j = O && "function" == typeof b ? b : g, L = O && w || v, I = O && C || $, M = f(s(x) ? x.enter : x), F = !1 !== a && !W, P = Fr(j), R = r._enterCb = D(()=>{
        F && (Sr(r, N), Sr(r, T)), R.cancelled ? (F && Sr(r, S), I && I(r)) : L && L(r), r._enterCb = null;
    });
    t.data.show || te(t, "insert", ()=>{
        const e = r.parentNode, n = e && e._pending && e._pending[t.key];
        n && n.tag === t.tag && n.elm._leaveCb && n.elm._leaveCb(), j && j(r, R);
    }), E && E(r), F && (Or(r, S), Or(r, T), Ar(()=>{
        Sr(r, S), R.cancelled || (Or(r, N), P || (Mr(M) ? setTimeout(R, M) : Tr(r, c, R)));
    })), t.data.show && (o && o(), j && j(r, R)), F || P || R();
}
function Ir(t, o) {
    const r = t.elm;
    n2(r._enterCb) && (r._enterCb.cancelled = !0, r._enterCb());
    const i = yr(t.data.transition);
    if (e4(i) || 1 !== r.nodeType) return o();
    if (n2(r._leaveCb)) return;
    const { css: a , type: c , leaveClass: l , leaveToClass: u , leaveActiveClass: d , beforeLeave: p , leave: h , afterLeave: m , leaveCancelled: y , delayLeave: g , duration: v  } = i, $ = !1 !== a && !W, _ = Fr(h), b = f(s(v) ? v.leave : v), w = r._leaveCb = D(()=>{
        r.parentNode && r.parentNode._pending && (r.parentNode._pending[t.key] = null), $ && (Sr(r, u), Sr(r, d)), w.cancelled ? ($ && Sr(r, l), y && y(r)) : (o(), m && m(r)), r._leaveCb = null;
    });
    function C() {
        w.cancelled || (!t.data.show && r.parentNode && ((r.parentNode._pending || (r.parentNode._pending = {
        }))[t.key] = t), p && p(r), $ && (Or(r, l), Or(r, d), Ar(()=>{
            Sr(r, l), w.cancelled || (Or(r, u), _ || (Mr(b) ? setTimeout(w, b) : Tr(r, c, w)));
        })), h && h(r, w), $ || _ || w());
    }
    g ? g(C) : C();
}
function Mr(t) {
    return "number" == typeof t && !isNaN(t);
}
function Fr(t) {
    if (e4(t)) return !1;
    const o = t.fns;
    return n2(o) ? Fr(Array.isArray(o) ? o[0] : o) : (t._length || t.length) > 1;
}
function Pr(t, e) {
    !0 !== e.data.show && Lr(e);
}
const Rr = function(t) {
    let s, i;
    const a = {
    }, { modules: c , nodeOps: l  } = t;
    for(s = 0; s < Yn.length; ++s)for(a[Yn[s]] = [], i = 0; i < c.length; ++i)n2(c[i][Yn[s]]) && a[Yn[s]].push(c[i][Yn[s]]);
    function u(t) {
        const e = l.parentNode(t);
        n2(e) && l.removeChild(e, t);
    }
    function f(t, e, r, s, i, c, u) {
        if (n2(t.elm) && n2(c) && (t = c[u] = mt(t)), t.isRootInsert = !i, (function(t, e, r, s) {
            let i = t.data;
            if (n2(i)) {
                const c = n2(t.componentInstance) && i.keepAlive;
                if (n2(i = i.hook) && n2(i = i.init) && i(t, !1), n2(t.componentInstance)) return p(t, e), h(r, t.elm, s), o3(c) && (function(t, e, o, r) {
                    let s, i = t;
                    for(; i.componentInstance;)if (i = i.componentInstance._vnode, n2(s = i.data) && n2(s = s.transition)) {
                        for(s = 0; s < a.activate.length; ++s)a.activate[s](Xn, i);
                        e.push(i);
                        break;
                    }
                    h(o, t.elm, r);
                })(t, e, r, s), !0;
            }
        })(t, e, r, s)) return;
        const f = t.data, d = t.children, y = t.tag;
        n2(y) ? (t.elm = t.ns ? l.createElementNS(t.ns, y) : l.createElement(y, t), v(t), m(t, d, e), n2(f) && g(t, e), h(r, t.elm, s)) : o3(t.isComment) ? (t.elm = l.createComment(t.text), h(r, t.elm, s)) : (t.elm = l.createTextNode(t.text), h(r, t.elm, s));
    }
    function p(t, e) {
        n2(t.data.pendingInsert) && (e.push.apply(e, t.data.pendingInsert), t.data.pendingInsert = null), t.elm = t.componentInstance.$el, y(t) ? (g(t, e), v(t)) : (Gn(t), e.push(t));
    }
    function h(t, e, o) {
        n2(t) && (n2(o) ? l.parentNode(o) === t && l.insertBefore(t, e, o) : l.appendChild(t, e));
    }
    function m(t, e, n) {
        if (Array.isArray(e)) for(let o = 0; o < e.length; ++o)f(e[o], n, t.elm, null, !0, e, o);
        else r3(t.text) && l.appendChild(t.elm, l.createTextNode(String(t.text)));
    }
    function y(t) {
        for(; t.componentInstance;)t = t.componentInstance._vnode;
        return n2(t.tag);
    }
    function g(t, e) {
        for(let e5 = 0; e5 < a.create.length; ++e5)a.create[e5](Xn, t);
        n2(s = t.data.hook) && (n2(s.create) && s.create(Xn, t), n2(s.insert) && e.push(t));
    }
    function v(t) {
        let e;
        if (n2(e = t.fnScopeId)) l.setStyleScope(t.elm, e);
        else {
            let o = t;
            for(; o;)n2(e = o.context) && n2(e = e.$options._scopeId) && l.setStyleScope(t.elm, e), o = o.parent;
        }
        n2(e = ze) && e !== t.context && e !== t.fnContext && n2(e = e.$options._scopeId) && l.setStyleScope(t.elm, e);
    }
    function $(t, e, n, o, r, s) {
        for(; o <= r; ++o)f(n[o], s, t, e, !1, n, o);
    }
    function _(t) {
        let e, o;
        const r = t.data;
        if (n2(r)) for(n2(e = r.hook) && n2(e = e.destroy) && e(t), e = 0; e < a.destroy.length; ++e)a.destroy[e](t);
        if (n2(e = t.children)) for(o = 0; o < t.children.length; ++o)_(t.children[o]);
    }
    function b(t, e, o) {
        for(; e <= o; ++e){
            const o = t[e];
            n2(o) && (n2(o.tag) ? (w(o), _(o)) : u(o.elm));
        }
    }
    function w(t, e) {
        if (n2(e) || n2(t.data)) {
            let o;
            const r = a.remove.length + 1;
            for(n2(e) ? e.listeners += r : e = (function(t, e) {
                function n() {
                    0 == --n.listeners && u(t);
                }
                return n.listeners = e, n;
            })(t.elm, r), n2(o = t.componentInstance) && n2(o = o._vnode) && n2(o.data) && w(o, e), o = 0; o < a.remove.length; ++o)a.remove[o](t, e);
            n2(o = t.data.hook) && n2(o = o.remove) ? o(t, e) : e();
        } else u(t.elm);
    }
    function C(t, e, o, r) {
        for(let s = o; s < r; s++){
            const o = e[s];
            if (n2(o) && Qn(t, o)) return s;
        }
    }
    function x(t, r, s, i, c, u) {
        if (t === r) return;
        n2(r.elm) && n2(i) && (r = i[c] = mt(r));
        const d = r.elm = t.elm;
        if (o3(t.isAsyncPlaceholder)) return void (n2(r.asyncFactory.resolved) ? O(t.elm, r, s) : r.isAsyncPlaceholder = !0);
        if (o3(r.isStatic) && o3(t.isStatic) && r.key === t.key && (o3(r.isCloned) || o3(r.isOnce))) return void (r.componentInstance = t.componentInstance);
        let p;
        const h = r.data;
        n2(h) && n2(p = h.hook) && n2(p = p.prepatch) && p(t, r);
        const m = t.children, g = r.children;
        if (n2(h) && y(r)) {
            for(p = 0; p < a.update.length; ++p)a.update[p](t, r);
            n2(p = h.hook) && n2(p = p.update) && p(t, r);
        }
        e4(r.text) ? n2(m) && n2(g) ? m !== g && (function(t, o, r, s, i) {
            let a, c, u, d, p = 0, h = 0, m = o.length - 1, y = o[0], g = o[m], v = r.length - 1, _ = r[0], w = r[v];
            const k = !i;
            for(; p <= m && h <= v;)e4(y) ? y = o[++p] : e4(g) ? g = o[--m] : Qn(y, _) ? (x(y, _, s, r, h), y = o[++p], _ = r[++h]) : Qn(g, w) ? (x(g, w, s, r, v), g = o[--m], w = r[--v]) : Qn(y, w) ? (x(y, w, s, r, v), k && l.insertBefore(t, y.elm, l.nextSibling(g.elm)), y = o[++p], w = r[--v]) : Qn(g, _) ? (x(g, _, s, r, h), k && l.insertBefore(t, g.elm, y.elm), g = o[--m], _ = r[++h]) : (e4(a) && (a = to(o, p, m)), e4(c = n2(_.key) ? a[_.key] : C(_, o, p, m)) ? f(_, s, t, y.elm, !1, r, h) : Qn(u = o[c], _) ? (x(u, _, s, r, h), o[c] = void 0, k && l.insertBefore(t, u.elm, y.elm)) : f(_, s, t, y.elm, !1, r, h), _ = r[++h]);
            p > m ? $(t, d = e4(r[v + 1]) ? null : r[v + 1].elm, r, h, v, s) : h > v && b(o, p, m);
        })(d, m, g, s, u) : n2(g) ? (n2(t.text) && l.setTextContent(d, ""), $(d, null, g, 0, g.length - 1, s)) : n2(m) ? b(m, 0, m.length - 1) : n2(t.text) && l.setTextContent(d, "") : t.text !== r.text && l.setTextContent(d, r.text), n2(h) && n2(p = h.hook) && n2(p = p.postpatch) && p(t, r);
    }
    function k(t, e, r) {
        if (o3(r) && n2(t.parent)) t.parent.data.pendingInsert = e;
        else for(let t6 = 0; t6 < e.length; ++t6)e[t6].data.hook.insert(e[t6]);
    }
    const A = d("attrs,class,staticClass,staticStyle,key");
    function O(t, e, r, s) {
        let i;
        const { tag: a , data: c , children: l  } = e;
        if (s = s || c && c.pre, e.elm = t, o3(e.isComment) && n2(e.asyncFactory)) return e.isAsyncPlaceholder = !0, !0;
        if (n2(c) && (n2(i = c.hook) && n2(i = i.init) && i(e, !0), n2(i = e.componentInstance))) return p(e, r), !0;
        if (n2(a)) {
            if (n2(l)) if (t.hasChildNodes()) if (n2(i = c) && n2(i = i.domProps) && n2(i = i.innerHTML)) {
                if (i !== t.innerHTML) return !1;
            } else {
                let e = !0, n = t.firstChild;
                for(let t6 = 0; t6 < l.length; t6++){
                    if (!n || !O(n, l[t6], r, s)) {
                        e = !1;
                        break;
                    }
                    n = n.nextSibling;
                }
                if (!e || n) return !1;
            }
            else m(e, l, r);
            if (n2(c)) {
                let t = !1;
                for(const n in c)if (!A(n)) {
                    t = !0, g(e, r);
                    break;
                }
                !t && c.class && Gt(c.class);
            }
        } else t.data !== e.text && (t.data = e.text);
        return !0;
    }
    return function(t, r, s, i) {
        if (e4(r)) return void (n2(t) && _(t));
        let c = !1;
        const u = [];
        if (e4(t)) c = !0, f(r, u);
        else {
            const e6 = n2(t.nodeType);
            if (!e6 && Qn(t, r)) x(t, r, u, null, null, i);
            else {
                if (e6) {
                    if (1 === t.nodeType && t.hasAttribute(L) && (t.removeAttribute(L), s = !0), o3(s) && O(t, r, u)) return k(r, u, !0), t;
                    d = t, t = new dt(l.tagName(d).toLowerCase(), {
                    }, [], void 0, d);
                }
                const i = t.elm, c = l.parentNode(i);
                if (f(r, u, i._leaveCb ? null : c, l.nextSibling(i)), n2(r.parent)) {
                    let t = r.parent;
                    const e = y(r);
                    for(; t;){
                        for(let e5 = 0; e5 < a.destroy.length; ++e5)a.destroy[e5](t);
                        if (t.elm = r.elm, e) {
                            for(let e = 0; e < a.create.length; ++e)a.create[e](Xn, t);
                            const e7 = t.data.hook.insert;
                            if (e7.merged) for(let t6 = 1; t6 < e7.fns.length; t6++)e7.fns[t6]();
                        } else Gn(t);
                        t = t.parent;
                    }
                }
                n2(c) ? b([
                    t
                ], 0, 0) : n2(t.tag) && _(t);
            }
        }
        var d;
        return k(r, u, c), r.elm;
    };
}({
    nodeOps: Wn,
    modules: [
        fo,
        ho,
        Xo,
        er,
        dr,
        V ? {
            create: Pr,
            activate: Pr,
            remove (t, e) {
                !0 !== t.data.show ? Ir(t, e) : e();
            }
        } : {
        }
    ].concat(ao)
});
W && document.addEventListener("selectionchange", ()=>{
    const t = document.activeElement;
    t && t.vmodel && qr(t, "input");
});
const Hr = {
    inserted (t, e, n, o) {
        "select" === n.tag ? (o.elm && !o.elm._vOptions ? te(n, "postpatch", ()=>{
            Hr.componentUpdated(t, e, n);
        }) : Br(t, e, n.context), t._vOptions = [].map.call(t.options, zr)) : ("textarea" === n.tag || Jn(t.type)) && (t._vModifiers = e.modifiers, e.modifiers.lazy || (t.addEventListener("compositionstart", Kr), t.addEventListener("compositionend", Jr), t.addEventListener("change", Jr), W && (t.vmodel = !0)));
    },
    componentUpdated (t, e, n) {
        if ("select" === n.tag) {
            Br(t, e, n.context);
            const o = t._vOptions, r = t._vOptions = [].map.call(t.options, zr);
            if (r.some((t, e)=>!E(t, o[e])
            )) {
                (t.multiple ? e.value.some((t)=>Vr(t, r)
                ) : e.value !== e.oldValue && Vr(e.value, r)) && qr(t, "change");
            }
        }
    }
};
function Br(t, e, n) {
    Ur(t, e, n), (q || Z) && setTimeout(()=>{
        Ur(t, e, n);
    }, 0);
}
function Ur(t, e, n) {
    const o = e.value, r = t.multiple;
    if (r && !Array.isArray(o)) return;
    let s, i;
    for(let e5 = 0, n4 = t.options.length; e5 < n4; e5++)if (i = t.options[e5], r) s = j(o, zr(i)) > -1, i.selected !== s && (i.selected = s);
    else if (E(zr(i), o)) return void (t.selectedIndex !== e5 && (t.selectedIndex = e5));
    r || (t.selectedIndex = -1);
}
function Vr(t, e) {
    return e.every((e)=>!E(e, t)
    );
}
function zr(t) {
    return "_value" in t ? t._value : t.value;
}
function Kr(t) {
    t.target.composing = !0;
}
function Jr(t) {
    t.target.composing && (t.target.composing = !1, qr(t.target, "input"));
}
function qr(t, e) {
    const n = document.createEvent("HTMLEvents");
    n.initEvent(e, !0, !0), t.dispatchEvent(n);
}
function Wr(t) {
    return !t.componentInstance || t.data && t.data.transition ? t : Wr(t.componentInstance._vnode);
}
var Zr = {
    model: Hr,
    show: {
        bind (t, { value: e  }, n) {
            const o = (n = Wr(n)).data && n.data.transition, r = t.__vOriginalDisplay = "none" === t.style.display ? "" : t.style.display;
            e && o ? (n.data.show = !0, Lr(n, ()=>{
                t.style.display = r;
            })) : t.style.display = e ? r : "none";
        },
        update (t, { value: e , oldValue: n  }, o) {
            if (!e == !n) return;
            (o = Wr(o)).data && o.data.transition ? (o.data.show = !0, e ? Lr(o, ()=>{
                t.style.display = t.__vOriginalDisplay;
            }) : Ir(o, ()=>{
                t.style.display = "none";
            })) : t.style.display = e ? t.__vOriginalDisplay : "none";
        },
        unbind (t, e, n, o, r) {
            r || (t.style.display = t.__vOriginalDisplay);
        }
    }
};
const Gr = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [
        Number,
        String,
        Object
    ]
};
function Xr(t) {
    const e = t && t.componentOptions;
    return e && e.Ctor.options.abstract ? Xr(Re(e.children)) : t;
}
function Yr(t) {
    const e = {
    }, n = t.$options;
    for(const o in n.propsData)e[o] = t[o];
    const o4 = n._parentListeners;
    for(const t6 in o4)e[_(t6)] = o4[t6];
    return e;
}
function Qr(t, e) {
    if (/\d-keep-alive$/.test(e.tag)) return t("keep-alive", {
        props: e.componentOptions.propsData
    });
}
const ts = (t)=>t.tag || ae(t)
, es = (t)=>"show" === t.name
;
var ns = {
    name: "transition",
    props: Gr,
    abstract: !0,
    render (t) {
        let e = this.$slots.default;
        if (!e) return;
        if (!(e = e.filter(ts)).length) return;
        const n = this.mode, o = e[0];
        if ((function(t) {
            for(; t = t.parent;)if (t.data.transition) return !0;
        })(this.$vnode)) return o;
        const s = Xr(o);
        if (!s) return o;
        if (this._leaving) return Qr(t, o);
        const i = `__transition-${this._uid}-`;
        s.key = null == s.key ? s.isComment ? i + "comment" : i + s.tag : r3(s.key) ? 0 === String(s.key).indexOf(i) ? s.key : i + s.key : s.key;
        const a = (s.data || (s.data = {
        })).transition = Yr(this), c = this._vnode, l = Xr(c);
        if (s.data.directives && s.data.directives.some(es) && (s.data.show = !0), l && l.data && !function(t, e) {
            return e.key === t.key && e.tag === t.tag;
        }(s, l) && !ae(l) && (!l.componentInstance || !l.componentInstance._vnode.isComment)) {
            const e = l.data.transition = A({
            }, a);
            if ("out-in" === n) return this._leaving = !0, te(e, "afterLeave", ()=>{
                this._leaving = !1, this.$forceUpdate();
            }), Qr(t, o);
            if ("in-out" === n) {
                if (ae(s)) return c;
                let t;
                const n = ()=>{
                    t();
                };
                te(a, "afterEnter", n), te(a, "enterCancelled", n), te(e, "delayLeave", (e)=>{
                    t = e;
                });
            }
        }
        return o;
    }
};
const os = A({
    tag: String,
    moveClass: String
}, Gr);
function rs(t) {
    t.elm._moveCb && t.elm._moveCb(), t.elm._enterCb && t.elm._enterCb();
}
function ss(t) {
    t.data.newPos = t.elm.getBoundingClientRect();
}
function is(t) {
    const e = t.data.pos, n = t.data.newPos, o = e.left - n.left, r = e.top - n.top;
    if (o || r) {
        t.data.moved = !0;
        const e = t.elm.style;
        e.transform = e.WebkitTransform = `translate(${o}px,${r}px)`, e.transitionDuration = "0s";
    }
}
delete os.mode;
var as = {
    Transition: ns,
    TransitionGroup: {
        props: os,
        beforeMount () {
            const t = this._update;
            this._update = (e, n)=>{
                const o = Ke(this);
                this.__patch__(this._vnode, this.kept, !1, !0), this._vnode = this.kept, o(), t.call(this, e, n);
            };
        },
        render (t) {
            const e = this.tag || this.$vnode.data.tag || "span", n = Object.create(null), o = this.prevChildren = this.children, r = this.$slots.default || [], s = this.children = [], i = Yr(this);
            for(let t8 = 0; t8 < r.length; t8++){
                const e = r[t8];
                e.tag && null != e.key && 0 !== String(e.key).indexOf("__vlist") && (s.push(e), n[e.key] = e, (e.data || (e.data = {
                })).transition = i);
            }
            if (o) {
                const r = [], s = [];
                for(let t6 = 0; t6 < o.length; t6++){
                    const e = o[t6];
                    e.data.transition = i, e.data.pos = e.elm.getBoundingClientRect(), n[e.key] ? r.push(e) : s.push(e);
                }
                this.kept = t(e, null, r), this.removed = s;
            }
            return t(e, null, s);
        },
        updated () {
            const t = this.prevChildren, e = this.moveClass || (this.name || "v") + "-move";
            t.length && this.hasMove(t[0].elm, e) && (t.forEach(rs), t.forEach(ss), t.forEach(is), this._reflow = document.body.offsetHeight, t.forEach((t)=>{
                if (t.data.moved) {
                    const n = t.elm, o = n.style;
                    Or(n, e), o.transform = o.WebkitTransform = o.transitionDuration = "", n.addEventListener(wr, n._moveCb = function t(o) {
                        o && o.target !== n || o && !/transform$/.test(o.propertyName) || (n.removeEventListener(wr, t), n._moveCb = null, Sr(n, e));
                    });
                }
            }));
        },
        methods: {
            hasMove (t, e) {
                if (!vr) return !1;
                if (this._hasMove) return this._hasMove;
                const n = t.cloneNode();
                t._transitionClasses && t._transitionClasses.forEach((t)=>{
                    mr(n, t);
                }), hr(n, e), n.style.display = "none", this.$el.appendChild(n);
                const o = Er(n);
                return this.$el.removeChild(n), this._hasMove = o.hasTransform;
            }
        }
    }
};
gn.config.mustUseProp = On, gn.config.isReservedTag = Vn, gn.config.isReservedAttr = kn, gn.config.getTagNamespace = zn, gn.config.isUnknownElement = function(t) {
    if (!V) return !0;
    if (Vn(t)) return !1;
    if (t = t.toLowerCase(), null != Kn[t]) return Kn[t];
    const e = document.createElement(t);
    return t.indexOf("-") > -1 ? Kn[t] = e.constructor === window.HTMLUnknownElement || e.constructor === window.HTMLElement : Kn[t] = /HTMLUnknownElement/.test(e.toString());
}, A(gn.options.directives, Zr), A(gn.options.components, as), gn.prototype.__patch__ = V ? Rr : S1, gn.prototype.$mount = function(t, e) {
    return (function(t, e, n) {
        let o;
        return t.$el = e, t.$options.render || (t.$options.render = pt), We(t, "beforeMount"), o = ()=>{
            t._update(t._render(), n);
        }, new sn(t, o, S1, {
            before () {
                t._isMounted && !t._isDestroyed && We(t, "beforeUpdate");
            }
        }, !0), n = !1, null == t.$vnode && (t._isMounted = !0, We(t, "mounted")), t;
    })(this, t = t && V ? qn(t) : void 0, e);
}, V && setTimeout(()=>{
    F.devtools && nt && nt.emit("init", gn);
}, 0);
const cs = /\{\{((?:.|\r?\n)+?)\}\}/g, ls = /[-.*+?^${}()|[\]\/\\]/g, us = v((t)=>{
    const e = t[0].replace(ls, "\\$&"), n = t[1].replace(ls, "\\$&");
    return new RegExp(e + "((?:.|\\n)+?)" + n, "g");
});
var fs = {
    staticKeys: [
        "staticClass"
    ],
    transformNode: function(t, e) {
        e.warn;
        const n = Oo(t, "class");
        n && (t.staticClass = JSON.stringify(n));
        const o = Ao(t, "class", !1);
        o && (t.classBinding = o);
    },
    genData: function(t) {
        let e = "";
        return t.staticClass && (e += `staticClass:${t.staticClass},`), t.classBinding && (e += `class:${t.classBinding},`), e;
    }
};
var ds = {
    staticKeys: [
        "staticStyle"
    ],
    transformNode: function(t, e) {
        e.warn;
        const n = Oo(t, "style");
        n && (t.staticStyle = JSON.stringify(nr(n)));
        const o = Ao(t, "style", !1);
        o && (t.styleBinding = o);
    },
    genData: function(t) {
        let e = "";
        return t.staticStyle && (e += `staticStyle:${t.staticStyle},`), t.styleBinding && (e += `style:(${t.styleBinding}),`), e;
    }
};
let ps;
var hs = {
    decode: (t)=>((ps = ps || document.createElement("div")).innerHTML = t, ps.textContent)
};
const ms = d("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"), ys = d("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"), gs = d("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"), vs = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/, $s = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/, _s = `[a-zA-Z_][\\-\\.0-9_a-zA-Z${P.source}]*`, bs = `((?:${_s}\\:)?${_s})`, ws = new RegExp(`^<${bs}`), Cs = /^\s*(\/?)>/, xs = new RegExp(`^<\\/${bs}[^>]*>`), ks = /^<!DOCTYPE [^>]+>/i, As = /^<!\--/, Os = /^<!\[/, Ss = d("script,style,textarea", !0), Ts = {
}, Ns = {
    "&lt;": "<",
    "&gt;": ">",
    "&quot;": '"',
    "&amp;": "&",
    "&#10;": "\n",
    "&#9;": "\t",
    "&#39;": "'"
}, Es = /&(?:lt|gt|quot|amp|#39);/g, js = /&(?:lt|gt|quot|amp|#39|#10|#9);/g, Ds = d("pre,textarea", !0), Ls = (t, e)=>t && Ds(t) && "\n" === e[0]
;
function Is(t, e) {
    const n = e ? js : Es;
    return t.replace(n, (t)=>Ns[t]
    );
}
const Ms = /^@|^v-on:/, Fs = /^v-|^@|^:|^#/, Ps = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, Rs = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, Hs = /^\(|\)$/g, Bs = /^\[.*\]$/, Us = /:(.*)$/, Vs = /^:|^\.|^v-bind:/, zs = /\.[^.\]]+(?=[^\]]*$)/g, Ks = /^v-slot(:|$)|^#/, Js = /[\r\n]/, qs = /[ \f\t\r\n]+/g, Ws = v(hs.decode), Zs = "_empty_";
let Gs, Xs, Ys, Qs, ti, ei, ni, oi;
function ri(t, e, n) {
    return {
        type: 1,
        tag: t,
        attrsList: e,
        attrsMap: fi(e),
        rawAttrsMap: {
        },
        parent: n,
        children: []
    };
}
function si(t6, e5) {
    Gs = e5.warn || vo, ei = e5.isPreTag || T1, ni = e5.mustUseProp || T1, oi = e5.getTagNamespace || T1;
    e5.isReservedTag;
    Ys = $o(e5.modules, "transformNode"), Qs = $o(e5.modules, "preTransformNode"), ti = $o(e5.modules, "postTransformNode"), Xs = e5.delimiters;
    const n5 = [], o4 = !1 !== e5.preserveWhitespace, r4 = e5.whitespace;
    let s, i, a = !1, c = !1;
    function l(t) {
        if (u1(t), a || t.processed || (t = ii(t, e5)), n5.length || t === s || s.if && (t.elseif || t.else) && ci(s, {
            exp: t.elseif,
            block: t
        }), i && !t.forbidden) if (t.elseif || t.else) !function(t, e) {
            const n = function(t) {
                let e = t.length;
                for(; e--;){
                    if (1 === t[e].type) return t[e];
                    t.pop();
                }
            }(e.children);
            n && n.if && ci(n, {
                exp: t.elseif,
                block: t
            });
        }(t, i);
        else {
            if (t.slotScope) {
                const e = t.slotTarget || '"default"';
                (i.scopedSlots || (i.scopedSlots = {
                }))[e] = t;
            }
            i.children.push(t), t.parent = i;
        }
        t.children = t.children.filter((t)=>!t.slotScope
        ), u1(t), t.pre && (a = !1), ei(t.tag) && (c = !1);
        for(let n4 = 0; n4 < ti.length; n4++)ti[n4](t, e5);
    }
    function u1(t) {
        if (!c) {
            let e;
            for(; (e = t.children[t.children.length - 1]) && 3 === e.type && " " === e.text;)t.children.pop();
        }
    }
    return (function(t, e) {
        const n = [], o = e.expectHTML, r = e.isUnaryTag || T1, s = e.canBeLeftOpenTag || T1;
        let i, a, c = 0;
        for(; t;){
            if (i = t, a && Ss(a)) {
                let n = 0;
                const o = a.toLowerCase(), r = Ts[o] || (Ts[o] = new RegExp("([\\s\\S]*?)(</" + o + "[^>]*>)", "i")), s = t.replace(r, function(t, r, s) {
                    return n = s.length, Ss(o) || "noscript" === o || (r = r.replace(/<!\--([\s\S]*?)-->/g, "$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g, "$1")), Ls(o, r) && (r = r.slice(1)), e.chars && e.chars(r), "";
                });
                c += t.length - s.length, t = s, d(o, c - n, c);
            } else {
                let n, o, r, s = t.indexOf("<");
                if (0 === s) {
                    if (As.test(t)) {
                        const n = t.indexOf("--\x3e");
                        if (n >= 0) {
                            e.shouldKeepComment && e.comment(t.substring(4, n), c, c + n + 3), l(n + 3);
                            continue;
                        }
                    }
                    if (Os.test(t)) {
                        const e = t.indexOf("]>");
                        if (e >= 0) {
                            l(e + 2);
                            continue;
                        }
                    }
                    const n = t.match(ks);
                    if (n) {
                        l(n[0].length);
                        continue;
                    }
                    const o = t.match(xs);
                    if (o) {
                        const t = c;
                        l(o[0].length), d(o[1], t, c);
                        continue;
                    }
                    const r = u();
                    if (r) {
                        f(r), Ls(r.tagName, t) && l(1);
                        continue;
                    }
                }
                if (s >= 0) {
                    for(o = t.slice(s); !(xs.test(o) || ws.test(o) || As.test(o) || Os.test(o) || (r = o.indexOf("<", 1)) < 0);)s += r, o = t.slice(s);
                    n = t.substring(0, s);
                }
                s < 0 && (n = t), n && l(n.length), e.chars && n && e.chars(n, c - n.length, c);
            }
            if (t === i) {
                e.chars && e.chars(t);
                break;
            }
        }
        function l(e) {
            c += e, t = t.substring(e);
        }
        function u() {
            const e = t.match(ws);
            if (e) {
                const n = {
                    tagName: e[1],
                    attrs: [],
                    start: c
                };
                let o, r;
                for(l(e[0].length); !(o = t.match(Cs)) && (r = t.match($s) || t.match(vs));)r.start = c, l(r[0].length), r.end = c, n.attrs.push(r);
                if (o) return n.unarySlash = o[1], l(o[0].length), n.end = c, n;
            }
        }
        function f(t) {
            const i = t.tagName, c = t.unarySlash;
            o && ("p" === a && gs(i) && d(a), s(i) && a === i && d(i));
            const l = r(i) || !!c, u = t.attrs.length, f = new Array(u);
            for(let n4 = 0; n4 < u; n4++){
                const o = t.attrs[n4], r = o[3] || o[4] || o[5] || "", s = "a" === i && "href" === o[1] ? e.shouldDecodeNewlinesForHref : e.shouldDecodeNewlines;
                f[n4] = {
                    name: o[1],
                    value: Is(r, s)
                };
            }
            l || (n.push({
                tag: i,
                lowerCasedTag: i.toLowerCase(),
                attrs: f,
                start: t.start,
                end: t.end
            }), a = i), e.start && e.start(i, f, l, t.start, t.end);
        }
        function d(t, o, r) {
            let s, i;
            if (null == o && (o = c), null == r && (r = c), t) for(i = t.toLowerCase(), s = n.length - 1; s >= 0 && n[s].lowerCasedTag !== i; s--);
            else s = 0;
            if (s >= 0) {
                for(let t = n.length - 1; t >= s; t--)e.end && e.end(n[t].tag, o, r);
                n.length = s, a = s && n[s - 1].tag;
            } else "br" === i ? e.start && e.start(t, [], !0, o, r) : "p" === i && (e.start && e.start(t, [], !1, o, r), e.end && e.end(t, o, r));
        }
        d();
    })(t6, {
        warn: Gs,
        expectHTML: e5.expectHTML,
        isUnaryTag: e5.isUnaryTag,
        canBeLeftOpenTag: e5.canBeLeftOpenTag,
        shouldDecodeNewlines: e5.shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: e5.shouldDecodeNewlinesForHref,
        shouldKeepComment: e5.comments,
        outputSourceRange: e5.outputSourceRange,
        start (t, o, r, u, f) {
            const d = i && i.ns || oi(t);
            q && "svg" === d && (o = (function(t) {
                const e = [];
                for(let n = 0; n < t.length; n++){
                    const o = t[n];
                    di.test(o.name) || (o.name = o.name.replace(pi, ""), e.push(o));
                }
                return e;
            })(o));
            let p = ri(t, o, i);
            var h;
            d && (p.ns = d), "style" !== (h = p).tag && ("script" !== h.tag || h.attrsMap.type && "text/javascript" !== h.attrsMap.type) || et() || (p.forbidden = !0);
            for(let t8 = 0; t8 < Qs.length; t8++)p = Qs[t8](p, e5) || p;
            a || (!function(t) {
                null != Oo(t, "v-pre") && (t.pre = !0);
            }(p), p.pre && (a = !0)), ei(p.tag) && (c = !0), a ? (function(t) {
                const e = t.attrsList, n = e.length;
                if (n) {
                    const o = t.attrs = new Array(n);
                    for(let t9 = 0; t9 < n; t9++)o[t9] = {
                        name: e[t9].name,
                        value: JSON.stringify(e[t9].value)
                    }, null != e[t9].start && (o[t9].start = e[t9].start, o[t9].end = e[t9].end);
                } else t.pre || (t.plain = !0);
            })(p) : p.processed || (ai(p), (function(t) {
                const e = Oo(t, "v-if");
                if (e) t.if = e, ci(t, {
                    exp: e,
                    block: t
                });
                else {
                    null != Oo(t, "v-else") && (t.else = !0);
                    const e = Oo(t, "v-else-if");
                    e && (t.elseif = e);
                }
            })(p), (function(t) {
                null != Oo(t, "v-once") && (t.once = !0);
            })(p)), s || (s = p), r ? l(p) : (i = p, n5.push(p));
        },
        end (t, e, o) {
            const r = n5[n5.length - 1];
            n5.length -= 1, i = n5[n5.length - 1], l(r);
        },
        chars (t, e, n) {
            if (!i) return;
            if (q && "textarea" === i.tag && i.attrsMap.placeholder === t) return;
            const s = i.children;
            var l;
            if (t = c || t.trim() ? "script" === (l = i).tag || "style" === l.tag ? t : Ws(t) : s.length ? r4 ? "condense" === r4 && Js.test(t) ? "" : " " : o4 ? " " : "" : "") {
                let e, n;
                c || "condense" !== r4 || (t = t.replace(qs, " ")), !a && " " !== t && (e = (function(t, e) {
                    const n = e ? us(e) : cs;
                    if (!n.test(t)) return;
                    const o = [], r = [];
                    let s, i, a, c = n.lastIndex = 0;
                    for(; s = n.exec(t);){
                        (i = s.index) > c && (r.push(a = t.slice(c, i)), o.push(JSON.stringify(a)));
                        const e = yo(s[1].trim());
                        o.push(`_s(${e})`), r.push({
                            "@binding": e
                        }), c = i + s[0].length;
                    }
                    return c < t.length && (r.push(a = t.slice(c)), o.push(JSON.stringify(a))), {
                        expression: o.join("+"),
                        tokens: r
                    };
                })(t, Xs)) ? n = {
                    type: 2,
                    expression: e.expression,
                    tokens: e.tokens,
                    text: t
                } : " " === t && s.length && " " === s[s.length - 1].text || (n = {
                    type: 3,
                    text: t
                }), n && s.push(n);
            }
        },
        comment (t, e, n) {
            if (i) {
                const e = {
                    type: 3,
                    text: t,
                    isComment: !0
                };
                i.children.push(e);
            }
        }
    }), s;
}
function ii(t, e) {
    var n;
    !function(t) {
        const e = Ao(t, "key");
        e && (t.key = e);
    }(t), t.plain = !t.key && !t.scopedSlots && !t.attrsList.length, (function(t) {
        const e = Ao(t, "ref");
        e && (t.ref = e, t.refInFor = (function(t) {
            let e = t;
            for(; e;){
                if (void 0 !== e.for) return !0;
                e = e.parent;
            }
            return !1;
        })(t));
    })(t), (function(t) {
        let e;
        "template" === t.tag ? (e = Oo(t, "scope"), t.slotScope = e || Oo(t, "slot-scope")) : (e = Oo(t, "slot-scope")) && (t.slotScope = e);
        const n = Ao(t, "slot");
        n && (t.slotTarget = '""' === n ? '"default"' : n, t.slotTargetDynamic = !(!t.attrsMap[":slot"] && !t.attrsMap["v-bind:slot"]), "template" === t.tag || t.slotScope || bo(t, "slot", n, function(t, e) {
            return t.rawAttrsMap[":" + e] || t.rawAttrsMap["v-bind:" + e] || t.rawAttrsMap[e];
        }(t, "slot")));
        if ("template" === t.tag) {
            const e = So(t, Ks);
            if (e) {
                const { name: n , dynamic: o  } = li(e);
                t.slotTarget = n, t.slotTargetDynamic = o, t.slotScope = e.value || Zs;
            }
        } else {
            const e = So(t, Ks);
            if (e) {
                const n = t.scopedSlots || (t.scopedSlots = {
                }), { name: o , dynamic: r  } = li(e), s = n[o] = ri("template", [], t);
                s.slotTarget = o, s.slotTargetDynamic = r, s.children = t.children.filter((t)=>{
                    if (!t.slotScope) return t.parent = s, !0;
                }), s.slotScope = e.value || Zs, t.children = [], t.plain = !1;
            }
        }
    })(t), "slot" === (n = t).tag && (n.slotName = Ao(n, "name")), (function(t) {
        let e;
        (e = Ao(t, "is")) && (t.component = e);
        null != Oo(t, "inline-template") && (t.inlineTemplate = !0);
    })(t);
    for(let n4 = 0; n4 < Ys.length; n4++)t = Ys[n4](t, e) || t;
    return (function(t) {
        const e = t.attrsList;
        let n, o, r, s, i, a, c, l;
        for(n = 0, o = e.length; n < o; n++)if (r = s = e[n].name, i = e[n].value, Fs.test(r)) if (t.hasBindings = !0, (a = ui(r.replace(Fs, ""))) && (r = r.replace(zs, "")), Vs.test(r)) r = r.replace(Vs, ""), i = yo(i), (l = Bs.test(r)) && (r = r.slice(1, -1)), a && (a.prop && !l && "innerHtml" === (r = _(r)) && (r = "innerHTML"), a.camel && !l && (r = _(r)), a.sync && (c = Eo(i, "$event"), l ? ko(t, `"update:"+(${r})`, c, null, !1, 0, e[n], !0) : (ko(t, `update:${_(r)}`, c, null, !1, 0, e[n]), C(r) !== _(r) && ko(t, `update:${C(r)}`, c, null, !1, 0, e[n])))), a && a.prop || !t.component && ni(t.tag, t.attrsMap.type, r) ? _o(t, r, i, e[n], l) : bo(t, r, i, e[n], l);
        else if (Ms.test(r)) r = r.replace(Ms, ""), (l = Bs.test(r)) && (r = r.slice(1, -1)), ko(t, r, i, a, !1, 0, e[n], l);
        else {
            const o = (r = r.replace(Fs, "")).match(Us);
            let c = o && o[1];
            l = !1, c && (r = r.slice(0, -(c.length + 1)), Bs.test(c) && (c = c.slice(1, -1), l = !0)), Co(t, r, s, i, c, l, a, e[n]);
        }
        else bo(t, r, JSON.stringify(i), e[n]), !t.component && "muted" === r && ni(t.tag, t.attrsMap.type, r) && _o(t, r, "true", e[n]);
    })(t), t;
}
function ai(t) {
    let e;
    if (e = Oo(t, "v-for")) {
        const n = function(t) {
            const e = t.match(Ps);
            if (!e) return;
            const n = {
            };
            n.for = e[2].trim();
            const o = e[1].trim().replace(Hs, ""), r = o.match(Rs);
            r ? (n.alias = o.replace(Rs, "").trim(), n.iterator1 = r[1].trim(), r[2] && (n.iterator2 = r[2].trim())) : n.alias = o;
            return n;
        }(e);
        n && A(t, n);
    }
}
function ci(t, e) {
    t.ifConditions || (t.ifConditions = []), t.ifConditions.push(e);
}
function li(t) {
    let e = t.name.replace(Ks, "");
    return e || "#" !== t.name[0] && (e = "default"), Bs.test(e) ? {
        name: e.slice(1, -1),
        dynamic: !0
    } : {
        name: `"${e}"`,
        dynamic: !1
    };
}
function ui(t) {
    const e = t.match(zs);
    if (e) {
        const t = {
        };
        return e.forEach((e)=>{
            t[e.slice(1)] = !0;
        }), t;
    }
}
function fi(t) {
    const e = {
    };
    for(let n = 0, o = t.length; n < o; n++)e[t[n].name] = t[n].value;
    return e;
}
const di = /^xmlns:NS\d+/, pi = /^NS\d+:/;
function hi(t) {
    return ri(t.tag, t.attrsList.slice(), t.parent);
}
var mi = [
    fs,
    ds,
    {
        preTransformNode: function(t, e) {
            if ("input" === t.tag) {
                const n = t.attrsMap;
                if (!n["v-model"]) return;
                let o;
                if ((n[":type"] || n["v-bind:type"]) && (o = Ao(t, "type")), n.type || o || !n["v-bind"] || (o = `(${n["v-bind"]}).type`), o) {
                    const n = Oo(t, "v-if", !0), r = n ? `&&(${n})` : "", s = null != Oo(t, "v-else", !0), i = Oo(t, "v-else-if", !0), a = hi(t);
                    ai(a), wo(a, "type", "checkbox"), ii(a, e), a.processed = !0, a.if = `(${o})==='checkbox'` + r, ci(a, {
                        exp: a.if,
                        block: a
                    });
                    const c = hi(t);
                    Oo(c, "v-for", !0), wo(c, "type", "radio"), ii(c, e), ci(a, {
                        exp: `(${o})==='radio'` + r,
                        block: c
                    });
                    const l = hi(t);
                    return Oo(l, "v-for", !0), wo(l, ":type", o), ii(l, e), ci(a, {
                        exp: n,
                        block: l
                    }), s ? a.else = !0 : i && (a.elseif = i), a;
                }
            }
        }
    }
];
const yi = {
    expectHTML: !0,
    modules: mi,
    directives: {
        model: function(t, e, n) {
            const o = e.value, r = e.modifiers, s = t.tag, i = t.attrsMap.type;
            if (t.component) return No(t, o, r), !1;
            if ("select" === s) !function(t, e, n) {
                let o = `var $$selectedVal = ${'Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;' + `return ${n && n.number ? "_n(val)" : "val"}})`};`;
                o = `${o} ${Eo(e, "$event.target.multiple ? $$selectedVal : $$selectedVal[0]")}`, ko(t, "change", o, null, !0);
            }(t, o, r);
            else if ("input" === s && "checkbox" === i) !function(t, e, n) {
                const o = n && n.number, r = Ao(t, "value") || "null", s = Ao(t, "true-value") || "true", i = Ao(t, "false-value") || "false";
                _o(t, "checked", `Array.isArray(${e})` + `?_i(${e},${r})>-1` + ("true" === s ? `:(${e})` : `:_q(${e},${s})`)), ko(t, "change", `var $$a=${e},` + "$$el=$event.target," + `$$c=$$el.checked?(${s}):(${i});` + "if(Array.isArray($$a)){" + `var $$v=${o ? "_n(" + r + ")" : r},` + "$$i=_i($$a,$$v);" + `if($$el.checked){$$i<0&&(${Eo(e, "$$a.concat([$$v])")})}` + `else{$$i>-1&&(${Eo(e, "$$a.slice(0,$$i).concat($$a.slice($$i+1))")})}` + `}else{${Eo(e, "$$c")}}`, null, !0);
            }(t, o, r);
            else if ("input" === s && "radio" === i) !function(t, e, n) {
                const o = n && n.number;
                let r = Ao(t, "value") || "null";
                _o(t, "checked", `_q(${e},${r = o ? `_n(${r})` : r})`), ko(t, "change", Eo(e, r), null, !0);
            }(t, o, r);
            else if ("input" === s || "textarea" === s) !function(t, e, n) {
                const o = t.attrsMap.type, { lazy: r , number: s , trim: i  } = n || {
                }, a = !r && "range" !== o, c = r ? "change" : "range" === o ? Vo : "input";
                let l = "$event.target.value";
                i && (l = "$event.target.value.trim()"), s && (l = `_n(${l})`);
                let u = Eo(e, l);
                a && (u = `if($event.target.composing)return;${u}`), _o(t, "value", `(${e})`), ko(t, c, u, null, !0), (i || s) && ko(t, "blur", "$forceUpdate()");
            }(t, o, r);
            else if (!F.isReservedTag(s)) return No(t, o, r), !1;
            return !0;
        },
        text: function(t, e) {
            e.value && _o(t, "textContent", `_s(${e.value})`, e);
        },
        html: function(t, e) {
            e.value && _o(t, "innerHTML", `_s(${e.value})`, e);
        }
    },
    isPreTag: (t)=>"pre" === t
    ,
    isUnaryTag: ms,
    mustUseProp: On,
    canBeLeftOpenTag: ys,
    isReservedTag: Vn,
    getTagNamespace: zn,
    staticKeys: function(t) {
        return t.reduce((t, e)=>t.concat(e.staticKeys || [])
        , []).join(",");
    }(mi)
};
let gi, vi;
const $i = v(function(t) {
    return d("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap" + (t ? "," + t : ""));
});
function _i(t, e) {
    t && (gi = $i(e.staticKeys || ""), vi = e.isReservedTag || T1, (function t(e) {
        e.static = (function(t) {
            if (2 === t.type) return !1;
            if (3 === t.type) return !0;
            return !(!t.pre && (t.hasBindings || t.if || t.for || p(t.tag) || !vi(t.tag) || function(t) {
                for(; t.parent;){
                    if ("template" !== (t = t.parent).tag) return !1;
                    if (t.for) return !0;
                }
                return !1;
            }(t) || !Object.keys(t).every(gi)));
        })(e);
        if (1 === e.type) {
            if (!vi(e.tag) && "slot" !== e.tag && null == e.attrsMap["inline-template"]) return;
            for(let n = 0, o = e.children.length; n < o; n++){
                const o = e.children[n];
                t(o), o.static || (e.static = !1);
            }
            if (e.ifConditions) for(let n4 = 1, o4 = e.ifConditions.length; n4 < o4; n4++){
                const o4 = e.ifConditions[n4].block;
                t(o4), o4.static || (e.static = !1);
            }
        }
    })(t), (function t(e, n) {
        if (1 === e.type) {
            if ((e.static || e.once) && (e.staticInFor = n), e.static && e.children.length && (1 !== e.children.length || 3 !== e.children[0].type)) return void (e.staticRoot = !0);
            if (e.staticRoot = !1, e.children) for(let o = 0, r = e.children.length; o < r; o++)t(e.children[o], n || !!e.for);
            if (e.ifConditions) for(let o4 = 1, r4 = e.ifConditions.length; o4 < r4; o4++)t(e.ifConditions[o4].block, n);
        }
    })(t, !1));
}
const bi = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/, wi = /\([^)]*?\);*$/, Ci = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/, xi = {
    esc: 27,
    tab: 9,
    enter: 13,
    space: 32,
    up: 38,
    left: 37,
    right: 39,
    down: 40,
    delete: [
        8,
        46
    ]
}, ki = {
    esc: [
        "Esc",
        "Escape"
    ],
    tab: "Tab",
    enter: "Enter",
    space: [
        " ",
        "Spacebar"
    ],
    up: [
        "Up",
        "ArrowUp"
    ],
    left: [
        "Left",
        "ArrowLeft"
    ],
    right: [
        "Right",
        "ArrowRight"
    ],
    down: [
        "Down",
        "ArrowDown"
    ],
    delete: [
        "Backspace",
        "Delete",
        "Del"
    ]
}, Ai = (t)=>`if(${t})return null;`
, Oi = {
    stop: "$event.stopPropagation();",
    prevent: "$event.preventDefault();",
    self: Ai("$event.target !== $event.currentTarget"),
    ctrl: Ai("!$event.ctrlKey"),
    shift: Ai("!$event.shiftKey"),
    alt: Ai("!$event.altKey"),
    meta: Ai("!$event.metaKey"),
    left: Ai("'button' in $event && $event.button !== 0"),
    middle: Ai("'button' in $event && $event.button !== 1"),
    right: Ai("'button' in $event && $event.button !== 2")
};
function Si(t, e) {
    const n = e ? "nativeOn:" : "on:";
    let o = "", r = "";
    for(const e5 in t){
        const n = Ti(t[e5]);
        t[e5] && t[e5].dynamic ? r += `${e5},${n},` : o += `"${e5}":${n},`;
    }
    return o = `{${o.slice(0, -1)}}`, r ? n + `_d(${o},[${r.slice(0, -1)}])` : n + o;
}
function Ti(t) {
    if (!t) return "function(){}";
    if (Array.isArray(t)) return `[${t.map((t)=>Ti(t)
    ).join(",")}]`;
    const e = Ci.test(t.value), n = bi.test(t.value), o = Ci.test(t.value.replace(wi, ""));
    if (t.modifiers) {
        let r = "", s = "";
        const i = [];
        for(const e5 in t.modifiers)if (Oi[e5]) s += Oi[e5], xi[e5] && i.push(e5);
        else if ("exact" === e5) {
            const e = t.modifiers;
            s += Ai([
                "ctrl",
                "shift",
                "alt",
                "meta"
            ].filter((t)=>!e[t]
            ).map((t)=>`$event.${t}Key`
            ).join("||"));
        } else i.push(e5);
        return i.length && (r += (function(t) {
            return "if(!$event.type.indexOf('key')&&" + `${t.map(Ni).join("&&")})return null;`;
        })(i)), s && (r += s), `function($event){${r}${e ? `return ${t.value}.apply(null, arguments)` : n ? `return (${t.value}).apply(null, arguments)` : o ? `return ${t.value}` : t.value}}`;
    }
    return e || n ? t.value : `function($event){${o ? `return ${t.value}` : t.value}}`;
}
function Ni(t) {
    const e = parseInt(t, 10);
    if (e) return `$event.keyCode!==${e}`;
    const n = xi[t], o = ki[t];
    return "_k($event.keyCode," + `${JSON.stringify(t)},` + `${JSON.stringify(n)},` + "$event.key," + `${JSON.stringify(o)}` + ")";
}
var Ei = {
    on: function(t, e) {
        t.wrapListeners = (t)=>`_g(${t},${e.value})`
        ;
    },
    bind: function(t, e) {
        t.wrapData = (n)=>`_b(${n},'${t.tag}',${e.value},${e.modifiers && e.modifiers.prop ? "true" : "false"}${e.modifiers && e.modifiers.sync ? ",true" : ""})`
        ;
    },
    cloak: S1
};
class ji {
    constructor(t6){
        this.options = t6, this.warn = t6.warn || vo, this.transforms = $o(t6.modules, "transformCode"), this.dataGenFns = $o(t6.modules, "genData"), this.directives = A(A({
        }, Ei), t6.directives);
        const e5 = t6.isReservedTag || T1;
        this.maybeComponent = (t)=>!!t.component || !e5(t.tag)
        , this.onceId = 0, this.staticRenderFns = [], this.pre = !1;
    }
}
function Di(t, e) {
    const n = new ji(e);
    return {
        render: `with(this){return ${t ? "script" === t.tag ? "null" : Li(t, n) : '_c("div")'}}`,
        staticRenderFns: n.staticRenderFns
    };
}
function Li(t, e) {
    if (t.parent && (t.pre = t.pre || t.parent.pre), t.staticRoot && !t.staticProcessed) return Ii(t, e);
    if (t.once && !t.onceProcessed) return Mi(t, e);
    if (t.for && !t.forProcessed) return Pi(t, e);
    if (t.if && !t.ifProcessed) return Fi(t, e);
    if ("template" !== t.tag || t.slotTarget || e.pre) {
        if ("slot" === t.tag) return (function(t, e) {
            const n = t.slotName || '"default"', o = Ui(t, e);
            let r = `_t(${n}${o ? `,function(){return ${o}}` : ""}`;
            const s = t.attrs || t.dynamicAttrs ? Ki((t.attrs || []).concat(t.dynamicAttrs || []).map((t)=>({
                    name: _(t.name),
                    value: t.value,
                    dynamic: t.dynamic
                })
            )) : null, i = t.attrsMap["v-bind"];
            !s && !i || o || (r += ",null");
            s && (r += `,${s}`);
            i && (r += `${s ? "" : ",null"},${i}`);
            return r + ")";
        })(t, e);
        {
            let n;
            if (t.component) n = (function(t, e, n) {
                const o = e.inlineTemplate ? null : Ui(e, n, !0);
                return `_c(${t},${Ri(e, n)}${o ? `,${o}` : ""})`;
            })(t.component, t, e);
            else {
                let o;
                (!t.plain || t.pre && e.maybeComponent(t)) && (o = Ri(t, e));
                const r = t.inlineTemplate ? null : Ui(t, e, !0);
                n = `_c('${t.tag}'${o ? `,${o}` : ""}${r ? `,${r}` : ""})`;
            }
            for(let o = 0; o < e.transforms.length; o++)n = e.transforms[o](t, n);
            return n;
        }
    }
    return Ui(t, e) || "void 0";
}
function Ii(t, e) {
    t.staticProcessed = !0;
    const n = e.pre;
    return t.pre && (e.pre = t.pre), e.staticRenderFns.push(`with(this){return ${Li(t, e)}}`), e.pre = n, `_m(${e.staticRenderFns.length - 1}${t.staticInFor ? ",true" : ""})`;
}
function Mi(t, e) {
    if (t.onceProcessed = !0, t.if && !t.ifProcessed) return Fi(t, e);
    if (t.staticInFor) {
        let n = "", o = t.parent;
        for(; o;){
            if (o.for) {
                n = o.key;
                break;
            }
            o = o.parent;
        }
        return n ? `_o(${Li(t, e)},${e.onceId++},${n})` : Li(t, e);
    }
    return Ii(t, e);
}
function Fi(t, e, n, o) {
    return t.ifProcessed = !0, (function t(e, n, o, r) {
        if (!e.length) return r || "_e()";
        const s = e.shift();
        return s.exp ? `(${s.exp})?${i(s.block)}:${t(e, n, o, r)}` : `${i(s.block)}`;
        function i(t) {
            return o ? o(t, n) : t.once ? Mi(t, n) : Li(t, n);
        }
    })(t.ifConditions.slice(), e, n, o);
}
function Pi(t, e, n, o) {
    const r = t.for, s = t.alias, i = t.iterator1 ? `,${t.iterator1}` : "", a = t.iterator2 ? `,${t.iterator2}` : "";
    return t.forProcessed = !0, `${o || "_l"}((${r}),` + `function(${s}${i}${a}){` + `return ${(n || Li)(t, e)}` + "})";
}
function Ri(t, e) {
    let n = "{";
    const o = function(t, e) {
        const n = t.directives;
        if (!n) return;
        let o, r, s, i, a = "directives:[", c = !1;
        for(o = 0, r = n.length; o < r; o++){
            s = n[o], i = !0;
            const r = e.directives[s.name];
            r && (i = !!r(t, s, e.warn)), i && (c = !0, a += `{name:"${s.name}",rawName:"${s.rawName}"${s.value ? `,value:(${s.value}),expression:${JSON.stringify(s.value)}` : ""}${s.arg ? `,arg:${s.isDynamicArg ? s.arg : `"${s.arg}"`}` : ""}${s.modifiers ? `,modifiers:${JSON.stringify(s.modifiers)}` : ""}},`);
        }
        if (c) return a.slice(0, -1) + "]";
    }(t, e);
    o && (n += o + ","), t.key && (n += `key:${t.key},`), t.ref && (n += `ref:${t.ref},`), t.refInFor && (n += "refInFor:true,"), t.pre && (n += "pre:true,"), t.component && (n += `tag:"${t.tag}",`);
    for(let o4 = 0; o4 < e.dataGenFns.length; o4++)n += e.dataGenFns[o4](t);
    if (t.attrs && (n += `attrs:${Ki(t.attrs)},`), t.props && (n += `domProps:${Ki(t.props)},`), t.events && (n += `${Si(t.events, !1)},`), t.nativeEvents && (n += `${Si(t.nativeEvents, !0)},`), t.slotTarget && !t.slotScope && (n += `slot:${t.slotTarget},`), t.scopedSlots && (n += `${(function(t, e, n) {
        let o = t.for || Object.keys(e).some((t)=>{
            const n = e[t];
            return n.slotTargetDynamic || n.if || n.for || Hi(n);
        }), r = !!t.if;
        if (!o) {
            let e = t.parent;
            for(; e;){
                if (e.slotScope && e.slotScope !== Zs || e.for) {
                    o = !0;
                    break;
                }
                e.if && (r = !0), e = e.parent;
            }
        }
        const s = Object.keys(e).map((t)=>Bi(e[t], n)
        ).join(",");
        return `scopedSlots:_u([${s}]${o ? ",null,true" : ""}${!o && r ? `,null,false,${(function(t) {
            let e = 5381, n = t.length;
            for(; n;)e = 33 * e ^ t.charCodeAt(--n);
            return e >>> 0;
        })(s)}` : ""})`;
    })(t, t.scopedSlots, e)},`), t.model && (n += `model:{value:${t.model.value},callback:${t.model.callback},expression:${t.model.expression}},`), t.inlineTemplate) {
        const o = function(t, e) {
            const n = t.children[0];
            if (n && 1 === n.type) {
                const t = Di(n, e.options);
                return `inlineTemplate:{render:function(){${t.render}},staticRenderFns:[${t.staticRenderFns.map((t)=>`function(){${t}}`
                ).join(",")}]}`;
            }
        }(t, e);
        o && (n += `${o},`);
    }
    return n = n.replace(/,$/, "") + "}", t.dynamicAttrs && (n = `_b(${n},"${t.tag}",${Ki(t.dynamicAttrs)})`), t.wrapData && (n = t.wrapData(n)), t.wrapListeners && (n = t.wrapListeners(n)), n;
}
function Hi(t) {
    return 1 === t.type && ("slot" === t.tag || t.children.some(Hi));
}
function Bi(t, e) {
    const n = t.attrsMap["slot-scope"];
    if (t.if && !t.ifProcessed && !n) return Fi(t, e, Bi, "null");
    if (t.for && !t.forProcessed) return Pi(t, e, Bi);
    const o = t.slotScope === Zs ? "" : String(t.slotScope), r = `function(${o}){` + `return ${"template" === t.tag ? t.if && n ? `(${t.if})?${Ui(t, e) || "undefined"}:undefined` : Ui(t, e) || "undefined" : Li(t, e)}}`, s = o ? "" : ",proxy:true";
    return `{key:${t.slotTarget || '"default"'},fn:${r}${s}}`;
}
function Ui(t, e, n, o, r) {
    const s = t.children;
    if (s.length) {
        const t = s[0];
        if (1 === s.length && t.for && "template" !== t.tag && "slot" !== t.tag) {
            const r = n ? e.maybeComponent(t) ? ",1" : ",0" : "";
            return `${(o || Li)(t, e)}${r}`;
        }
        const i = n ? function(t, e) {
            let n = 0;
            for(let o = 0; o < t.length; o++){
                const r = t[o];
                if (1 === r.type) {
                    if (Vi(r) || r.ifConditions && r.ifConditions.some((t)=>Vi(t.block)
                    )) {
                        n = 2;
                        break;
                    }
                    (e(r) || r.ifConditions && r.ifConditions.some((t)=>e(t.block)
                    )) && (n = 1);
                }
            }
            return n;
        }(s, e.maybeComponent) : 0, a = r || zi;
        return `[${s.map((t)=>a(t, e)
        ).join(",")}]${i ? `,${i}` : ""}`;
    }
}
function Vi(t) {
    return void 0 !== t.for || "template" === t.tag || "slot" === t.tag;
}
function zi(t, e) {
    return 1 === t.type ? Li(t, e) : 3 === t.type && t.isComment ? (o = t, `_e(${JSON.stringify(o.text)})`) : `_v(${2 === (n = t).type ? n.expression : Ji(JSON.stringify(n.text))})`;
    var n, o;
}
function Ki(t) {
    let e = "", n = "";
    for(let o = 0; o < t.length; o++){
        const r = t[o], s = Ji(r.value);
        r.dynamic ? n += `${r.name},${s},` : e += `"${r.name}":${s},`;
    }
    return e = `{${e.slice(0, -1)}}`, n ? `_d(${e},[${n.slice(0, -1)}])` : e;
}
function Ji(t) {
    return t.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
}
new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b") + "\\b");
function qi(t, e) {
    try {
        return new Function(t);
    } catch (n) {
        return e.push({
            err: n,
            code: t
        }), S1;
    }
}
function Wi(t) {
    const e = Object.create(null);
    return function(n, o, r) {
        (o = A({
        }, o)).warn;
        delete o.warn;
        const s = o.delimiters ? String(o.delimiters) + n : n;
        if (e[s]) return e[s];
        const i = t(n, o), a = {
        }, c = [];
        return a.render = qi(i.render, c), a.staticRenderFns = i.staticRenderFns.map((t)=>qi(t, c)
        ), e[s] = a;
    };
}
const Zi = (Gi = function(t, e) {
    const n = si(t.trim(), e);
    !1 !== e.optimize && _i(n, e);
    const o = Di(n, e);
    return {
        ast: n,
        render: o.render,
        staticRenderFns: o.staticRenderFns
    };
}, function(t) {
    function e(e, n) {
        const o = Object.create(t), r = [], s = [];
        if (n) {
            n.modules && (o.modules = (t.modules || []).concat(n.modules)), n.directives && (o.directives = A(Object.create(t.directives || null), n.directives));
            for(const t8 in n)"modules" !== t8 && "directives" !== t8 && (o[t8] = n[t8]);
        }
        o.warn = (t, e, n)=>{
            (n ? s : r).push(t);
        };
        const i = Gi(e.trim(), o);
        return i.errors = r, i.tips = s, i;
    }
    return {
        compile: e,
        compileToFunctions: Wi(e)
    };
});
var Gi;
const { compile: Xi , compileToFunctions: Yi  } = Zi(yi);
let Qi;
function ta(t) {
    return (Qi = Qi || document.createElement("div")).innerHTML = t ? '<a href="\n"/>' : '<div a="\n"/>', Qi.innerHTML.indexOf("&#10;") > 0;
}
const ea = !!V && ta(!1), na = !!V && ta(!0), oa = v((t)=>{
    const e = qn(t);
    return e && e.innerHTML;
}), ra = gn.prototype.$mount;
gn.prototype.$mount = function(t, e) {
    if ((t = t && qn(t)) === document.body || t === document.documentElement) return this;
    const n = this.$options;
    if (!n.render) {
        let e = n.template;
        if (e) if ("string" == typeof e) "#" === e.charAt(0) && (e = oa(e));
        else {
            if (!e.nodeType) return this;
            e = e.innerHTML;
        }
        else t && (e = (function(t) {
            if (t.outerHTML) return t.outerHTML;
            {
                const e = document.createElement("div");
                return e.appendChild(t.cloneNode(!0)), e.innerHTML;
            }
        })(t));
        if (e) {
            const { render: t , staticRenderFns: o  } = Yi(e, {
                outputSourceRange: !1,
                shouldDecodeNewlines: ea,
                shouldDecodeNewlinesForHref: na,
                delimiters: n.delimiters,
                comments: n.comments
            }, this);
            n.render = t, n.staticRenderFns = o;
        }
    }
    return ra.call(this, t, e);
}, gn.compile = Yi;
function t8(t, e) {
    for(const n in e)t[n] = e[n];
    return t;
}
const e6 = /[!'()*]/g, n4 = (t)=>"%" + t.charCodeAt(0).toString(16)
, r4 = /%2C/g, o4 = (t)=>encodeURIComponent(t).replace(e6, n4).replace(r4, ",")
;
function i2(t) {
    try {
        return decodeURIComponent(t);
    } catch (t9) {
    }
    return t;
}
const s2 = (t)=>null == t || "object" == typeof t ? t : String(t)
;
function a2(t) {
    const e = {
    };
    return (t = t.trim().replace(/^(\?|#|&)/, "")) ? (t.split("&").forEach((t)=>{
        const n = t.replace(/\+/g, " ").split("="), r = i2(n.shift()), o = n.length > 0 ? i2(n.join("=")) : null;
        void 0 === e[r] ? e[r] = o : Array.isArray(e[r]) ? e[r].push(o) : e[r] = [
            e[r],
            o
        ];
    }), e) : e;
}
function c1(t) {
    const e = t ? Object.keys(t).map((e)=>{
        const n = t[e];
        if (void 0 === n) return "";
        if (null === n) return o4(e);
        if (Array.isArray(n)) {
            const t = [];
            return n.forEach((n)=>{
                void 0 !== n && (null === n ? t.push(o4(e)) : t.push(o4(e) + "=" + o4(n)));
            }), t.join("&");
        }
        return o4(e) + "=" + o4(n);
    }).filter((t)=>t.length > 0
    ).join("&") : null;
    return e ? "?" + e : "";
}
const u1 = /\/?$/;
function h1(t, e, n, r) {
    const o = r && r.options.stringifyQuery;
    let i = e.query || {
    };
    try {
        i = l1(i);
    } catch (t9) {
    }
    const s = {
        name: e.name || t && t.name,
        meta: t && t.meta || {
        },
        path: e.path || "/",
        hash: e.hash || "",
        query: i,
        params: e.params || {
        },
        fullPath: d1(e, o),
        matched: t ? f1(t) : []
    };
    return n && (s.redirectedFrom = d1(n, o)), Object.freeze(s);
}
function l1(t) {
    if (Array.isArray(t)) return t.map(l1);
    if (t && "object" == typeof t) {
        const e = {
        };
        for(const n in t)e[n] = l1(t[n]);
        return e;
    }
    return t;
}
const p1 = h1(null, {
    path: "/"
});
function f1(t) {
    const e = [];
    for(; t;)e.unshift(t), t = t.parent;
    return e;
}
function d1({ path: t , query: e = {
} , hash: n = ""  }, r) {
    return (t || "/") + (r || c1)(e) + n;
}
function y1(t, e, n) {
    return e === p1 ? t === e : !!e && (t.path && e.path ? t.path.replace(u1, "") === e.path.replace(u1, "") && (n || t.hash === e.hash && m1(t.query, e.query)) : !(!t.name || !e.name) && t.name === e.name && (n || t.hash === e.hash && m1(t.query, e.query) && m1(t.params, e.params)));
}
function m1(t = {
}, e = {
}) {
    if (!t || !e) return t === e;
    const n = Object.keys(t).sort(), r = Object.keys(e).sort();
    return n.length === r.length && n.every((n, o)=>{
        const i = t[n];
        if (r[o] !== n) return !1;
        const s = e[n];
        return null == i || null == s ? i === s : "object" == typeof i && "object" == typeof s ? m1(i, s) : String(i) === String(s);
    });
}
function g1(t) {
    for(let e = 0; e < t.matched.length; e++){
        const n = t.matched[e];
        for(const t9 in n.instances){
            const e = n.instances[t9], r = n.enteredCbs[t9];
            if (e && r) {
                delete n.enteredCbs[t9];
                for(let t10 = 0; t10 < r.length; t10++)e._isBeingDestroyed || r[t10](e);
            }
        }
    }
}
var w1 = {
    name: "RouterView",
    functional: !0,
    props: {
        name: {
            type: String,
            default: "default"
        }
    },
    render (e, { props: n , children: r , parent: o , data: i  }) {
        i.routerView = !0;
        const s = o.$createElement, a = n.name, c = o.$route, u = o._routerViewCache || (o._routerViewCache = {
        });
        let h = 0, l = !1;
        for(; o && o._routerRoot !== o;){
            const t = o.$vnode ? o.$vnode.data : {
            };
            t.routerView && h++, t.keepAlive && o._directInactive && o._inactive && (l = !0), o = o.$parent;
        }
        if (i.routerViewDepth = h, l) {
            const t = u[a], e = t && t.component;
            return e ? (t.configProps && b1(e, i, t.route, t.configProps), s(e, i, r)) : s();
        }
        const p = c.matched[h], f = p && p.components[a];
        if (!p || !f) return u[a] = null, s();
        u[a] = {
            component: f
        }, i.registerRouteInstance = (t, e)=>{
            const n = p.instances[a];
            (e && n !== t || !e && n === t) && (p.instances[a] = e);
        }, (i.hook || (i.hook = {
        })).prepatch = (t, e)=>{
            p.instances[a] = e.componentInstance;
        }, i.hook.init = (t)=>{
            t.data.keepAlive && t.componentInstance && t.componentInstance !== p.instances[a] && (p.instances[a] = t.componentInstance), g1(c);
        };
        const d = p.props && p.props[a];
        return d && (t8(u[a], {
            route: c,
            configProps: d
        }), b1(f, i, c, d)), s(f, i, r);
    }
};
function b1(e, n, r, o) {
    let i = n.props = function(t, e) {
        switch(typeof e){
            case "undefined":
                return;
            case "object":
                return e;
            case "function":
                return e(t);
            case "boolean":
                return e ? t.params : void 0;
        }
    }(r, o);
    if (i) {
        i = n.props = t8({
        }, i);
        const r = n.attrs = n.attrs || {
        };
        for(const t9 in i)e.props && t9 in e.props || (r[t9] = i[t9], delete i[t9]);
    }
}
function v1(t, e, n) {
    const r = t.charAt(0);
    if ("/" === r) return t;
    if ("?" === r || "#" === r) return e + t;
    const o = e.split("/");
    n && o[o.length - 1] || o.pop();
    const i = t.replace(/^\//, "").split("/");
    for(let t9 = 0; t9 < i.length; t9++){
        const e = i[t9];
        ".." === e ? o.pop() : "." !== e && o.push(e);
    }
    return "" !== o[0] && o.unshift(""), o.join("/");
}
function x1(t) {
    return t.replace(/\/\//g, "/");
}
var R1 = Array.isArray || function(t) {
    return "[object Array]" == Object.prototype.toString.call(t);
}, k1 = B2, E1 = S2, C1 = function(t, e) {
    return T2(S2(t, e), e);
}, A1 = T2, $1 = U2, O1 = new RegExp([
    "(\\\\.)",
    "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"
].join("|"), "g");
function S2(t, e) {
    for(var n, r = [], o = 0, i = 0, s = "", a = e && e.delimiter || "/"; null != (n = O1.exec(t));){
        var c = n[0], u = n[1], h = n.index;
        if (s += t.slice(i, h), i = h + c.length, u) s += u[1];
        else {
            var l = t[i], p = n[2], f = n[3], d = n[4], y = n[5], m = n[6], g = n[7];
            s && (r.push(s), s = "");
            var w = null != p && null != l && l !== p, b = "+" === m || "*" === m, v = "?" === m || "*" === m, x = n[2] || a, R = d || y;
            r.push({
                name: f || o++,
                prefix: p || "",
                delimiter: x,
                optional: v,
                repeat: b,
                partial: w,
                asterisk: !!g,
                pattern: R ? L1(R) : g ? ".*" : "[^" + P1(x) + "]+?"
            });
        }
    }
    return i < t.length && (s += t.substr(i)), s && r.push(s), r;
}
function j1(t) {
    return encodeURI(t).replace(/[\/?#]/g, function(t) {
        return "%" + t.charCodeAt(0).toString(16).toUpperCase();
    });
}
function T2(t, e) {
    for(var n = new Array(t.length), r = 0; r < t.length; r++)"object" == typeof t[r] && (n[r] = new RegExp("^(?:" + t[r].pattern + ")$", q1(e)));
    return function(e, r) {
        for(var o = "", i = e || {
        }, s = (r || {
        }).pretty ? j1 : encodeURIComponent, a = 0; a < t.length; a++){
            var c = t[a];
            if ("string" != typeof c) {
                var u, h = i[c.name];
                if (null == h) {
                    if (c.optional) {
                        c.partial && (o += c.prefix);
                        continue;
                    }
                    throw new TypeError('Expected "' + c.name + '" to be defined');
                }
                if (R1(h)) {
                    if (!c.repeat) throw new TypeError('Expected "' + c.name + '" to not repeat, but received `' + JSON.stringify(h) + "`");
                    if (0 === h.length) {
                        if (c.optional) continue;
                        throw new TypeError('Expected "' + c.name + '" to not be empty');
                    }
                    for(var l = 0; l < h.length; l++){
                        if (u = s(h[l]), !n[a].test(u)) throw new TypeError('Expected all "' + c.name + '" to match "' + c.pattern + '", but received `' + JSON.stringify(u) + "`");
                        o += (0 === l ? c.prefix : c.delimiter) + u;
                    }
                } else {
                    if (u = c.asterisk ? encodeURI(h).replace(/[?#]/g, function(t) {
                        return "%" + t.charCodeAt(0).toString(16).toUpperCase();
                    }) : s(h), !n[a].test(u)) throw new TypeError('Expected "' + c.name + '" to match "' + c.pattern + '", but received "' + u + '"');
                    o += c.prefix + u;
                }
            } else o += c;
        }
        return o;
    };
}
function P1(t) {
    return t.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
}
function L1(t) {
    return t.replace(/([=!:$\/()])/g, "\\$1");
}
function _1(t, e) {
    return t.keys = e, t;
}
function q1(t) {
    return t && t.sensitive ? "" : "i";
}
function U2(t, e, n) {
    R1(e) || (n = e || n, e = []);
    for(var r = (n = n || {
    }).strict, o = !1 !== n.end, i = "", s = 0; s < t.length; s++){
        var a = t[s];
        if ("string" == typeof a) i += P1(a);
        else {
            var c = P1(a.prefix), u = "(?:" + a.pattern + ")";
            e.push(a), a.repeat && (u += "(?:" + c + u + ")*"), i += u = a.optional ? a.partial ? c + "(" + u + ")?" : "(?:" + c + "(" + u + "))?" : c + "(" + u + ")";
        }
    }
    var h = P1(n.delimiter || "/"), l = i.slice(-h.length) === h;
    return r || (i = (l ? i.slice(0, -h.length) : i) + "(?:" + h + "(?=$))?"), i += o ? "$" : r && l ? "" : "(?=" + h + "|$)", _1(new RegExp("^" + i, q1(n)), e);
}
function B2(t, e, n) {
    return R1(e) || (n = e || n, e = []), n = n || {
    }, t instanceof RegExp ? (function(t, e) {
        var n = t.source.match(/\((?!\?)/g);
        if (n) for(var r = 0; r < n.length; r++)e.push({
            name: r,
            prefix: null,
            delimiter: null,
            optional: !1,
            repeat: !1,
            partial: !1,
            asterisk: !1,
            pattern: null
        });
        return _1(t, e);
    })(t, e) : R1(t) ? (function(t, e, n) {
        for(var r = [], o = 0; o < t.length; o++)r.push(B2(t[o], e, n).source);
        return _1(new RegExp("(?:" + r.join("|") + ")", q1(n)), e);
    })(t, e, n) : (function(t, e, n) {
        return U2(S2(t, n), e, n);
    })(t, e, n);
}
k1.parse = E1, k1.compile = C1, k1.tokensToFunction = A1, k1.tokensToRegExp = $1;
const I1 = Object.create(null);
function M1(t, e, n) {
    e = e || {
    };
    try {
        const n5 = I1[t] || (I1[t] = k1.compile(t));
        return "string" == typeof e.pathMatch && (e[0] = e.pathMatch), n5(e, {
            pretty: !0
        });
    } catch (t9) {
        return "";
    } finally{
        delete e[0];
    }
}
function V1(e, n, r, o) {
    let i = "string" == typeof e ? {
        path: e
    } : e;
    if (i._normalized) return i;
    if (i.name) {
        i = t8({
        }, e);
        const n = i.params;
        return n && "object" == typeof n && (i.params = t8({
        }, n)), i;
    }
    if (!i.path && i.params && n) {
        i = t8({
        }, i), i._normalized = !0;
        const e = t8(t8({
        }, n.params), i.params);
        if (n.name) i.name = n.name, i.params = e;
        else if (n.matched.length) {
            const t = n.matched[n.matched.length - 1].path;
            i.path = M1(t, e, n.path);
        }
        return i;
    }
    const c = function(t) {
        let e = "", n = "";
        const r = t.indexOf("#");
        r >= 0 && (e = t.slice(r), t = t.slice(0, r));
        const o = t.indexOf("?");
        return o >= 0 && (n = t.slice(o + 1), t = t.slice(0, o)), {
            path: t,
            query: n,
            hash: e
        };
    }(i.path || ""), u = n && n.path || "/", h = c.path ? v1(c.path, u, r || i.append) : u, l = function(t, e = {
    }, n) {
        const r = n || a2;
        let o;
        try {
            o = r(t || "");
        } catch (t9) {
            o = {
            };
        }
        for(const t10 in e){
            const n = e[t10];
            o[t10] = Array.isArray(n) ? n.map(s2) : s2(n);
        }
        return o;
    }(c.query, i.query, o && o.options.parseQuery);
    let p = i.hash || c.hash;
    return p && "#" !== p.charAt(0) && (p = "#" + p), {
        _normalized: !0,
        path: h,
        query: l,
        hash: p
    };
}
const H1 = ()=>{
};
var N1 = {
    name: "RouterLink",
    props: {
        to: {
            type: [
                String,
                Object
            ],
            required: !0
        },
        tag: {
            type: String,
            default: "a"
        },
        custom: Boolean,
        exact: Boolean,
        exactPath: Boolean,
        append: Boolean,
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        ariaCurrentValue: {
            type: String,
            default: "page"
        },
        event: {
            type: [
                String,
                Array
            ],
            default: "click"
        }
    },
    render (e) {
        const n = this.$router, r = this.$route, { location: o , route: i , href: s  } = n.resolve(this.to, r, this.append), a = {
        }, c = n.options.linkActiveClass, l = n.options.linkExactActiveClass, p = null == c ? "router-link-active" : c, f = null == l ? "router-link-exact-active" : l, d = null == this.activeClass ? p : this.activeClass, m = null == this.exactActiveClass ? f : this.exactActiveClass, g = i.redirectedFrom ? h1(null, V1(i.redirectedFrom), null, n) : i;
        a[m] = y1(r, g, this.exactPath), a[d] = this.exact || this.exactPath ? a[m] : (function(t, e) {
            return 0 === t.path.replace(u1, "/").indexOf(e.path.replace(u1, "/")) && (!e.hash || t.hash === e.hash) && (function(t, e) {
                for(const n in e)if (!(n in t)) return !1;
                return !0;
            })(t.query, e.query);
        })(r, g);
        const w = a[m] ? this.ariaCurrentValue : null, b = (t)=>{
            F1(t) && (this.replace ? n.replace(o, H1) : n.push(o, H1));
        }, v = {
            click: F1
        };
        Array.isArray(this.event) ? this.event.forEach((t)=>{
            v[t] = b;
        }) : v[this.event] = b;
        const x = {
            class: a
        }, R = !this.$scopedSlots.$hasNormal && this.$scopedSlots.default && this.$scopedSlots.default({
            href: s,
            route: i,
            navigate: b,
            isActive: a[d],
            isExactActive: a[m]
        });
        if (R) {
            if (1 === R.length) return R[0];
            if (R.length > 1 || !R.length) return 0 === R.length ? e() : e("span", {
            }, R);
        }
        if ("a" === this.tag) x.on = v, x.attrs = {
            href: s,
            "aria-current": w
        };
        else {
            const e = function t(e) {
                if (e) {
                    let n;
                    for(let r = 0; r < e.length; r++){
                        if (n = e[r], "a" === n.tag) return n;
                        if (n.children && (n = t(n.children))) return n;
                    }
                }
            }(this.$slots.default);
            if (e) {
                e.isStatic = !1;
                const n = e.data = t8({
                }, e.data);
                n.on = n.on || {
                };
                for(const t9 in n.on){
                    const e = n.on[t9];
                    t9 in v && (n.on[t9] = Array.isArray(e) ? e : [
                        e
                    ]);
                }
                for(const t10 in v)t10 in n.on ? n.on[t10].push(v[t10]) : n.on[t10] = b;
                const r = e.data.attrs = t8({
                }, e.data.attrs);
                r.href = s, r["aria-current"] = w;
            } else x.on = v;
        }
        return e(this.tag, x, this.$slots.default);
    }
};
function F1(t) {
    if (!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey || t.defaultPrevented || void 0 !== t.button && 0 !== t.button)) {
        if (t.currentTarget && t.currentTarget.getAttribute) {
            const e = t.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(e)) return;
        }
        return t.preventDefault && t.preventDefault(), !0;
    }
}
let z1;
const D1 = "undefined" != typeof window;
function K1(t, e, n, r, o) {
    const i = e || [], s = n || Object.create(null), a = r || Object.create(null);
    t.forEach((t)=>{
        !function t(e, n, r, o, i, s) {
            const { path: a , name: c  } = o, u = o.pathToRegexpOptions || {
            }, h = function(t, e, n) {
                n || (t = t.replace(/\/$/, ""));
                return "/" === t[0] || null == e ? t : x1(`${e.path}/${t}`);
            }(a, i, u.strict);
            "boolean" == typeof o.caseSensitive && (u.sensitive = o.caseSensitive);
            const l = {
                path: h,
                regex: J1(h, u),
                components: o.components || {
                    default: o.component
                },
                alias: o.alias ? "string" == typeof o.alias ? [
                    o.alias
                ] : o.alias : [],
                instances: {
                },
                enteredCbs: {
                },
                name: c,
                parent: i,
                matchAs: s,
                redirect: o.redirect,
                beforeEnter: o.beforeEnter,
                meta: o.meta || {
                },
                props: null == o.props ? {
                } : o.components ? o.props : {
                    default: o.props
                }
            };
            o.children && o.children.forEach((o)=>{
                const i = s ? x1(`${s}/${o.path}`) : void 0;
                t(e, n, r, o, l, i);
            });
            n[l.path] || (e.push(l.path), n[l.path] = l);
            if (void 0 !== o.alias) {
                const s = Array.isArray(o.alias) ? o.alias : [
                    o.alias
                ];
                for(let a = 0; a < s.length; ++a){
                    const c = {
                        path: s[a],
                        children: o.children
                    };
                    t(e, n, r, c, i, l.path || "/");
                }
            }
            c && (r[c] || (r[c] = l));
        }(i, s, a, t, o);
    });
    for(let t9 = 0, e7 = i.length; t9 < e7; t9++)"*" === i[t9] && (i.push(i.splice(t9, 1)[0]), e7--, t9--);
    return {
        pathList: i,
        pathMap: s,
        nameMap: a
    };
}
function J1(t, e) {
    return k1(t, [], e);
}
function Q1(t11, e) {
    const { pathList: n , pathMap: r , nameMap: o  } = K1(t11);
    function i(t10, i, s) {
        const c = V1(t10, i, !1, e), { name: u  } = c;
        if (u) {
            const t = o[u];
            if (!t) return a(null, c);
            const e = t.regex.keys.filter((t)=>!t.optional
            ).map((t)=>t.name
            );
            if ("object" != typeof c.params && (c.params = {
            }), i && "object" == typeof i.params) for(const t9 in i.params)!(t9 in c.params) && e.indexOf(t9) > -1 && (c.params[t9] = i.params[t9]);
            return c.path = M1(t.path, c.params), a(t, c, s);
        }
        if (c.path) {
            c.params = {
            };
            for(let t = 0; t < n.length; t++){
                const e = n[t], o = r[e];
                if (X1(o.regex, c.path, c.params)) return a(o, c, s);
            }
        }
        return a(null, c);
    }
    function s(t, n) {
        const r = t.redirect;
        let s = "function" == typeof r ? r(h1(t, n, null, e)) : r;
        if ("string" == typeof s && (s = {
            path: s
        }), !s || "object" != typeof s) return a(null, n);
        const c = s, { name: u , path: l  } = c;
        let { query: p , hash: f , params: d  } = n;
        if (p = c.hasOwnProperty("query") ? c.query : p, f = c.hasOwnProperty("hash") ? c.hash : f, d = c.hasOwnProperty("params") ? c.params : d, u) return o[u], i({
            _normalized: !0,
            name: u,
            query: p,
            hash: f,
            params: d
        }, void 0, n);
        if (l) {
            return i({
                _normalized: !0,
                path: M1(function(t, e) {
                    return v1(t, e.parent ? e.parent.path : "/", !0);
                }(l, t), d),
                query: p,
                hash: f
            }, void 0, n);
        }
        return a(null, n);
    }
    function a(t, n, r) {
        return t && t.redirect ? s(t, r || n) : t && t.matchAs ? (function(t, e, n) {
            const r = i({
                _normalized: !0,
                path: M1(n, e.params)
            });
            if (r) {
                const t = r.matched, n = t[t.length - 1];
                return e.params = r.params, a(n, e);
            }
            return a(null, e);
        })(0, n, t.matchAs) : h1(t, n, r, e);
    }
    return {
        match: i,
        addRoute: function(t, e) {
            const i = "object" != typeof t ? o[t] : void 0;
            K1([
                e || t
            ], n, r, o, i), i && i.alias.length && K1(i.alias.map((t)=>({
                    path: t,
                    children: [
                        e
                    ]
                })
            ), n, r, o, i);
        },
        getRoutes: function() {
            return n.map((t)=>r[t]
            );
        },
        addRoutes: function(t) {
            K1(t, n, r, o);
        }
    };
}
function X1(t, e, n) {
    const r = e.match(t);
    if (!r) return !1;
    if (!n) return !0;
    for(let e7 = 1, o = r.length; e7 < o; ++e7){
        const o = t.keys[e7 - 1];
        o && (n[o.name || "pathMatch"] = "string" == typeof r[e7] ? i2(r[e7]) : r[e7]);
    }
    return !0;
}
const Y1 = D1 && window.performance && window.performance.now ? window.performance : Date;
function W1() {
    return Y1.now().toFixed(3);
}
let G1 = W1();
function Z1() {
    return G1;
}
function tt1(t) {
    return G1 = t;
}
const et1 = Object.create(null);
function nt1() {
    "scrollRestoration" in window.history && (window.history.scrollRestoration = "manual");
    const e = window.location.protocol + "//" + window.location.host, n = window.location.href.replace(e, ""), r = t8({
    }, window.history.state);
    return r.key = Z1(), window.history.replaceState(r, "", n), window.addEventListener("popstate", it1), ()=>{
        window.removeEventListener("popstate", it1);
    };
}
function rt1(t, e, n, r) {
    if (!t.app) return;
    const o = t.options.scrollBehavior;
    o && t.app.$nextTick(()=>{
        const i = function() {
            const t = Z1();
            if (t) return et1[t];
        }(), s = o.call(t, e, n, r ? i : null);
        s && ("function" == typeof s.then ? s.then((t)=>{
            ht1(t, i);
        }).catch((t)=>{
        }) : ht1(s, i));
    });
}
function ot1() {
    const t = Z1();
    t && (et1[t] = {
        x: window.pageXOffset,
        y: window.pageYOffset
    });
}
function it1(t) {
    ot1(), t.state && t.state.key && tt1(t.state.key);
}
function st1(t) {
    return ct1(t.x) || ct1(t.y);
}
function at1(t) {
    return {
        x: ct1(t.x) ? t.x : window.pageXOffset,
        y: ct1(t.y) ? t.y : window.pageYOffset
    };
}
function ct1(t) {
    return "number" == typeof t;
}
const ut1 = /^#\d/;
function ht1(t, e) {
    const n = "object" == typeof t;
    if (n && "string" == typeof t.selector) {
        const n = ut1.test(t.selector) ? document.getElementById(t.selector.slice(1)) : document.querySelector(t.selector);
        if (n) {
            let o = t.offset && "object" == typeof t.offset ? t.offset : {
            };
            o = {
                x: ct1((r = o).x) ? r.x : 0,
                y: ct1(r.y) ? r.y : 0
            }, e = (function(t, e) {
                const n = document.documentElement.getBoundingClientRect(), r = t.getBoundingClientRect();
                return {
                    x: r.left - n.left - e.x,
                    y: r.top - n.top - e.y
                };
            })(n, o);
        } else st1(t) && (e = at1(t));
    } else n && st1(t) && (e = at1(t));
    var r;
    e && ("scrollBehavior" in document.documentElement.style ? window.scrollTo({
        left: e.x,
        top: e.y,
        behavior: t.behavior
    }) : window.scrollTo(e.x, e.y));
}
const lt1 = D1 && function() {
    const t = window.navigator.userAgent;
    return (-1 === t.indexOf("Android 2.") && -1 === t.indexOf("Android 4.0") || -1 === t.indexOf("Mobile Safari") || -1 !== t.indexOf("Chrome") || -1 !== t.indexOf("Windows Phone")) && window.history && "function" == typeof window.history.pushState;
}();
function pt1(e, n) {
    ot1();
    const r = window.history;
    try {
        if (n) {
            const n = t8({
            }, r.state);
            n.key = Z1(), r.replaceState(n, "", e);
        } else r.pushState({
            key: tt1(W1())
        }, "", e);
    } catch (t) {
        window.location[n ? "replace" : "assign"](e);
    }
}
function ft1(t) {
    pt1(t, !0);
}
function dt1(t, e, n) {
    const r = (o)=>{
        o >= t.length ? n() : t[o] ? e(t[o], ()=>{
            r(o + 1);
        }) : r(o + 1);
    };
    r(0);
}
const yt1 = {
    redirected: 2,
    aborted: 4,
    cancelled: 8,
    duplicated: 16
};
function mt1(t, e) {
    return wt1(t, e, yt1.redirected, `Redirected when going from "${t.fullPath}" to "${function(t) {
        if ("string" == typeof t) return t;
        if ("path" in t) return t.path;
        const e = {
        };
        return bt1.forEach((n)=>{
            n in t && (e[n] = t[n]);
        }), JSON.stringify(e, null, 2);
    }(e)}" via a navigation guard.`);
}
function gt1(t, e) {
    return wt1(t, e, yt1.cancelled, `Navigation cancelled from "${t.fullPath}" to "${e.fullPath}" with a new navigation.`);
}
function wt1(t, e, n, r) {
    const o = new Error(r);
    return o._isRouter = !0, o.from = t, o.to = e, o.type = n, o;
}
const bt1 = [
    "params",
    "query",
    "hash"
];
function vt1(t) {
    return Object.prototype.toString.call(t).indexOf("Error") > -1;
}
function xt1(t, e) {
    return vt1(t) && t._isRouter && (null == e || t.type === e);
}
function Rt1(t) {
    return (e, n, r)=>{
        let o = !1, i = 0, s = null;
        kt1(t, (t, e, n, a)=>{
            if ("function" == typeof t && void 0 === t.cid) {
                o = !0, i++;
                const e = At1((e)=>{
                    var o;
                    ((o = e).__esModule || Ct1 && "Module" === o[Symbol.toStringTag]) && (e = e.default), t.resolved = "function" == typeof e ? e : z1.extend(e), n.components[a] = e, i--, i <= 0 && r();
                }), c = At1((t)=>{
                    const e = `Failed to resolve async component ${a}: ${t}`;
                    s || (s = vt1(t) ? t : new Error(e), r(s));
                });
                let u;
                try {
                    u = t(e, c);
                } catch (t9) {
                    c(t9);
                }
                if (u) if ("function" == typeof u.then) u.then(e, c);
                else {
                    const t = u.component;
                    t && "function" == typeof t.then && t.then(e, c);
                }
            }
        }), o || r();
    };
}
function kt1(t, e) {
    return Et1(t.map((t)=>Object.keys(t.components).map((n)=>e(t.components[n], t.instances[n], t, n)
        )
    ));
}
function Et1(t) {
    return Array.prototype.concat.apply([], t);
}
const Ct1 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
function At1(t) {
    let e = !1;
    return function(...n) {
        if (!e) return e = !0, t.apply(this, n);
    };
}
class $t1 {
    constructor(t9, e7){
        this.router = t9, this.base = (function(t) {
            if (!t) if (D1) {
                const e = document.querySelector("base");
                t = (t = e && e.getAttribute("href") || "/").replace(/^https?:\/\/[^\/]+/, "");
            } else t = "/";
            "/" !== t.charAt(0) && (t = "/" + t);
            return t.replace(/\/$/, "");
        })(e7), this.current = p1, this.pending = null, this.ready = !1, this.readyCbs = [], this.readyErrorCbs = [], this.errorCbs = [], this.listeners = [];
    }
    listen(t) {
        this.cb = t;
    }
    onReady(t, e) {
        this.ready ? t() : (this.readyCbs.push(t), e && this.readyErrorCbs.push(e));
    }
    onError(t) {
        this.errorCbs.push(t);
    }
    transitionTo(t, e, n) {
        let r;
        try {
            r = this.router.match(t, this.current);
        } catch (t10) {
            throw this.errorCbs.forEach((e)=>{
                e(t10);
            }), t10;
        }
        const o = this.current;
        this.confirmTransition(r, ()=>{
            this.updateRoute(r), e && e(r), this.ensureURL(), this.router.afterHooks.forEach((t)=>{
                t && t(r, o);
            }), this.ready || (this.ready = !0, this.readyCbs.forEach((t)=>{
                t(r);
            }));
        }, (t)=>{
            n && n(t), t && !this.ready && (xt1(t, yt1.redirected) && o === p1 || (this.ready = !0, this.readyErrorCbs.forEach((e)=>{
                e(t);
            })));
        });
    }
    confirmTransition(t, e, n) {
        const r = this.current;
        this.pending = t;
        const o = (t)=>{
            !xt1(t) && vt1(t) && (this.errorCbs.length ? this.errorCbs.forEach((e)=>{
                e(t);
            }) : console.error(t)), n && n(t);
        }, i = t.matched.length - 1, s = r.matched.length - 1;
        if (y1(t, r) && i === s && t.matched[i] === r.matched[s]) return this.ensureURL(), o(function(t, e) {
            const n = wt1(t, e, yt1.duplicated, `Avoided redundant navigation to current location: "${t.fullPath}".`);
            return n.name = "NavigationDuplicated", n;
        }(r, t));
        const { updated: a , deactivated: c , activated: u  } = function(t, e) {
            let n;
            const r = Math.max(t.length, e.length);
            for(n = 0; n < r && t[n] === e[n]; n++);
            return {
                updated: e.slice(0, n),
                activated: e.slice(n),
                deactivated: t.slice(n)
            };
        }(this.current.matched, t.matched), h = [].concat(function(t) {
            return Ot1(t, "beforeRouteLeave", St1, !0);
        }(c), this.router.beforeHooks, function(t) {
            return Ot1(t, "beforeRouteUpdate", St1);
        }(a), u.map((t)=>t.beforeEnter
        ), Rt1(u)), l = (e, n)=>{
            if (this.pending !== t) return o(gt1(r, t));
            try {
                e(t, r, (e)=>{
                    !1 === e ? (this.ensureURL(!0), o(function(t, e) {
                        return wt1(t, e, yt1.aborted, `Navigation aborted from "${t.fullPath}" to "${e.fullPath}" via a navigation guard.`);
                    }(r, t))) : vt1(e) ? (this.ensureURL(!0), o(e)) : "string" == typeof e || "object" == typeof e && ("string" == typeof e.path || "string" == typeof e.name) ? (o(mt1(r, t)), "object" == typeof e && e.replace ? this.replace(e) : this.push(e)) : n(e);
                });
            } catch (t10) {
                o(t10);
            }
        };
        dt1(h, l, ()=>{
            dt1((function(t) {
                return Ot1(t, "beforeRouteEnter", (t, e, n, r)=>(function(t, e, n) {
                        return function(r, o, i) {
                            return t(r, o, (t)=>{
                                "function" == typeof t && (e.enteredCbs[n] || (e.enteredCbs[n] = []), e.enteredCbs[n].push(t)), i(t);
                            });
                        };
                    })(t, n, r)
                );
            })(u).concat(this.router.resolveHooks), l, ()=>{
                if (this.pending !== t) return o(gt1(r, t));
                this.pending = null, e(t), this.router.app && this.router.app.$nextTick(()=>{
                    g1(t);
                });
            });
        });
    }
    updateRoute(t) {
        this.current = t, this.cb && this.cb(t);
    }
    setupListeners() {
    }
    teardown() {
        this.listeners.forEach((t)=>{
            t();
        }), this.listeners = [], this.current = p1, this.pending = null;
    }
}
function Ot1(t, e, n, r) {
    const o = kt1(t, (t, r, o, i)=>{
        const s = function(t, e) {
            "function" != typeof t && (t = z1.extend(t));
            return t.options[e];
        }(t, e);
        if (s) return Array.isArray(s) ? s.map((t)=>n(t, r, o, i)
        ) : n(s, r, o, i);
    });
    return Et1(r ? o.reverse() : o);
}
function St1(t, e) {
    if (e) return function() {
        return t.apply(e, arguments);
    };
}
class jt1 extends $t1 {
    constructor(t10, e8){
        super(t10, e8), this._startLocation = Tt2(this.base);
    }
    setupListeners() {
        if (this.listeners.length > 0) return;
        const t = this.router, e = t.options.scrollBehavior, n = lt1 && e;
        n && this.listeners.push(nt1());
        const r = ()=>{
            const e = this.current, r = Tt2(this.base);
            this.current === p1 && r === this._startLocation || this.transitionTo(r, (r)=>{
                n && rt1(t, r, e, !0);
            });
        };
        window.addEventListener("popstate", r), this.listeners.push(()=>{
            window.removeEventListener("popstate", r);
        });
    }
    go(t) {
        window.history.go(t);
    }
    push(t, e, n) {
        const { current: r  } = this;
        this.transitionTo(t, (t)=>{
            pt1(x1(this.base + t.fullPath)), rt1(this.router, t, r, !1), e && e(t);
        }, n);
    }
    replace(t, e, n) {
        const { current: r  } = this;
        this.transitionTo(t, (t)=>{
            ft1(x1(this.base + t.fullPath)), rt1(this.router, t, r, !1), e && e(t);
        }, n);
    }
    ensureURL(t) {
        if (Tt2(this.base) !== this.current.fullPath) {
            const e = x1(this.base + this.current.fullPath);
            t ? pt1(e) : ft1(e);
        }
    }
    getCurrentLocation() {
        return Tt2(this.base);
    }
}
function Tt2(t) {
    let e = window.location.pathname;
    const n = e.toLowerCase(), r = t.toLowerCase();
    return !t || n !== r && 0 !== n.indexOf(x1(r + "/")) || (e = e.slice(t.length)), (e || "/") + window.location.search + window.location.hash;
}
class Pt1 extends $t1 {
    constructor(t11, e9, n5){
        super(t11, e9), n5 && (function(t) {
            const e = Tt2(t);
            if (!/^\/#/.test(e)) return window.location.replace(x1(t + "/#" + e)), !0;
        })(this.base) || Lt2();
    }
    setupListeners() {
        if (this.listeners.length > 0) return;
        const t = this.router.options.scrollBehavior, e = lt1 && t;
        e && this.listeners.push(nt1());
        const n = ()=>{
            const t = this.current;
            Lt2() && this.transitionTo(_t1(), (n)=>{
                e && rt1(this.router, n, t, !0), lt1 || Bt1(n.fullPath);
            });
        }, r = lt1 ? "popstate" : "hashchange";
        window.addEventListener(r, n), this.listeners.push(()=>{
            window.removeEventListener(r, n);
        });
    }
    push(t, e, n) {
        const { current: r  } = this;
        this.transitionTo(t, (t)=>{
            Ut1(t.fullPath), rt1(this.router, t, r, !1), e && e(t);
        }, n);
    }
    replace(t, e, n) {
        const { current: r  } = this;
        this.transitionTo(t, (t)=>{
            Bt1(t.fullPath), rt1(this.router, t, r, !1), e && e(t);
        }, n);
    }
    go(t) {
        window.history.go(t);
    }
    ensureURL(t) {
        const e = this.current.fullPath;
        _t1() !== e && (t ? Ut1(e) : Bt1(e));
    }
    getCurrentLocation() {
        return _t1();
    }
}
function Lt2() {
    const t = _t1();
    return "/" === t.charAt(0) || (Bt1("/" + t), !1);
}
function _t1() {
    let t = window.location.href;
    const e = t.indexOf("#");
    return e < 0 ? "" : (t = t.slice(e + 1), t);
}
function qt1(t) {
    const e = window.location.href, n = e.indexOf("#");
    return `${n >= 0 ? e.slice(0, n) : e}#${t}`;
}
function Ut1(t) {
    lt1 ? pt1(qt1(t)) : window.location.hash = t;
}
function Bt1(t) {
    lt1 ? ft1(qt1(t)) : window.location.replace(qt1(t));
}
class It1 extends $t1 {
    constructor(t12, e10){
        super(t12, e10), this.stack = [], this.index = -1;
    }
    push(t, e, n) {
        this.transitionTo(t, (t)=>{
            this.stack = this.stack.slice(0, this.index + 1).concat(t), this.index++, e && e(t);
        }, n);
    }
    replace(t, e, n) {
        this.transitionTo(t, (t)=>{
            this.stack = this.stack.slice(0, this.index).concat(t), e && e(t);
        }, n);
    }
    go(t) {
        const e = this.index + t;
        if (e < 0 || e >= this.stack.length) return;
        const n = this.stack[e];
        this.confirmTransition(n, ()=>{
            const t = this.current;
            this.index = e, this.updateRoute(n), this.router.afterHooks.forEach((e)=>{
                e && e(n, t);
            });
        }, (t)=>{
            xt1(t, yt1.duplicated) && (this.index = e);
        });
    }
    getCurrentLocation() {
        const t = this.stack[this.stack.length - 1];
        return t ? t.fullPath : "/";
    }
    ensureURL() {
    }
}
class Mt1 {
    constructor(t13 = {
    }){
        this.app = null, this.apps = [], this.options = t13, this.beforeHooks = [], this.resolveHooks = [], this.afterHooks = [], this.matcher = Q1(t13.routes || [], this);
        let e11 = t13.mode || "hash";
        switch(this.fallback = "history" === e11 && !lt1 && !1 !== t13.fallback, this.fallback && (e11 = "hash"), D1 || (e11 = "abstract"), this.mode = e11, e11){
            case "history":
                this.history = new jt1(this, t13.base);
                break;
            case "hash":
                this.history = new Pt1(this, t13.base, this.fallback);
                break;
            case "abstract":
                this.history = new It1(this, t13.base);
        }
    }
    match(t, e, n) {
        return this.matcher.match(t, e, n);
    }
    get currentRoute() {
        return this.history && this.history.current;
    }
    init(t) {
        if (this.apps.push(t), t.$once("hook:destroyed", ()=>{
            const e = this.apps.indexOf(t);
            e > -1 && this.apps.splice(e, 1), this.app === t && (this.app = this.apps[0] || null), this.app || this.history.teardown();
        }), this.app) return;
        this.app = t;
        const e = this.history;
        if (e instanceof jt1 || e instanceof Pt1) {
            const t = (t)=>{
                const n = e.current, r = this.options.scrollBehavior;
                lt1 && r && "fullPath" in t && rt1(this, t, n, !1);
            }, n = (n)=>{
                e.setupListeners(), t(n);
            };
            e.transitionTo(e.getCurrentLocation(), n, n);
        }
        e.listen((t)=>{
            this.apps.forEach((e)=>{
                e._route = t;
            });
        });
    }
    beforeEach(t) {
        return Vt1(this.beforeHooks, t);
    }
    beforeResolve(t) {
        return Vt1(this.resolveHooks, t);
    }
    afterEach(t) {
        return Vt1(this.afterHooks, t);
    }
    onReady(t, e) {
        this.history.onReady(t, e);
    }
    onError(t) {
        this.history.onError(t);
    }
    push(t, e, n) {
        if (!e && !n && "undefined" != typeof Promise) return new Promise((e, n)=>{
            this.history.push(t, e, n);
        });
        this.history.push(t, e, n);
    }
    replace(t, e, n) {
        if (!e && !n && "undefined" != typeof Promise) return new Promise((e, n)=>{
            this.history.replace(t, e, n);
        });
        this.history.replace(t, e, n);
    }
    go(t) {
        this.history.go(t);
    }
    back() {
        this.go(-1);
    }
    forward() {
        this.go(1);
    }
    getMatchedComponents(t) {
        const e = t ? t.matched ? t : this.resolve(t).route : this.currentRoute;
        return e ? [].concat.apply([], e.matched.map((t)=>Object.keys(t.components).map((e)=>t.components[e]
            )
        )) : [];
    }
    resolve(t, e, n) {
        const r = V1(t, e = e || this.history.current, n, this), o = this.match(r, e), i = o.redirectedFrom || o.fullPath;
        return {
            location: r,
            route: o,
            href: (function(t, e, n) {
                var r = "hash" === n ? "#" + e : e;
                return t ? x1(t + "/" + r) : r;
            })(this.history.base, i, this.mode),
            normalizedTo: r,
            resolved: o
        };
    }
    getRoutes() {
        return this.matcher.getRoutes();
    }
    addRoute(t, e) {
        this.matcher.addRoute(t, e), this.history.current !== p1 && this.history.transitionTo(this.history.getCurrentLocation());
    }
    addRoutes(t) {
        this.matcher.addRoutes(t), this.history.current !== p1 && this.history.transitionTo(this.history.getCurrentLocation());
    }
}
function Vt1(t, e) {
    return t.push(e), ()=>{
        const n = t.indexOf(e);
        n > -1 && t.splice(n, 1);
    };
}
Mt1.install = function t(e) {
    if (t.installed && z1 === e) return;
    t.installed = !0, z1 = e;
    const n = (t)=>void 0 !== t
    , r = (t, e)=>{
        let r = t.$options._parentVnode;
        n(r) && n(r = r.data) && n(r = r.registerRouteInstance) && r(t, e);
    };
    e.mixin({
        beforeCreate () {
            n(this.$options.router) ? (this._routerRoot = this, this._router = this.$options.router, this._router.init(this), e.util.defineReactive(this, "_route", this._router.history.current)) : this._routerRoot = this.$parent && this.$parent._routerRoot || this, r(this, this);
        },
        destroyed () {
            r(this);
        }
    }), Object.defineProperty(e.prototype, "$router", {
        get () {
            return this._routerRoot._router;
        }
    }), Object.defineProperty(e.prototype, "$route", {
        get () {
            return this._routerRoot._route;
        }
    }), e.component("RouterView", w1), e.component("RouterLink", N1);
    const o = e.config.optionMergeStrategies;
    o.beforeRouteEnter = o.beforeRouteLeave = o.beforeRouteUpdate = o.created;
}, Mt1.version = "3.5.2", Mt1.isNavigationFailure = xt1, Mt1.NavigationFailureType = yt1, Mt1.START_LOCATION = p1, D1 && window.Vue && window.Vue.use(Mt1);
const AboutPage = {
    template: `<div>
        <h1 class="title">About</h1>
        <p>WIP...</p>
    </div>`
};
const HelpPage = (db)=>({
        data () {
            return {
                tables: []
            };
        },
        template: `<div>
    <h1 class="title">Help</h1>

    <h2 class="subtitle">List of all Tables</h2>

    <div v-for="table in tables">
        <h3><code>{{table.name}}</code></h3>
        <table class="table">
            <thead>
                <tr>
                    <th>Column</th>
                    <th>Type</th>
                </tr>
            </thead>
            <tbody>
                <tr v-for="row in table.values">
                    <td>{{row[1]}}</td>
                    <td>{{row[2]}}</td>
                </tr>
            </tbody>
        </table>
    </div>
  </div>`,
        mounted () {
            this.tables = [].concat(this.load("table"), this.load("view"));
        },
        methods: {
            load (tableType) {
                const tableNames = db.exec("SELECT DISTINCT(tbl_name) FROM sqlite_master WHERE type = ?", [
                    tableType
                ]);
                return tableNames[0].values.map(([name])=>{
                    const results = db.exec(`PRAGMA TABLE_INFO(${name})`);
                    return {
                        name: name,
                        ...results[0]
                    };
                });
            }
        }
    })
;
const ErrorPage = {
    props: [
        "message", 
    ],
    template: `<div>
        <h1 class="title">Unexpected Error!</h1>
        <p><code>{{message}}</code></p>
    </div>`
};
(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.CodeMirror = factory());
})(this, function() {
    'use strict';
    var userAgent = navigator.userAgent;
    var platform = navigator.platform;
    var gecko = /gecko\/\d/i.test(userAgent);
    var ie_upto10 = /MSIE \d/.test(userAgent);
    var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
    var edge = /Edge\/(\d+)/.exec(userAgent);
    var ie = ie_upto10 || ie_11up || edge;
    var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
    var webkit = !edge && /WebKit\//.test(userAgent);
    var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
    var chrome = !edge && /Chrome\//.test(userAgent);
    var presto = /Opera\//.test(userAgent);
    var safari = /Apple Computer/.test(navigator.vendor);
    var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
    var phantom = /PhantomJS/.test(userAgent);
    var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
    var android = /Android/.test(userAgent);
    var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
    var mac = ios || /Mac/.test(platform);
    var chromeOS = /\bCrOS\b/.test(userAgent);
    var windows = /win/i.test(platform);
    var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
    if (presto_version) {
        presto_version = Number(presto_version[1]);
    }
    if (presto_version && presto_version >= 15) {
        presto = false;
        webkit = true;
    }
    var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
    var captureRightClick = gecko || ie && ie_version >= 9;
    function classTest(cls) {
        return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
    }
    var rmClass = function(node, cls) {
        var current = node.className;
        var match = classTest(cls).exec(current);
        if (match) {
            var after = current.slice(match.index + match[0].length);
            node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
        }
    };
    function removeChildren(e) {
        for(var count = e.childNodes.length; count > 0; --count){
            e.removeChild(e.firstChild);
        }
        return e;
    }
    function removeChildrenAndAdd(parent, e) {
        return removeChildren(parent).appendChild(e);
    }
    function elt(tag, content, className, style) {
        var e = document.createElement(tag);
        if (className) {
            e.className = className;
        }
        if (style) {
            e.style.cssText = style;
        }
        if (typeof content == "string") {
            e.appendChild(document.createTextNode(content));
        } else if (content) {
            for(var i = 0; i < content.length; ++i){
                e.appendChild(content[i]);
            }
        }
        return e;
    }
    function eltP(tag, content, className, style) {
        var e = elt(tag, content, className, style);
        e.setAttribute("role", "presentation");
        return e;
    }
    var range;
    if (document.createRange) {
        range = function(node, start, end, endNode) {
            var r = document.createRange();
            r.setEnd(endNode || node, end);
            r.setStart(node, start);
            return r;
        };
    } else {
        range = function(node, start, end) {
            var r = document.body.createTextRange();
            try {
                r.moveToElementText(node.parentNode);
            } catch (e) {
                return r;
            }
            r.collapse(true);
            r.moveEnd("character", end);
            r.moveStart("character", start);
            return r;
        };
    }
    function contains(parent, child) {
        if (child.nodeType == 3) {
            child = child.parentNode;
        }
        if (parent.contains) {
            return parent.contains(child);
        }
        do {
            if (child.nodeType == 11) {
                child = child.host;
            }
            if (child == parent) {
                return true;
            }
        }while (child = child.parentNode)
    }
    function activeElt() {
        var activeElement;
        try {
            activeElement = document.activeElement;
        } catch (e) {
            activeElement = document.body || null;
        }
        while(activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement){
            activeElement = activeElement.shadowRoot.activeElement;
        }
        return activeElement;
    }
    function addClass(node, cls) {
        var current = node.className;
        if (!classTest(cls).test(current)) {
            node.className += (current ? " " : "") + cls;
        }
    }
    function joinClasses(a, b) {
        var as = a.split(" ");
        for(var i = 0; i < as.length; i++){
            if (as[i] && !classTest(as[i]).test(b)) {
                b += " " + as[i];
            }
        }
        return b;
    }
    var selectInput = function(node) {
        node.select();
    };
    if (ios) {
        selectInput = function(node) {
            node.selectionStart = 0;
            node.selectionEnd = node.value.length;
        };
    } else if (ie) {
        selectInput = function(node) {
            try {
                node.select();
            } catch (_e) {
            }
        };
    }
    function bind(f) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function() {
            return f.apply(null, args);
        };
    }
    function copyObj(obj, target, overwrite) {
        if (!target) {
            target = {
            };
        }
        for(var prop in obj){
            if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) {
                target[prop] = obj[prop];
            }
        }
        return target;
    }
    function countColumn(string, end, tabSize, startIndex, startValue) {
        if (end == null) {
            end = string.search(/[^\s\u00a0]/);
            if (end == -1) {
                end = string.length;
            }
        }
        for(var i = startIndex || 0, n = startValue || 0;;){
            var nextTab = string.indexOf("\t", i);
            if (nextTab < 0 || nextTab >= end) {
                return n + (end - i);
            }
            n += nextTab - i;
            n += tabSize - n % tabSize;
            i = nextTab + 1;
        }
    }
    var Delayed = function() {
        this.id = null;
        this.f = null;
        this.time = 0;
        this.handler = bind(this.onTimeout, this);
    };
    Delayed.prototype.onTimeout = function(self) {
        self.id = 0;
        if (self.time <= +new Date) {
            self.f();
        } else {
            setTimeout(self.handler, self.time - +new Date);
        }
    };
    Delayed.prototype.set = function(ms, f) {
        this.f = f;
        var time = +new Date + ms;
        if (!this.id || time < this.time) {
            clearTimeout(this.id);
            this.id = setTimeout(this.handler, ms);
            this.time = time;
        }
    };
    function indexOf(array, elt) {
        for(var i = 0; i < array.length; ++i){
            if (array[i] == elt) {
                return i;
            }
        }
        return -1;
    }
    var scrollerGap = 50;
    var Pass = {
        toString: function() {
            return "CodeMirror.Pass";
        }
    };
    var sel_dontScroll = {
        scroll: false
    }, sel_mouse = {
        origin: "*mouse"
    }, sel_move = {
        origin: "+move"
    };
    function findColumn(string, goal, tabSize) {
        for(var pos = 0, col = 0;;){
            var nextTab = string.indexOf("\t", pos);
            if (nextTab == -1) {
                nextTab = string.length;
            }
            var skipped = nextTab - pos;
            if (nextTab == string.length || col + skipped >= goal) {
                return pos + Math.min(skipped, goal - col);
            }
            col += nextTab - pos;
            col += tabSize - col % tabSize;
            pos = nextTab + 1;
            if (col >= goal) {
                return pos;
            }
        }
    }
    var spaceStrs = [
        ""
    ];
    function spaceStr(n) {
        while(spaceStrs.length <= n){
            spaceStrs.push(lst(spaceStrs) + " ");
        }
        return spaceStrs[n];
    }
    function lst(arr) {
        return arr[arr.length - 1];
    }
    function map(array, f) {
        var out = [];
        for(var i = 0; i < array.length; i++){
            out[i] = f(array[i], i);
        }
        return out;
    }
    function insertSorted(array, value, score) {
        var pos = 0, priority = score(value);
        while(pos < array.length && score(array[pos]) <= priority){
            pos++;
        }
        array.splice(pos, 0, value);
    }
    function nothing() {
    }
    function createObj(base, props) {
        var inst;
        if (Object.create) {
            inst = Object.create(base);
        } else {
            nothing.prototype = base;
            inst = new nothing();
        }
        if (props) {
            copyObj(props, inst);
        }
        return inst;
    }
    var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
    function isWordCharBasic(ch) {
        return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
    }
    function isWordChar(ch, helper) {
        if (!helper) {
            return isWordCharBasic(ch);
        }
        if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
            return true;
        }
        return helper.test(ch);
    }
    function isEmpty(obj) {
        for(var n in obj){
            if (obj.hasOwnProperty(n) && obj[n]) {
                return false;
            }
        }
        return true;
    }
    var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
    function isExtendingChar(ch) {
        return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
    }
    function skipExtendingChars(str, pos, dir) {
        while((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))){
            pos += dir;
        }
        return pos;
    }
    function findFirst(pred, from, to) {
        var dir = from > to ? -1 : 1;
        for(;;){
            if (from == to) {
                return from;
            }
            var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
            if (mid == from) {
                return pred(mid) ? from : to;
            }
            if (pred(mid)) {
                to = mid;
            } else {
                from = mid + dir;
            }
        }
    }
    function iterateBidiSections(order, from, to, f) {
        if (!order) {
            return f(from, to, "ltr", 0);
        }
        var found = false;
        for(var i = 0; i < order.length; ++i){
            var part = order[i];
            if (part.from < to && part.to > from || from == to && part.to == from) {
                f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
                found = true;
            }
        }
        if (!found) {
            f(from, to, "ltr");
        }
    }
    var bidiOther = null;
    function getBidiPartAt(order, ch, sticky) {
        var found;
        bidiOther = null;
        for(var i = 0; i < order.length; ++i){
            var cur = order[i];
            if (cur.from < ch && cur.to > ch) {
                return i;
            }
            if (cur.to == ch) {
                if (cur.from != cur.to && sticky == "before") {
                    found = i;
                } else {
                    bidiOther = i;
                }
            }
            if (cur.from == ch) {
                if (cur.from != cur.to && sticky != "before") {
                    found = i;
                } else {
                    bidiOther = i;
                }
            }
        }
        return found != null ? found : bidiOther;
    }
    var bidiOrdering = function() {
        var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
        var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
        function charType(code) {
            if (code <= 247) {
                return lowTypes.charAt(code);
            } else if (1424 <= code && code <= 1524) {
                return "R";
            } else if (1536 <= code && code <= 1785) {
                return arabicTypes.charAt(code - 1536);
            } else if (1774 <= code && code <= 2220) {
                return "r";
            } else if (8192 <= code && code <= 8203) {
                return "w";
            } else if (code == 8204) {
                return "b";
            } else {
                return "L";
            }
        }
        var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
        var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
        function BidiSpan(level, from, to) {
            this.level = level;
            this.from = from;
            this.to = to;
        }
        return function(str, direction) {
            var outerType = direction == "ltr" ? "L" : "R";
            if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
                return false;
            }
            var len = str.length, types = [];
            for(var i = 0; i < len; ++i){
                types.push(charType(str.charCodeAt(i)));
            }
            for(var i$1 = 0, prev = outerType; i$1 < len; ++i$1){
                var type = types[i$1];
                if (type == "m") {
                    types[i$1] = prev;
                } else {
                    prev = type;
                }
            }
            for(var i$2 = 0, cur = outerType; i$2 < len; ++i$2){
                var type$1 = types[i$2];
                if (type$1 == "1" && cur == "r") {
                    types[i$2] = "n";
                } else if (isStrong.test(type$1)) {
                    cur = type$1;
                    if (type$1 == "r") {
                        types[i$2] = "R";
                    }
                }
            }
            for(var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3){
                var type$2 = types[i$3];
                if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
                    types[i$3] = "1";
                } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
                    types[i$3] = prev$1;
                }
                prev$1 = type$2;
            }
            for(var i$4 = 0; i$4 < len; ++i$4){
                var type$3 = types[i$4];
                if (type$3 == ",") {
                    types[i$4] = "N";
                } else if (type$3 == "%") {
                    var end = void 0;
                    for(end = i$4 + 1; end < len && types[end] == "%"; ++end){
                    }
                    var replace = i$4 && types[i$4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";
                    for(var j = i$4; j < end; ++j){
                        types[j] = replace;
                    }
                    i$4 = end - 1;
                }
            }
            for(var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5){
                var type$4 = types[i$5];
                if (cur$1 == "L" && type$4 == "1") {
                    types[i$5] = "L";
                } else if (isStrong.test(type$4)) {
                    cur$1 = type$4;
                }
            }
            for(var i$6 = 0; i$6 < len; ++i$6){
                if (isNeutral.test(types[i$6])) {
                    var end$1 = void 0;
                    for(end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1){
                    }
                    var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
                    var after = (end$1 < len ? types[end$1] : outerType) == "L";
                    var replace$1 = before == after ? before ? "L" : "R" : outerType;
                    for(var j$1 = i$6; j$1 < end$1; ++j$1){
                        types[j$1] = replace$1;
                    }
                    i$6 = end$1 - 1;
                }
            }
            var order = [], m;
            for(var i$7 = 0; i$7 < len;){
                if (countsAsLeft.test(types[i$7])) {
                    var start = i$7;
                    for(++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7){
                    }
                    order.push(new BidiSpan(0, start, i$7));
                } else {
                    var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
                    for(++i$7; i$7 < len && types[i$7] != "L"; ++i$7){
                    }
                    for(var j$2 = pos; j$2 < i$7;){
                        if (countsAsNum.test(types[j$2])) {
                            if (pos < j$2) {
                                order.splice(at, 0, new BidiSpan(1, pos, j$2));
                                at += isRTL;
                            }
                            var nstart = j$2;
                            for(++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2){
                            }
                            order.splice(at, 0, new BidiSpan(2, nstart, j$2));
                            at += isRTL;
                            pos = j$2;
                        } else {
                            ++j$2;
                        }
                    }
                    if (pos < i$7) {
                        order.splice(at, 0, new BidiSpan(1, pos, i$7));
                    }
                }
            }
            if (direction == "ltr") {
                if (order[0].level == 1 && (m = str.match(/^\s+/))) {
                    order[0].from = m[0].length;
                    order.unshift(new BidiSpan(0, 0, m[0].length));
                }
                if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
                    lst(order).to -= m[0].length;
                    order.push(new BidiSpan(0, len - m[0].length, len));
                }
            }
            return direction == "rtl" ? order.reverse() : order;
        };
    }();
    function getOrder(line, direction) {
        var order = line.order;
        if (order == null) {
            order = line.order = bidiOrdering(line.text, direction);
        }
        return order;
    }
    var noHandlers = [];
    var on = function(emitter, type, f) {
        if (emitter.addEventListener) {
            emitter.addEventListener(type, f, false);
        } else if (emitter.attachEvent) {
            emitter.attachEvent("on" + type, f);
        } else {
            var map = emitter._handlers || (emitter._handlers = {
            });
            map[type] = (map[type] || noHandlers).concat(f);
        }
    };
    function getHandlers(emitter, type) {
        return emitter._handlers && emitter._handlers[type] || noHandlers;
    }
    function off(emitter, type, f) {
        if (emitter.removeEventListener) {
            emitter.removeEventListener(type, f, false);
        } else if (emitter.detachEvent) {
            emitter.detachEvent("on" + type, f);
        } else {
            var map = emitter._handlers, arr = map && map[type];
            if (arr) {
                var index = indexOf(arr, f);
                if (index > -1) {
                    map[type] = arr.slice(0, index).concat(arr.slice(index + 1));
                }
            }
        }
    }
    function signal(emitter, type) {
        var handlers = getHandlers(emitter, type);
        if (!handlers.length) {
            return;
        }
        var args = Array.prototype.slice.call(arguments, 2);
        for(var i = 0; i < handlers.length; ++i){
            handlers[i].apply(null, args);
        }
    }
    function signalDOMEvent(cm, e, override) {
        if (typeof e == "string") {
            e = {
                type: e,
                preventDefault: function() {
                    this.defaultPrevented = true;
                }
            };
        }
        signal(cm, override || e.type, cm, e);
        return e_defaultPrevented(e) || e.codemirrorIgnore;
    }
    function signalCursorActivity(cm) {
        var arr = cm._handlers && cm._handlers.cursorActivity;
        if (!arr) {
            return;
        }
        var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
        for(var i = 0; i < arr.length; ++i){
            if (indexOf(set, arr[i]) == -1) {
                set.push(arr[i]);
            }
        }
    }
    function hasHandler(emitter, type) {
        return getHandlers(emitter, type).length > 0;
    }
    function eventMixin(ctor) {
        ctor.prototype.on = function(type, f) {
            on(this, type, f);
        };
        ctor.prototype.off = function(type, f) {
            off(this, type, f);
        };
    }
    function e_preventDefault(e) {
        if (e.preventDefault) {
            e.preventDefault();
        } else {
            e.returnValue = false;
        }
    }
    function e_stopPropagation(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
        } else {
            e.cancelBubble = true;
        }
    }
    function e_defaultPrevented(e) {
        return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
    }
    function e_stop(e) {
        e_preventDefault(e);
        e_stopPropagation(e);
    }
    function e_target(e) {
        return e.target || e.srcElement;
    }
    function e_button(e) {
        var b = e.which;
        if (b == null) {
            if (e.button & 1) {
                b = 1;
            } else if (e.button & 2) {
                b = 3;
            } else if (e.button & 4) {
                b = 2;
            }
        }
        if (mac && e.ctrlKey && b == 1) {
            b = 3;
        }
        return b;
    }
    var dragAndDrop = function() {
        if (ie && ie_version < 9) {
            return false;
        }
        var div = elt('div');
        return "draggable" in div || "dragDrop" in div;
    }();
    var zwspSupported;
    function zeroWidthElement(measure) {
        if (zwspSupported == null) {
            var test = elt("span", "\u200b");
            removeChildrenAndAdd(measure, elt("span", [
                test,
                document.createTextNode("x")
            ]));
            if (measure.firstChild.offsetHeight != 0) {
                zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
            }
        }
        var node = zwspSupported ? elt("span", "\u200b") : elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
        node.setAttribute("cm-text", "");
        return node;
    }
    var badBidiRects;
    function hasBadBidiRects(measure) {
        if (badBidiRects != null) {
            return badBidiRects;
        }
        var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
        var r0 = range(txt, 0, 1).getBoundingClientRect();
        var r1 = range(txt, 1, 2).getBoundingClientRect();
        removeChildren(measure);
        if (!r0 || r0.left == r0.right) {
            return false;
        }
        return badBidiRects = r1.right - r0.right < 3;
    }
    var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function(string) {
        var pos = 0, result = [], l = string.length;
        while(pos <= l){
            var nl = string.indexOf("\n", pos);
            if (nl == -1) {
                nl = string.length;
            }
            var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
            var rt = line.indexOf("\r");
            if (rt != -1) {
                result.push(line.slice(0, rt));
                pos += rt + 1;
            } else {
                result.push(line);
                pos = nl + 1;
            }
        }
        return result;
    } : function(string) {
        return string.split(/\r\n?|\n/);
    };
    var hasSelection = window.getSelection ? function(te) {
        try {
            return te.selectionStart != te.selectionEnd;
        } catch (e) {
            return false;
        }
    } : function(te) {
        var range;
        try {
            range = te.ownerDocument.selection.createRange();
        } catch (e) {
        }
        if (!range || range.parentElement() != te) {
            return false;
        }
        return range.compareEndPoints("StartToEnd", range) != 0;
    };
    var hasCopyEvent = function() {
        var e = elt("div");
        if ("oncopy" in e) {
            return true;
        }
        e.setAttribute("oncopy", "return;");
        return typeof e.oncopy == "function";
    }();
    var badZoomedRects = null;
    function hasBadZoomedRects(measure) {
        if (badZoomedRects != null) {
            return badZoomedRects;
        }
        var node = removeChildrenAndAdd(measure, elt("span", "x"));
        var normal = node.getBoundingClientRect();
        var fromRange = range(node, 0, 1).getBoundingClientRect();
        return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
    }
    var modes = {
    }, mimeModes = {
    };
    function defineMode(name, mode) {
        if (arguments.length > 2) {
            mode.dependencies = Array.prototype.slice.call(arguments, 2);
        }
        modes[name] = mode;
    }
    function defineMIME(mime, spec) {
        mimeModes[mime] = spec;
    }
    function resolveMode(spec) {
        if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
            spec = mimeModes[spec];
        } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
            var found = mimeModes[spec.name];
            if (typeof found == "string") {
                found = {
                    name: found
                };
            }
            spec = createObj(found, spec);
            spec.name = found.name;
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
            return resolveMode("application/xml");
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
            return resolveMode("application/json");
        }
        if (typeof spec == "string") {
            return {
                name: spec
            };
        } else {
            return spec || {
                name: "null"
            };
        }
    }
    function getMode(options, spec) {
        spec = resolveMode(spec);
        var mfactory = modes[spec.name];
        if (!mfactory) {
            return getMode(options, "text/plain");
        }
        var modeObj = mfactory(options, spec);
        if (modeExtensions.hasOwnProperty(spec.name)) {
            var exts = modeExtensions[spec.name];
            for(var prop in exts){
                if (!exts.hasOwnProperty(prop)) {
                    continue;
                }
                if (modeObj.hasOwnProperty(prop)) {
                    modeObj["_" + prop] = modeObj[prop];
                }
                modeObj[prop] = exts[prop];
            }
        }
        modeObj.name = spec.name;
        if (spec.helperType) {
            modeObj.helperType = spec.helperType;
        }
        if (spec.modeProps) {
            for(var prop$1 in spec.modeProps){
                modeObj[prop$1] = spec.modeProps[prop$1];
            }
        }
        return modeObj;
    }
    var modeExtensions = {
    };
    function extendMode(mode, properties) {
        var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {
        };
        copyObj(properties, exts);
    }
    function copyState(mode, state) {
        if (state === true) {
            return state;
        }
        if (mode.copyState) {
            return mode.copyState(state);
        }
        var nstate = {
        };
        for(var n in state){
            var val = state[n];
            if (val instanceof Array) {
                val = val.concat([]);
            }
            nstate[n] = val;
        }
        return nstate;
    }
    function innerMode(mode, state) {
        var info;
        while(mode.innerMode){
            info = mode.innerMode(state);
            if (!info || info.mode == mode) {
                break;
            }
            state = info.state;
            mode = info.mode;
        }
        return info || {
            mode: mode,
            state: state
        };
    }
    function startState(mode, a1, a2) {
        return mode.startState ? mode.startState(a1, a2) : true;
    }
    var StringStream = function(string, tabSize, lineOracle) {
        this.pos = this.start = 0;
        this.string = string;
        this.tabSize = tabSize || 8;
        this.lastColumnPos = this.lastColumnValue = 0;
        this.lineStart = 0;
        this.lineOracle = lineOracle;
    };
    StringStream.prototype.eol = function() {
        return this.pos >= this.string.length;
    };
    StringStream.prototype.sol = function() {
        return this.pos == this.lineStart;
    };
    StringStream.prototype.peek = function() {
        return this.string.charAt(this.pos) || undefined;
    };
    StringStream.prototype.next = function() {
        if (this.pos < this.string.length) {
            return this.string.charAt(this.pos++);
        }
    };
    StringStream.prototype.eat = function(match) {
        var ch = this.string.charAt(this.pos);
        var ok;
        if (typeof match == "string") {
            ok = ch == match;
        } else {
            ok = ch && (match.test ? match.test(ch) : match(ch));
        }
        if (ok) {
            ++this.pos;
            return ch;
        }
    };
    StringStream.prototype.eatWhile = function(match) {
        var start = this.pos;
        while(this.eat(match)){
        }
        return this.pos > start;
    };
    StringStream.prototype.eatSpace = function() {
        var start = this.pos;
        while(/[\s\u00a0]/.test(this.string.charAt(this.pos))){
            ++this.pos;
        }
        return this.pos > start;
    };
    StringStream.prototype.skipToEnd = function() {
        this.pos = this.string.length;
    };
    StringStream.prototype.skipTo = function(ch) {
        var found = this.string.indexOf(ch, this.pos);
        if (found > -1) {
            this.pos = found;
            return true;
        }
    };
    StringStream.prototype.backUp = function(n) {
        this.pos -= n;
    };
    StringStream.prototype.column = function() {
        if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
        }
        return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    };
    StringStream.prototype.indentation = function() {
        return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    };
    StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
        if (typeof pattern == "string") {
            var cased = function(str) {
                return caseInsensitive ? str.toLowerCase() : str;
            };
            var substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
                if (consume !== false) {
                    this.pos += pattern.length;
                }
                return true;
            }
        } else {
            var match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0) {
                return null;
            }
            if (match && consume !== false) {
                this.pos += match[0].length;
            }
            return match;
        }
    };
    StringStream.prototype.current = function() {
        return this.string.slice(this.start, this.pos);
    };
    StringStream.prototype.hideFirstChars = function(n, inner) {
        this.lineStart += n;
        try {
            return inner();
        } finally{
            this.lineStart -= n;
        }
    };
    StringStream.prototype.lookAhead = function(n) {
        var oracle = this.lineOracle;
        return oracle && oracle.lookAhead(n);
    };
    StringStream.prototype.baseToken = function() {
        var oracle = this.lineOracle;
        return oracle && oracle.baseToken(this.pos);
    };
    function getLine(doc, n) {
        n -= doc.first;
        if (n < 0 || n >= doc.size) {
            throw new Error("There is no line " + (n + doc.first) + " in the document.");
        }
        var chunk = doc;
        while(!chunk.lines){
            for(var i = 0;; ++i){
                var child = chunk.children[i], sz = child.chunkSize();
                if (n < sz) {
                    chunk = child;
                    break;
                }
                n -= sz;
            }
        }
        return chunk.lines[n];
    }
    function getBetween(doc, start, end) {
        var out = [], n = start.line;
        doc.iter(start.line, end.line + 1, function(line) {
            var text = line.text;
            if (n == end.line) {
                text = text.slice(0, end.ch);
            }
            if (n == start.line) {
                text = text.slice(start.ch);
            }
            out.push(text);
            ++n;
        });
        return out;
    }
    function getLines(doc, from, to) {
        var out = [];
        doc.iter(from, to, function(line) {
            out.push(line.text);
        });
        return out;
    }
    function updateLineHeight(line, height) {
        var diff = height - line.height;
        if (diff) {
            for(var n = line; n; n = n.parent){
                n.height += diff;
            }
        }
    }
    function lineNo(line) {
        if (line.parent == null) {
            return null;
        }
        var cur = line.parent, no = indexOf(cur.lines, line);
        for(var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent){
            for(var i = 0;; ++i){
                if (chunk.children[i] == cur) {
                    break;
                }
                no += chunk.children[i].chunkSize();
            }
        }
        return no + cur.first;
    }
    function lineAtHeight(chunk, h) {
        var n = chunk.first;
        outer: do {
            for(var i$1 = 0; i$1 < chunk.children.length; ++i$1){
                var child = chunk.children[i$1], ch = child.height;
                if (h < ch) {
                    chunk = child;
                    continue outer;
                }
                h -= ch;
                n += child.chunkSize();
            }
            return n;
        }while (!chunk.lines)
        var i = 0;
        for(; i < chunk.lines.length; ++i){
            var line = chunk.lines[i], lh = line.height;
            if (h < lh) {
                break;
            }
            h -= lh;
        }
        return n + i;
    }
    function isLine(doc, l) {
        return l >= doc.first && l < doc.first + doc.size;
    }
    function lineNumberFor(options, i) {
        return String(options.lineNumberFormatter(i + options.firstLineNumber));
    }
    function Pos(line, ch, sticky) {
        if (sticky === void 0) sticky = null;
        if (!(this instanceof Pos)) {
            return new Pos(line, ch, sticky);
        }
        this.line = line;
        this.ch = ch;
        this.sticky = sticky;
    }
    function cmp(a, b) {
        return a.line - b.line || a.ch - b.ch;
    }
    function equalCursorPos(a, b) {
        return a.sticky == b.sticky && cmp(a, b) == 0;
    }
    function copyPos(x) {
        return Pos(x.line, x.ch);
    }
    function maxPos(a, b) {
        return cmp(a, b) < 0 ? b : a;
    }
    function minPos(a, b) {
        return cmp(a, b) < 0 ? a : b;
    }
    function clipLine(doc, n) {
        return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
    }
    function clipPos(doc, pos) {
        if (pos.line < doc.first) {
            return Pos(doc.first, 0);
        }
        var last = doc.first + doc.size - 1;
        if (pos.line > last) {
            return Pos(last, getLine(doc, last).text.length);
        }
        return clipToLen(pos, getLine(doc, pos.line).text.length);
    }
    function clipToLen(pos, linelen) {
        var ch = pos.ch;
        if (ch == null || ch > linelen) {
            return Pos(pos.line, linelen);
        } else if (ch < 0) {
            return Pos(pos.line, 0);
        } else {
            return pos;
        }
    }
    function clipPosArray(doc, array) {
        var out = [];
        for(var i = 0; i < array.length; i++){
            out[i] = clipPos(doc, array[i]);
        }
        return out;
    }
    var SavedContext = function(state, lookAhead) {
        this.state = state;
        this.lookAhead = lookAhead;
    };
    var Context = function(doc, state, line, lookAhead) {
        this.state = state;
        this.doc = doc;
        this.line = line;
        this.maxLookAhead = lookAhead || 0;
        this.baseTokens = null;
        this.baseTokenPos = 1;
    };
    Context.prototype.lookAhead = function(n) {
        var line = this.doc.getLine(this.line + n);
        if (line != null && n > this.maxLookAhead) {
            this.maxLookAhead = n;
        }
        return line;
    };
    Context.prototype.baseToken = function(n) {
        if (!this.baseTokens) {
            return null;
        }
        while(this.baseTokens[this.baseTokenPos] <= n){
            this.baseTokenPos += 2;
        }
        var type = this.baseTokens[this.baseTokenPos + 1];
        return {
            type: type && type.replace(/( |^)overlay .*/, ""),
            size: this.baseTokens[this.baseTokenPos] - n
        };
    };
    Context.prototype.nextLine = function() {
        this.line++;
        if (this.maxLookAhead > 0) {
            this.maxLookAhead--;
        }
    };
    Context.fromSaved = function(doc, saved, line) {
        if (saved instanceof SavedContext) {
            return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);
        } else {
            return new Context(doc, copyState(doc.mode, saved), line);
        }
    };
    Context.prototype.save = function(copy) {
        var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
        return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
    };
    function highlightLine(cm, line, context, forceToEnd) {
        var st = [
            cm.state.modeGen
        ], lineClasses = {
        };
        runMode(cm, line.text, cm.doc.mode, context, function(end, style) {
            return st.push(end, style);
        }, lineClasses, forceToEnd);
        var state = context.state;
        var loop = function(o) {
            context.baseTokens = st;
            var overlay = cm.state.overlays[o], i = 1, at = 0;
            context.state = true;
            runMode(cm, line.text, overlay.mode, context, function(end, style) {
                var start = i;
                while(at < end){
                    var i_end = st[i];
                    if (i_end > end) {
                        st.splice(i, 1, end, st[i + 1], i_end);
                    }
                    i += 2;
                    at = Math.min(end, i_end);
                }
                if (!style) {
                    return;
                }
                if (overlay.opaque) {
                    st.splice(start, i - start, end, "overlay " + style);
                    i = start + 2;
                } else {
                    for(; start < i; start += 2){
                        var cur = st[start + 1];
                        st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
                    }
                }
            }, lineClasses);
            context.state = state;
            context.baseTokens = null;
            context.baseTokenPos = 1;
        };
        for(var o = 0; o < cm.state.overlays.length; ++o)loop(o);
        return {
            styles: st,
            classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
        };
    }
    function getLineStyles(cm, line, updateFrontier) {
        if (!line.styles || line.styles[0] != cm.state.modeGen) {
            var context = getContextBefore(cm, lineNo(line));
            var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
            var result = highlightLine(cm, line, context);
            if (resetState) {
                context.state = resetState;
            }
            line.stateAfter = context.save(!resetState);
            line.styles = result.styles;
            if (result.classes) {
                line.styleClasses = result.classes;
            } else if (line.styleClasses) {
                line.styleClasses = null;
            }
            if (updateFrontier === cm.doc.highlightFrontier) {
                cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
            }
        }
        return line.styles;
    }
    function getContextBefore(cm, n, precise) {
        var doc = cm.doc, display = cm.display;
        if (!doc.mode.startState) {
            return new Context(doc, true, n);
        }
        var start = findStartLine(cm, n, precise);
        var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
        var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
        doc.iter(start, n, function(line) {
            processLine(cm, line.text, context);
            var pos = context.line;
            line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
            context.nextLine();
        });
        if (precise) {
            doc.modeFrontier = context.line;
        }
        return context;
    }
    function processLine(cm, text, context, startAt) {
        var mode = cm.doc.mode;
        var stream = new StringStream(text, cm.options.tabSize, context);
        stream.start = stream.pos = startAt || 0;
        if (text == "") {
            callBlankLine(mode, context.state);
        }
        while(!stream.eol()){
            readToken(mode, stream, context.state);
            stream.start = stream.pos;
        }
    }
    function callBlankLine(mode, state) {
        if (mode.blankLine) {
            return mode.blankLine(state);
        }
        if (!mode.innerMode) {
            return;
        }
        var inner = innerMode(mode, state);
        if (inner.mode.blankLine) {
            return inner.mode.blankLine(inner.state);
        }
    }
    function readToken(mode, stream, state, inner) {
        for(var i = 0; i < 10; i++){
            if (inner) {
                inner[0] = innerMode(mode, state).mode;
            }
            var style = mode.token(stream, state);
            if (stream.pos > stream.start) {
                return style;
            }
        }
        throw new Error("Mode " + mode.name + " failed to advance stream.");
    }
    var Token = function(stream, type, state) {
        this.start = stream.start;
        this.end = stream.pos;
        this.string = stream.current();
        this.type = type || null;
        this.state = state;
    };
    function takeToken(cm, pos, precise, asArray) {
        var doc = cm.doc, mode = doc.mode, style;
        pos = clipPos(doc, pos);
        var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
        var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
        if (asArray) {
            tokens = [];
        }
        while((asArray || stream.pos < pos.ch) && !stream.eol()){
            stream.start = stream.pos;
            style = readToken(mode, stream, context.state);
            if (asArray) {
                tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
            }
        }
        return asArray ? tokens : new Token(stream, style, context.state);
    }
    function extractLineClasses(type, output) {
        if (type) {
            for(;;){
                var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
                if (!lineClass) {
                    break;
                }
                type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
                var prop = lineClass[1] ? "bgClass" : "textClass";
                if (output[prop] == null) {
                    output[prop] = lineClass[2];
                } else if (!new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop])) {
                    output[prop] += " " + lineClass[2];
                }
            }
        }
        return type;
    }
    function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
        var flattenSpans = mode.flattenSpans;
        if (flattenSpans == null) {
            flattenSpans = cm.options.flattenSpans;
        }
        var curStart = 0, curStyle = null;
        var stream = new StringStream(text, cm.options.tabSize, context), style;
        var inner = cm.options.addModeClass && [
            null
        ];
        if (text == "") {
            extractLineClasses(callBlankLine(mode, context.state), lineClasses);
        }
        while(!stream.eol()){
            if (stream.pos > cm.options.maxHighlightLength) {
                flattenSpans = false;
                if (forceToEnd) {
                    processLine(cm, text, context, stream.pos);
                }
                stream.pos = text.length;
                style = null;
            } else {
                style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
            }
            if (inner) {
                var mName = inner[0].name;
                if (mName) {
                    style = "m-" + (style ? mName + " " + style : mName);
                }
            }
            if (!flattenSpans || curStyle != style) {
                while(curStart < stream.start){
                    curStart = Math.min(stream.start, curStart + 5000);
                    f(curStart, curStyle);
                }
                curStyle = style;
            }
            stream.start = stream.pos;
        }
        while(curStart < stream.pos){
            var pos = Math.min(stream.pos, curStart + 5000);
            f(pos, curStyle);
            curStart = pos;
        }
    }
    function findStartLine(cm, n, precise) {
        var minindent, minline, doc = cm.doc;
        var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
        for(var search = n; search > lim; --search){
            if (search <= doc.first) {
                return doc.first;
            }
            var line = getLine(doc, search - 1), after = line.stateAfter;
            if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {
                return search;
            }
            var indented = countColumn(line.text, null, cm.options.tabSize);
            if (minline == null || minindent > indented) {
                minline = search - 1;
                minindent = indented;
            }
        }
        return minline;
    }
    function retreatFrontier(doc, n) {
        doc.modeFrontier = Math.min(doc.modeFrontier, n);
        if (doc.highlightFrontier < n - 10) {
            return;
        }
        var start = doc.first;
        for(var line = n - 1; line > start; line--){
            var saved = getLine(doc, line).stateAfter;
            if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
                start = line + 1;
                break;
            }
        }
        doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
    }
    var sawReadOnlySpans = false, sawCollapsedSpans = false;
    function seeReadOnlySpans() {
        sawReadOnlySpans = true;
    }
    function seeCollapsedSpans() {
        sawCollapsedSpans = true;
    }
    function MarkedSpan(marker, from, to) {
        this.marker = marker;
        this.from = from;
        this.to = to;
    }
    function getMarkedSpanFor(spans, marker) {
        if (spans) {
            for(var i = 0; i < spans.length; ++i){
                var span = spans[i];
                if (span.marker == marker) {
                    return span;
                }
            }
        }
    }
    function removeMarkedSpan(spans, span) {
        var r;
        for(var i = 0; i < spans.length; ++i){
            if (spans[i] != span) {
                (r || (r = [])).push(spans[i]);
            }
        }
        return r;
    }
    function addMarkedSpan(line, span, op) {
        var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet));
        if (inThisOp && inThisOp.has(line.markedSpans)) {
            line.markedSpans.push(span);
        } else {
            line.markedSpans = line.markedSpans ? line.markedSpans.concat([
                span
            ]) : [
                span
            ];
            if (inThisOp) {
                inThisOp.add(line.markedSpans);
            }
        }
        span.marker.attachLine(line);
    }
    function markedSpansBefore(old, startCh, isInsert) {
        var nw;
        if (old) {
            for(var i = 0; i < old.length; ++i){
                var span = old[i], marker = span.marker;
                var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
                if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
                    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                    (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
                }
            }
        }
        return nw;
    }
    function markedSpansAfter(old, endCh, isInsert) {
        var nw;
        if (old) {
            for(var i = 0; i < old.length; ++i){
                var span = old[i], marker = span.marker;
                var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
                if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
                    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                    (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
                }
            }
        }
        return nw;
    }
    function stretchSpansOverChange(doc, change) {
        if (change.full) {
            return null;
        }
        var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
        var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
        if (!oldFirst && !oldLast) {
            return null;
        }
        var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
        var first = markedSpansBefore(oldFirst, startCh, isInsert);
        var last = markedSpansAfter(oldLast, endCh, isInsert);
        var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
        if (first) {
            for(var i = 0; i < first.length; ++i){
                var span = first[i];
                if (span.to == null) {
                    var found = getMarkedSpanFor(last, span.marker);
                    if (!found) {
                        span.to = startCh;
                    } else if (sameLine) {
                        span.to = found.to == null ? null : found.to + offset;
                    }
                }
            }
        }
        if (last) {
            for(var i$1 = 0; i$1 < last.length; ++i$1){
                var span$1 = last[i$1];
                if (span$1.to != null) {
                    span$1.to += offset;
                }
                if (span$1.from == null) {
                    var found$1 = getMarkedSpanFor(first, span$1.marker);
                    if (!found$1) {
                        span$1.from = offset;
                        if (sameLine) {
                            (first || (first = [])).push(span$1);
                        }
                    }
                } else {
                    span$1.from += offset;
                    if (sameLine) {
                        (first || (first = [])).push(span$1);
                    }
                }
            }
        }
        if (first) {
            first = clearEmptySpans(first);
        }
        if (last && last != first) {
            last = clearEmptySpans(last);
        }
        var newMarkers = [
            first
        ];
        if (!sameLine) {
            var gap = change.text.length - 2, gapMarkers;
            if (gap > 0 && first) {
                for(var i$2 = 0; i$2 < first.length; ++i$2){
                    if (first[i$2].to == null) {
                        (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));
                    }
                }
            }
            for(var i$3 = 0; i$3 < gap; ++i$3){
                newMarkers.push(gapMarkers);
            }
            newMarkers.push(last);
        }
        return newMarkers;
    }
    function clearEmptySpans(spans) {
        for(var i = 0; i < spans.length; ++i){
            var span = spans[i];
            if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
                spans.splice(i--, 1);
            }
        }
        if (!spans.length) {
            return null;
        }
        return spans;
    }
    function removeReadOnlyRanges(doc, from, to) {
        var markers = null;
        doc.iter(from.line, to.line + 1, function(line) {
            if (line.markedSpans) {
                for(var i = 0; i < line.markedSpans.length; ++i){
                    var mark = line.markedSpans[i].marker;
                    if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
                        (markers || (markers = [])).push(mark);
                    }
                }
            }
        });
        if (!markers) {
            return null;
        }
        var parts = [
            {
                from: from,
                to: to
            }
        ];
        for(var i = 0; i < markers.length; ++i){
            var mk = markers[i], m = mk.find(0);
            for(var j = 0; j < parts.length; ++j){
                var p = parts[j];
                if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
                    continue;
                }
                var newParts = [
                    j,
                    1
                ], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
                if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
                    newParts.push({
                        from: p.from,
                        to: m.from
                    });
                }
                if (dto > 0 || !mk.inclusiveRight && !dto) {
                    newParts.push({
                        from: m.to,
                        to: p.to
                    });
                }
                parts.splice.apply(parts, newParts);
                j += newParts.length - 3;
            }
        }
        return parts;
    }
    function detachMarkedSpans(line) {
        var spans = line.markedSpans;
        if (!spans) {
            return;
        }
        for(var i = 0; i < spans.length; ++i){
            spans[i].marker.detachLine(line);
        }
        line.markedSpans = null;
    }
    function attachMarkedSpans(line, spans) {
        if (!spans) {
            return;
        }
        for(var i = 0; i < spans.length; ++i){
            spans[i].marker.attachLine(line);
        }
        line.markedSpans = spans;
    }
    function extraLeft(marker) {
        return marker.inclusiveLeft ? -1 : 0;
    }
    function extraRight(marker) {
        return marker.inclusiveRight ? 1 : 0;
    }
    function compareCollapsedMarkers(a, b) {
        var lenDiff = a.lines.length - b.lines.length;
        if (lenDiff != 0) {
            return lenDiff;
        }
        var aPos = a.find(), bPos = b.find();
        var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
        if (fromCmp) {
            return -fromCmp;
        }
        var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
        if (toCmp) {
            return toCmp;
        }
        return b.id - a.id;
    }
    function collapsedSpanAtSide(line, start) {
        var sps = sawCollapsedSpans && line.markedSpans, found;
        if (sps) {
            for(var sp = void 0, i = 0; i < sps.length; ++i){
                sp = sps[i];
                if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
                    found = sp.marker;
                }
            }
        }
        return found;
    }
    function collapsedSpanAtStart(line) {
        return collapsedSpanAtSide(line, true);
    }
    function collapsedSpanAtEnd(line) {
        return collapsedSpanAtSide(line, false);
    }
    function collapsedSpanAround(line, ch) {
        var sps = sawCollapsedSpans && line.markedSpans, found;
        if (sps) {
            for(var i = 0; i < sps.length; ++i){
                var sp = sps[i];
                if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
                    found = sp.marker;
                }
            }
        }
        return found;
    }
    function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
        var line = getLine(doc, lineNo);
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps) {
            for(var i = 0; i < sps.length; ++i){
                var sp = sps[i];
                if (!sp.marker.collapsed) {
                    continue;
                }
                var found = sp.marker.find(0);
                var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
                var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
                if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
                    continue;
                }
                if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
                    return true;
                }
            }
        }
    }
    function visualLine(line) {
        var merged;
        while(merged = collapsedSpanAtStart(line)){
            line = merged.find(-1, true).line;
        }
        return line;
    }
    function visualLineEnd(line) {
        var merged;
        while(merged = collapsedSpanAtEnd(line)){
            line = merged.find(1, true).line;
        }
        return line;
    }
    function visualLineContinued(line) {
        var merged, lines;
        while(merged = collapsedSpanAtEnd(line)){
            line = merged.find(1, true).line;
            (lines || (lines = [])).push(line);
        }
        return lines;
    }
    function visualLineNo(doc, lineN) {
        var line = getLine(doc, lineN), vis = visualLine(line);
        if (line == vis) {
            return lineN;
        }
        return lineNo(vis);
    }
    function visualLineEndNo(doc, lineN) {
        if (lineN > doc.lastLine()) {
            return lineN;
        }
        var line = getLine(doc, lineN), merged;
        if (!lineIsHidden(doc, line)) {
            return lineN;
        }
        while(merged = collapsedSpanAtEnd(line)){
            line = merged.find(1, true).line;
        }
        return lineNo(line) + 1;
    }
    function lineIsHidden(doc, line) {
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps) {
            for(var sp = void 0, i = 0; i < sps.length; ++i){
                sp = sps[i];
                if (!sp.marker.collapsed) {
                    continue;
                }
                if (sp.from == null) {
                    return true;
                }
                if (sp.marker.widgetNode) {
                    continue;
                }
                if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {
                    return true;
                }
            }
        }
    }
    function lineIsHiddenInner(doc, line, span) {
        if (span.to == null) {
            var end = span.marker.find(1, true);
            return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
        }
        if (span.marker.inclusiveRight && span.to == line.text.length) {
            return true;
        }
        for(var sp = void 0, i = 0; i < line.markedSpans.length; ++i){
            sp = line.markedSpans[i];
            if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {
                return true;
            }
        }
    }
    function heightAtLine(lineObj) {
        lineObj = visualLine(lineObj);
        var h = 0, chunk = lineObj.parent;
        for(var i = 0; i < chunk.lines.length; ++i){
            var line = chunk.lines[i];
            if (line == lineObj) {
                break;
            } else {
                h += line.height;
            }
        }
        for(var p = chunk.parent; p; chunk = p, p = chunk.parent){
            for(var i$1 = 0; i$1 < p.children.length; ++i$1){
                var cur = p.children[i$1];
                if (cur == chunk) {
                    break;
                } else {
                    h += cur.height;
                }
            }
        }
        return h;
    }
    function lineLength(line) {
        if (line.height == 0) {
            return 0;
        }
        var len = line.text.length, merged, cur = line;
        while(merged = collapsedSpanAtStart(cur)){
            var found = merged.find(0, true);
            cur = found.from.line;
            len += found.from.ch - found.to.ch;
        }
        cur = line;
        while(merged = collapsedSpanAtEnd(cur)){
            var found$1 = merged.find(0, true);
            len -= cur.text.length - found$1.from.ch;
            cur = found$1.to.line;
            len += cur.text.length - found$1.to.ch;
        }
        return len;
    }
    function findMaxLine(cm) {
        var d = cm.display, doc = cm.doc;
        d.maxLine = getLine(doc, doc.first);
        d.maxLineLength = lineLength(d.maxLine);
        d.maxLineChanged = true;
        doc.iter(function(line) {
            var len = lineLength(line);
            if (len > d.maxLineLength) {
                d.maxLineLength = len;
                d.maxLine = line;
            }
        });
    }
    var Line = function(text, markedSpans, estimateHeight) {
        this.text = text;
        attachMarkedSpans(this, markedSpans);
        this.height = estimateHeight ? estimateHeight(this) : 1;
    };
    Line.prototype.lineNo = function() {
        return lineNo(this);
    };
    eventMixin(Line);
    function updateLine(line, text, markedSpans, estimateHeight) {
        line.text = text;
        if (line.stateAfter) {
            line.stateAfter = null;
        }
        if (line.styles) {
            line.styles = null;
        }
        if (line.order != null) {
            line.order = null;
        }
        detachMarkedSpans(line);
        attachMarkedSpans(line, markedSpans);
        var estHeight = estimateHeight ? estimateHeight(line) : 1;
        if (estHeight != line.height) {
            updateLineHeight(line, estHeight);
        }
    }
    function cleanUpLine(line) {
        line.parent = null;
        detachMarkedSpans(line);
    }
    var styleToClassCache = {
    }, styleToClassCacheWithMode = {
    };
    function interpretTokenStyle(style, options) {
        if (!style || /^\s*$/.test(style)) {
            return null;
        }
        var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
        return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
    }
    function buildLineContent(cm, lineView) {
        var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
        var builder = {
            pre: eltP("pre", [
                content
            ], "CodeMirror-line"),
            content: content,
            col: 0,
            pos: 0,
            cm: cm,
            trailingSpace: false,
            splitSpaces: cm.getOption("lineWrapping")
        };
        lineView.measure = {
        };
        for(var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++){
            var line = i ? lineView.rest[i - 1] : lineView.line, order = void 0;
            builder.pos = 0;
            builder.addToken = buildToken;
            if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
                builder.addToken = buildTokenBadBidi(builder.addToken, order);
            }
            builder.map = [];
            var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
            insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
            if (line.styleClasses) {
                if (line.styleClasses.bgClass) {
                    builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
                }
                if (line.styleClasses.textClass) {
                    builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
                }
            }
            if (builder.map.length == 0) {
                builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
            }
            if (i == 0) {
                lineView.measure.map = builder.map;
                lineView.measure.cache = {
                };
            } else {
                (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
                (lineView.measure.caches || (lineView.measure.caches = [])).push({
                });
            }
        }
        if (webkit) {
            var last = builder.content.lastChild;
            if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
                builder.content.className = "cm-tab-wrap-hack";
            }
        }
        signal(cm, "renderLine", cm, lineView.line, builder.pre);
        if (builder.pre.className) {
            builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
        }
        return builder;
    }
    function defaultSpecialCharPlaceholder(ch) {
        var token = elt("span", "\u2022", "cm-invalidchar");
        token.title = "\\u" + ch.charCodeAt(0).toString(16);
        token.setAttribute("aria-label", token.title);
        return token;
    }
    function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
        if (!text) {
            return;
        }
        var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
        var special = builder.cm.state.specialChars, mustWrap = false;
        var content;
        if (!special.test(text)) {
            builder.col += text.length;
            content = document.createTextNode(displayText);
            builder.map.push(builder.pos, builder.pos + text.length, content);
            if (ie && ie_version < 9) {
                mustWrap = true;
            }
            builder.pos += text.length;
        } else {
            content = document.createDocumentFragment();
            var pos = 0;
            while(true){
                special.lastIndex = pos;
                var m = special.exec(text);
                var skipped = m ? m.index - pos : text.length - pos;
                if (skipped) {
                    var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
                    if (ie && ie_version < 9) {
                        content.appendChild(elt("span", [
                            txt
                        ]));
                    } else {
                        content.appendChild(txt);
                    }
                    builder.map.push(builder.pos, builder.pos + skipped, txt);
                    builder.col += skipped;
                    builder.pos += skipped;
                }
                if (!m) {
                    break;
                }
                pos += skipped + 1;
                var txt$1 = void 0;
                if (m[0] == "\t") {
                    var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
                    txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
                    txt$1.setAttribute("role", "presentation");
                    txt$1.setAttribute("cm-text", "\t");
                    builder.col += tabWidth;
                } else if (m[0] == "\r" || m[0] == "\n") {
                    txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
                    txt$1.setAttribute("cm-text", m[0]);
                    builder.col += 1;
                } else {
                    txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
                    txt$1.setAttribute("cm-text", m[0]);
                    if (ie && ie_version < 9) {
                        content.appendChild(elt("span", [
                            txt$1
                        ]));
                    } else {
                        content.appendChild(txt$1);
                    }
                    builder.col += 1;
                }
                builder.map.push(builder.pos, builder.pos + 1, txt$1);
                builder.pos++;
            }
        }
        builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
        if (style || startStyle || endStyle || mustWrap || css || attributes) {
            var fullStyle = style || "";
            if (startStyle) {
                fullStyle += startStyle;
            }
            if (endStyle) {
                fullStyle += endStyle;
            }
            var token = elt("span", [
                content
            ], fullStyle, css);
            if (attributes) {
                for(var attr in attributes){
                    if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
                        token.setAttribute(attr, attributes[attr]);
                    }
                }
            }
            return builder.content.appendChild(token);
        }
        builder.content.appendChild(content);
    }
    function splitSpaces(text, trailingBefore) {
        if (text.length > 1 && !/  /.test(text)) {
            return text;
        }
        var spaceBefore = trailingBefore, result = "";
        for(var i = 0; i < text.length; i++){
            var ch = text.charAt(i);
            if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32)) {
                ch = "\u00a0";
            }
            result += ch;
            spaceBefore = ch == " ";
        }
        return result;
    }
    function buildTokenBadBidi(inner, order) {
        return function(builder, text, style, startStyle, endStyle, css, attributes) {
            style = style ? style + " cm-force-border" : "cm-force-border";
            var start = builder.pos, end = start + text.length;
            for(;;){
                var part = void 0;
                for(var i = 0; i < order.length; i++){
                    part = order[i];
                    if (part.to > start && part.from <= start) {
                        break;
                    }
                }
                if (part.to >= end) {
                    return inner(builder, text, style, startStyle, endStyle, css, attributes);
                }
                inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
                startStyle = null;
                text = text.slice(part.to - start);
                start = part.to;
            }
        };
    }
    function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        var widget = !ignoreWidget && marker.widgetNode;
        if (widget) {
            builder.map.push(builder.pos, builder.pos + size, widget);
        }
        if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
            if (!widget) {
                widget = builder.content.appendChild(document.createElement("span"));
            }
            widget.setAttribute("cm-marker", marker.id);
        }
        if (widget) {
            builder.cm.display.input.setUneditable(widget);
            builder.content.appendChild(widget);
        }
        builder.pos += size;
        builder.trailingSpace = false;
    }
    function insertLineContent(line, builder, styles) {
        var spans = line.markedSpans, allText = line.text, at = 0;
        if (!spans) {
            for(var i$1 = 1; i$1 < styles.length; i$1 += 2){
                builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));
            }
            return;
        }
        var len = allText.length, pos = 0, i = 1, text = "", style, css;
        var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
        for(;;){
            if (nextChange == pos) {
                spanStyle = spanEndStyle = spanStartStyle = css = "";
                attributes = null;
                collapsed = null;
                nextChange = Infinity;
                var foundBookmarks = [], endStyles = void 0;
                for(var j = 0; j < spans.length; ++j){
                    var sp = spans[j], m = sp.marker;
                    if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
                        foundBookmarks.push(m);
                    } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
                        if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                            nextChange = sp.to;
                            spanEndStyle = "";
                        }
                        if (m.className) {
                            spanStyle += " " + m.className;
                        }
                        if (m.css) {
                            css = (css ? css + ";" : "") + m.css;
                        }
                        if (m.startStyle && sp.from == pos) {
                            spanStartStyle += " " + m.startStyle;
                        }
                        if (m.endStyle && sp.to == nextChange) {
                            (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
                        }
                        if (m.title) {
                            (attributes || (attributes = {
                            })).title = m.title;
                        }
                        if (m.attributes) {
                            for(var attr in m.attributes){
                                (attributes || (attributes = {
                                }))[attr] = m.attributes[attr];
                            }
                        }
                        if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
                            collapsed = sp;
                        }
                    } else if (sp.from > pos && nextChange > sp.from) {
                        nextChange = sp.from;
                    }
                }
                if (endStyles) {
                    for(var j$1 = 0; j$1 < endStyles.length; j$1 += 2){
                        if (endStyles[j$1 + 1] == nextChange) {
                            spanEndStyle += " " + endStyles[j$1];
                        }
                    }
                }
                if (!collapsed || collapsed.from == pos) {
                    for(var j$2 = 0; j$2 < foundBookmarks.length; ++j$2){
                        buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
                    }
                }
                if (collapsed && (collapsed.from || 0) == pos) {
                    buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
                    if (collapsed.to == null) {
                        return;
                    }
                    if (collapsed.to == pos) {
                        collapsed = false;
                    }
                }
            }
            if (pos >= len) {
                break;
            }
            var upto = Math.min(len, nextChange);
            while(true){
                if (text) {
                    var end = pos + text.length;
                    if (!collapsed) {
                        var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                        builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
                    }
                    if (end >= upto) {
                        text = text.slice(upto - pos);
                        pos = upto;
                        break;
                    }
                    pos = end;
                    spanStartStyle = "";
                }
                text = allText.slice(at, at = styles[i++]);
                style = interpretTokenStyle(styles[i++], builder.cm.options);
            }
        }
    }
    function LineView(doc, line, lineN) {
        this.line = line;
        this.rest = visualLineContinued(line);
        this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
        this.node = this.text = null;
        this.hidden = lineIsHidden(doc, line);
    }
    function buildViewArray(cm, from, to) {
        var array = [], nextPos;
        for(var pos = from; pos < to; pos = nextPos){
            var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
            nextPos = pos + view.size;
            array.push(view);
        }
        return array;
    }
    var operationGroup = null;
    function pushOperation(op) {
        if (operationGroup) {
            operationGroup.ops.push(op);
        } else {
            op.ownsGroup = operationGroup = {
                ops: [
                    op
                ],
                delayedCallbacks: []
            };
        }
    }
    function fireCallbacksForOps(group) {
        var callbacks = group.delayedCallbacks, i = 0;
        do {
            for(; i < callbacks.length; i++){
                callbacks[i].call(null);
            }
            for(var j = 0; j < group.ops.length; j++){
                var op = group.ops[j];
                if (op.cursorActivityHandlers) {
                    while(op.cursorActivityCalled < op.cursorActivityHandlers.length){
                        op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
                    }
                }
            }
        }while (i < callbacks.length)
    }
    function finishOperation(op, endCb) {
        var group = op.ownsGroup;
        if (!group) {
            return;
        }
        try {
            fireCallbacksForOps(group);
        } finally{
            operationGroup = null;
            endCb(group);
        }
    }
    var orphanDelayedCallbacks = null;
    function signalLater(emitter, type) {
        var arr = getHandlers(emitter, type);
        if (!arr.length) {
            return;
        }
        var args = Array.prototype.slice.call(arguments, 2), list;
        if (operationGroup) {
            list = operationGroup.delayedCallbacks;
        } else if (orphanDelayedCallbacks) {
            list = orphanDelayedCallbacks;
        } else {
            list = orphanDelayedCallbacks = [];
            setTimeout(fireOrphanDelayed, 0);
        }
        var loop = function(i) {
            list.push(function() {
                return arr[i].apply(null, args);
            });
        };
        for(var i = 0; i < arr.length; ++i)loop(i);
    }
    function fireOrphanDelayed() {
        var delayed = orphanDelayedCallbacks;
        orphanDelayedCallbacks = null;
        for(var i = 0; i < delayed.length; ++i){
            delayed[i]();
        }
    }
    function updateLineForChanges(cm, lineView, lineN, dims) {
        for(var j = 0; j < lineView.changes.length; j++){
            var type = lineView.changes[j];
            if (type == "text") {
                updateLineText(cm, lineView);
            } else if (type == "gutter") {
                updateLineGutter(cm, lineView, lineN, dims);
            } else if (type == "class") {
                updateLineClasses(cm, lineView);
            } else if (type == "widget") {
                updateLineWidgets(cm, lineView, dims);
            }
        }
        lineView.changes = null;
    }
    function ensureLineWrapped(lineView) {
        if (lineView.node == lineView.text) {
            lineView.node = elt("div", null, null, "position: relative");
            if (lineView.text.parentNode) {
                lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
            }
            lineView.node.appendChild(lineView.text);
            if (ie && ie_version < 8) {
                lineView.node.style.zIndex = 2;
            }
        }
        return lineView.node;
    }
    function updateLineBackground(cm, lineView) {
        var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
        if (cls) {
            cls += " CodeMirror-linebackground";
        }
        if (lineView.background) {
            if (cls) {
                lineView.background.className = cls;
            } else {
                lineView.background.parentNode.removeChild(lineView.background);
                lineView.background = null;
            }
        } else if (cls) {
            var wrap = ensureLineWrapped(lineView);
            lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
            cm.display.input.setUneditable(lineView.background);
        }
    }
    function getLineContent(cm, lineView) {
        var ext = cm.display.externalMeasured;
        if (ext && ext.line == lineView.line) {
            cm.display.externalMeasured = null;
            lineView.measure = ext.measure;
            return ext.built;
        }
        return buildLineContent(cm, lineView);
    }
    function updateLineText(cm, lineView) {
        var cls = lineView.text.className;
        var built = getLineContent(cm, lineView);
        if (lineView.text == lineView.node) {
            lineView.node = built.pre;
        }
        lineView.text.parentNode.replaceChild(built.pre, lineView.text);
        lineView.text = built.pre;
        if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
            lineView.bgClass = built.bgClass;
            lineView.textClass = built.textClass;
            updateLineClasses(cm, lineView);
        } else if (cls) {
            lineView.text.className = cls;
        }
    }
    function updateLineClasses(cm, lineView) {
        updateLineBackground(cm, lineView);
        if (lineView.line.wrapClass) {
            ensureLineWrapped(lineView).className = lineView.line.wrapClass;
        } else if (lineView.node != lineView.text) {
            lineView.node.className = "";
        }
        var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
        lineView.text.className = textClass || "";
    }
    function updateLineGutter(cm, lineView, lineN, dims) {
        if (lineView.gutter) {
            lineView.node.removeChild(lineView.gutter);
            lineView.gutter = null;
        }
        if (lineView.gutterBackground) {
            lineView.node.removeChild(lineView.gutterBackground);
            lineView.gutterBackground = null;
        }
        if (lineView.line.gutterClass) {
            var wrap = ensureLineWrapped(lineView);
            lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
            cm.display.input.setUneditable(lineView.gutterBackground);
            wrap.insertBefore(lineView.gutterBackground, lineView.text);
        }
        var markers = lineView.line.gutterMarkers;
        if (cm.options.lineNumbers || markers) {
            var wrap$1 = ensureLineWrapped(lineView);
            var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
            gutterWrap.setAttribute("aria-hidden", "true");
            cm.display.input.setUneditable(gutterWrap);
            wrap$1.insertBefore(gutterWrap, lineView.text);
            if (lineView.line.gutterClass) {
                gutterWrap.className += " " + lineView.line.gutterClass;
            }
            if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
                lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
            }
            if (markers) {
                for(var k = 0; k < cm.display.gutterSpecs.length; ++k){
                    var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
                    if (found) {
                        gutterWrap.appendChild(elt("div", [
                            found
                        ], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
                    }
                }
            }
        }
    }
    function updateLineWidgets(cm, lineView, dims) {
        if (lineView.alignable) {
            lineView.alignable = null;
        }
        var isWidget = classTest("CodeMirror-linewidget");
        for(var node = lineView.node.firstChild, next = void 0; node; node = next){
            next = node.nextSibling;
            if (isWidget.test(node.className)) {
                lineView.node.removeChild(node);
            }
        }
        insertLineWidgets(cm, lineView, dims);
    }
    function buildLineElement(cm, lineView, lineN, dims) {
        var built = getLineContent(cm, lineView);
        lineView.text = lineView.node = built.pre;
        if (built.bgClass) {
            lineView.bgClass = built.bgClass;
        }
        if (built.textClass) {
            lineView.textClass = built.textClass;
        }
        updateLineClasses(cm, lineView);
        updateLineGutter(cm, lineView, lineN, dims);
        insertLineWidgets(cm, lineView, dims);
        return lineView.node;
    }
    function insertLineWidgets(cm, lineView, dims) {
        insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
        if (lineView.rest) {
            for(var i = 0; i < lineView.rest.length; i++){
                insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
            }
        }
    }
    function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
        if (!line.widgets) {
            return;
        }
        var wrap = ensureLineWrapped(lineView);
        for(var i = 0, ws = line.widgets; i < ws.length; ++i){
            var widget = ws[i], node = elt("div", [
                widget.node
            ], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
            if (!widget.handleMouseEvents) {
                node.setAttribute("cm-ignore-events", "true");
            }
            positionLineWidget(widget, node, lineView, dims);
            cm.display.input.setUneditable(node);
            if (allowAbove && widget.above) {
                wrap.insertBefore(node, lineView.gutter || lineView.text);
            } else {
                wrap.appendChild(node);
            }
            signalLater(widget, "redraw");
        }
    }
    function positionLineWidget(widget, node, lineView, dims) {
        if (widget.noHScroll) {
            (lineView.alignable || (lineView.alignable = [])).push(node);
            var width = dims.wrapperWidth;
            node.style.left = dims.fixedPos + "px";
            if (!widget.coverGutter) {
                width -= dims.gutterTotalWidth;
                node.style.paddingLeft = dims.gutterTotalWidth + "px";
            }
            node.style.width = width + "px";
        }
        if (widget.coverGutter) {
            node.style.zIndex = 5;
            node.style.position = "relative";
            if (!widget.noHScroll) {
                node.style.marginLeft = -dims.gutterTotalWidth + "px";
            }
        }
    }
    function widgetHeight(widget) {
        if (widget.height != null) {
            return widget.height;
        }
        var cm = widget.doc.cm;
        if (!cm) {
            return 0;
        }
        if (!contains(document.body, widget.node)) {
            var parentStyle = "position: relative;";
            if (widget.coverGutter) {
                parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
            }
            if (widget.noHScroll) {
                parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
            }
            removeChildrenAndAdd(cm.display.measure, elt("div", [
                widget.node
            ], null, parentStyle));
        }
        return widget.height = widget.node.parentNode.offsetHeight;
    }
    function eventInWidget(display, e) {
        for(var n = e_target(e); n != display.wrapper; n = n.parentNode){
            if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
                return true;
            }
        }
    }
    function paddingTop(display) {
        return display.lineSpace.offsetTop;
    }
    function paddingVert(display) {
        return display.mover.offsetHeight - display.lineSpace.offsetHeight;
    }
    function paddingH(display) {
        if (display.cachedPaddingH) {
            return display.cachedPaddingH;
        }
        var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
        var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
        var data = {
            left: parseInt(style.paddingLeft),
            right: parseInt(style.paddingRight)
        };
        if (!isNaN(data.left) && !isNaN(data.right)) {
            display.cachedPaddingH = data;
        }
        return data;
    }
    function scrollGap(cm) {
        return scrollerGap - cm.display.nativeBarWidth;
    }
    function displayWidth(cm) {
        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
    }
    function displayHeight(cm) {
        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
    }
    function ensureLineHeights(cm, lineView, rect) {
        var wrapping = cm.options.lineWrapping;
        var curWidth = wrapping && displayWidth(cm);
        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
            var heights = lineView.measure.heights = [];
            if (wrapping) {
                lineView.measure.width = curWidth;
                var rects = lineView.text.firstChild.getClientRects();
                for(var i = 0; i < rects.length - 1; i++){
                    var cur = rects[i], next = rects[i + 1];
                    if (Math.abs(cur.bottom - next.bottom) > 2) {
                        heights.push((cur.bottom + next.top) / 2 - rect.top);
                    }
                }
            }
            heights.push(rect.bottom - rect.top);
        }
    }
    function mapFromLineView(lineView, line, lineN) {
        if (lineView.line == line) {
            return {
                map: lineView.measure.map,
                cache: lineView.measure.cache
            };
        }
        for(var i = 0; i < lineView.rest.length; i++){
            if (lineView.rest[i] == line) {
                return {
                    map: lineView.measure.maps[i],
                    cache: lineView.measure.caches[i]
                };
            }
        }
        for(var i$1 = 0; i$1 < lineView.rest.length; i$1++){
            if (lineNo(lineView.rest[i$1]) > lineN) {
                return {
                    map: lineView.measure.maps[i$1],
                    cache: lineView.measure.caches[i$1],
                    before: true
                };
            }
        }
    }
    function updateExternalMeasurement(cm, line) {
        line = visualLine(line);
        var lineN = lineNo(line);
        var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
        view.lineN = lineN;
        var built = view.built = buildLineContent(cm, view);
        view.text = built.pre;
        removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
        return view;
    }
    function measureChar(cm, line, ch, bias) {
        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
    }
    function findViewForLine(cm, lineN) {
        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
            return cm.display.view[findViewIndex(cm, lineN)];
        }
        var ext = cm.display.externalMeasured;
        if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
            return ext;
        }
    }
    function prepareMeasureForLine(cm, line) {
        var lineN = lineNo(line);
        var view = findViewForLine(cm, lineN);
        if (view && !view.text) {
            view = null;
        } else if (view && view.changes) {
            updateLineForChanges(cm, view, lineN, getDimensions(cm));
            cm.curOp.forceUpdate = true;
        }
        if (!view) {
            view = updateExternalMeasurement(cm, line);
        }
        var info = mapFromLineView(view, line, lineN);
        return {
            line: line,
            view: view,
            rect: null,
            map: info.map,
            cache: info.cache,
            before: info.before,
            hasHeights: false
        };
    }
    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
        if (prepared.before) {
            ch = -1;
        }
        var key = ch + (bias || ""), found;
        if (prepared.cache.hasOwnProperty(key)) {
            found = prepared.cache[key];
        } else {
            if (!prepared.rect) {
                prepared.rect = prepared.view.text.getBoundingClientRect();
            }
            if (!prepared.hasHeights) {
                ensureLineHeights(cm, prepared.view, prepared.rect);
                prepared.hasHeights = true;
            }
            found = measureCharInner(cm, prepared, ch, bias);
            if (!found.bogus) {
                prepared.cache[key] = found;
            }
        }
        return {
            left: found.left,
            right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom
        };
    }
    var nullRect = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    };
    function nodeAndOffsetInLineMap(map, ch, bias) {
        var node, start, end, collapse, mStart, mEnd;
        for(var i = 0; i < map.length; i += 3){
            mStart = map[i];
            mEnd = map[i + 1];
            if (ch < mStart) {
                start = 0;
                end = 1;
                collapse = "left";
            } else if (ch < mEnd) {
                start = ch - mStart;
                end = start + 1;
            } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
                end = mEnd - mStart;
                start = end - 1;
                if (ch >= mEnd) {
                    collapse = "right";
                }
            }
            if (start != null) {
                node = map[i + 2];
                if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
                    collapse = bias;
                }
                if (bias == "left" && start == 0) {
                    while(i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft){
                        node = map[(i -= 3) + 2];
                        collapse = "left";
                    }
                }
                if (bias == "right" && start == mEnd - mStart) {
                    while(i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft){
                        node = map[(i += 3) + 2];
                        collapse = "right";
                    }
                }
                break;
            }
        }
        return {
            node: node,
            start: start,
            end: end,
            collapse: collapse,
            coverStart: mStart,
            coverEnd: mEnd
        };
    }
    function getUsefulRect(rects, bias) {
        var rect = nullRect;
        if (bias == "left") {
            for(var i = 0; i < rects.length; i++){
                if ((rect = rects[i]).left != rect.right) {
                    break;
                }
            }
        } else {
            for(var i$1 = rects.length - 1; i$1 >= 0; i$1--){
                if ((rect = rects[i$1]).left != rect.right) {
                    break;
                }
            }
        }
        return rect;
    }
    function measureCharInner(cm, prepared, ch, bias) {
        var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
        var node = place.node, start = place.start, end = place.end, collapse = place.collapse;
        var rect;
        if (node.nodeType == 3) {
            for(var i$1 = 0; i$1 < 4; i$1++){
                while(start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))){
                    --start;
                }
                while(place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))){
                    ++end;
                }
                if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
                    rect = node.parentNode.getBoundingClientRect();
                } else {
                    rect = getUsefulRect(range(node, start, end).getClientRects(), bias);
                }
                if (rect.left || rect.right || start == 0) {
                    break;
                }
                end = start;
                start = start - 1;
                collapse = "right";
            }
            if (ie && ie_version < 11) {
                rect = maybeUpdateRectForZooming(cm.display.measure, rect);
            }
        } else {
            if (start > 0) {
                collapse = bias = "right";
            }
            var rects;
            if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
                rect = rects[bias == "right" ? rects.length - 1 : 0];
            } else {
                rect = node.getBoundingClientRect();
            }
        }
        if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
            var rSpan = node.parentNode.getClientRects()[0];
            if (rSpan) {
                rect = {
                    left: rSpan.left,
                    right: rSpan.left + charWidth(cm.display),
                    top: rSpan.top,
                    bottom: rSpan.bottom
                };
            } else {
                rect = nullRect;
            }
        }
        var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
        var mid = (rtop + rbot) / 2;
        var heights = prepared.view.measure.heights;
        var i = 0;
        for(; i < heights.length - 1; i++){
            if (mid < heights[i]) {
                break;
            }
        }
        var top = i ? heights[i - 1] : 0, bot = heights[i];
        var result = {
            left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
            right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
            top: top,
            bottom: bot
        };
        if (!rect.left && !rect.right) {
            result.bogus = true;
        }
        if (!cm.options.singleCursorHeightPerLine) {
            result.rtop = rtop;
            result.rbottom = rbot;
        }
        return result;
    }
    function maybeUpdateRectForZooming(measure, rect) {
        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
            return rect;
        }
        var scaleX = screen.logicalXDPI / screen.deviceXDPI;
        var scaleY = screen.logicalYDPI / screen.deviceYDPI;
        return {
            left: rect.left * scaleX,
            right: rect.right * scaleX,
            top: rect.top * scaleY,
            bottom: rect.bottom * scaleY
        };
    }
    function clearLineMeasurementCacheFor(lineView) {
        if (lineView.measure) {
            lineView.measure.cache = {
            };
            lineView.measure.heights = null;
            if (lineView.rest) {
                for(var i = 0; i < lineView.rest.length; i++){
                    lineView.measure.caches[i] = {
                    };
                }
            }
        }
    }
    function clearLineMeasurementCache(cm) {
        cm.display.externalMeasure = null;
        removeChildren(cm.display.lineMeasure);
        for(var i = 0; i < cm.display.view.length; i++){
            clearLineMeasurementCacheFor(cm.display.view[i]);
        }
    }
    function clearCaches(cm) {
        clearLineMeasurementCache(cm);
        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
        if (!cm.options.lineWrapping) {
            cm.display.maxLineChanged = true;
        }
        cm.display.lineNumChars = null;
    }
    function pageScrollX() {
        if (chrome && android) {
            return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
        }
        return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
    }
    function pageScrollY() {
        if (chrome && android) {
            return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
        }
        return window.pageYOffset || (document.documentElement || document.body).scrollTop;
    }
    function widgetTopHeight(lineObj) {
        var height = 0;
        if (lineObj.widgets) {
            for(var i = 0; i < lineObj.widgets.length; ++i){
                if (lineObj.widgets[i].above) {
                    height += widgetHeight(lineObj.widgets[i]);
                }
            }
        }
        return height;
    }
    function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
        if (!includeWidgets) {
            var height = widgetTopHeight(lineObj);
            rect.top += height;
            rect.bottom += height;
        }
        if (context == "line") {
            return rect;
        }
        if (!context) {
            context = "local";
        }
        var yOff = heightAtLine(lineObj);
        if (context == "local") {
            yOff += paddingTop(cm.display);
        } else {
            yOff -= cm.display.viewOffset;
        }
        if (context == "page" || context == "window") {
            var lOff = cm.display.lineSpace.getBoundingClientRect();
            yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
            var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
            rect.left += xOff;
            rect.right += xOff;
        }
        rect.top += yOff;
        rect.bottom += yOff;
        return rect;
    }
    function fromCoordSystem(cm, coords, context) {
        if (context == "div") {
            return coords;
        }
        var left = coords.left, top = coords.top;
        if (context == "page") {
            left -= pageScrollX();
            top -= pageScrollY();
        } else if (context == "local" || !context) {
            var localBox = cm.display.sizer.getBoundingClientRect();
            left += localBox.left;
            top += localBox.top;
        }
        var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
        return {
            left: left - lineSpaceBox.left,
            top: top - lineSpaceBox.top
        };
    }
    function charCoords(cm, pos, context, lineObj, bias) {
        if (!lineObj) {
            lineObj = getLine(cm.doc, pos.line);
        }
        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
    }
    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
        lineObj = lineObj || getLine(cm.doc, pos.line);
        if (!preparedMeasure) {
            preparedMeasure = prepareMeasureForLine(cm, lineObj);
        }
        function get(ch, right) {
            var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
            if (right) {
                m.left = m.right;
            } else {
                m.right = m.left;
            }
            return intoCoordSystem(cm, lineObj, m, context);
        }
        var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
        if (ch >= lineObj.text.length) {
            ch = lineObj.text.length;
            sticky = "before";
        } else if (ch <= 0) {
            ch = 0;
            sticky = "after";
        }
        if (!order) {
            return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
        }
        function getBidi(ch, partPos, invert) {
            var part = order[partPos], right = part.level == 1;
            return get(invert ? ch - 1 : ch, right != invert);
        }
        var partPos = getBidiPartAt(order, ch, sticky);
        var other = bidiOther;
        var val = getBidi(ch, partPos, sticky == "before");
        if (other != null) {
            val.other = getBidi(ch, other, sticky != "before");
        }
        return val;
    }
    function estimateCoords(cm, pos) {
        var left = 0;
        pos = clipPos(cm.doc, pos);
        if (!cm.options.lineWrapping) {
            left = charWidth(cm.display) * pos.ch;
        }
        var lineObj = getLine(cm.doc, pos.line);
        var top = heightAtLine(lineObj) + paddingTop(cm.display);
        return {
            left: left,
            right: left,
            top: top,
            bottom: top + lineObj.height
        };
    }
    function PosWithInfo(line, ch, sticky, outside, xRel) {
        var pos = Pos(line, ch, sticky);
        pos.xRel = xRel;
        if (outside) {
            pos.outside = outside;
        }
        return pos;
    }
    function coordsChar(cm, x, y) {
        var doc = cm.doc;
        y += cm.display.viewOffset;
        if (y < 0) {
            return PosWithInfo(doc.first, 0, null, -1, -1);
        }
        var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
        if (lineN > last) {
            return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);
        }
        if (x < 0) {
            x = 0;
        }
        var lineObj = getLine(doc, lineN);
        for(;;){
            var found = coordsCharInner(cm, lineObj, lineN, x, y);
            var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
            if (!collapsed) {
                return found;
            }
            var rangeEnd = collapsed.find(1);
            if (rangeEnd.line == lineN) {
                return rangeEnd;
            }
            lineObj = getLine(doc, lineN = rangeEnd.line);
        }
    }
    function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
        y -= widgetTopHeight(lineObj);
        var end = lineObj.text.length;
        var begin = findFirst(function(ch) {
            return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
        }, end, 0);
        end = findFirst(function(ch) {
            return measureCharPrepared(cm, preparedMeasure, ch).top > y;
        }, begin, end);
        return {
            begin: begin,
            end: end
        };
    }
    function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
        if (!preparedMeasure) {
            preparedMeasure = prepareMeasureForLine(cm, lineObj);
        }
        var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
        return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
    }
    function boxIsAfter(box, x, y, left) {
        return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;
    }
    function coordsCharInner(cm, lineObj, lineNo, x, y) {
        y -= heightAtLine(lineObj);
        var preparedMeasure = prepareMeasureForLine(cm, lineObj);
        var widgetHeight = widgetTopHeight(lineObj);
        var begin = 0, end = lineObj.text.length, ltr = true;
        var order = getOrder(lineObj, cm.doc.direction);
        if (order) {
            var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo, preparedMeasure, order, x, y);
            ltr = part.level != 1;
            begin = ltr ? part.from : part.to - 1;
            end = ltr ? part.to : part.from - 1;
        }
        var chAround = null, boxAround = null;
        var ch = findFirst(function(ch) {
            var box = measureCharPrepared(cm, preparedMeasure, ch);
            box.top += widgetHeight;
            box.bottom += widgetHeight;
            if (!boxIsAfter(box, x, y, false)) {
                return false;
            }
            if (box.top <= y && box.left <= x) {
                chAround = ch;
                boxAround = box;
            }
            return true;
        }, begin, end);
        var baseX, sticky, outside = false;
        if (boxAround) {
            var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
            ch = chAround + (atStart ? 0 : 1);
            sticky = atStart ? "after" : "before";
            baseX = atLeft ? boxAround.left : boxAround.right;
        } else {
            if (!ltr && (ch == end || ch == begin)) {
                ch++;
            }
            sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y == ltr ? "after" : "before";
            var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), "line", lineObj, preparedMeasure);
            baseX = coords.left;
            outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
        }
        ch = skipExtendingChars(lineObj.text, ch, 1);
        return PosWithInfo(lineNo, ch, sticky, outside, x - baseX);
    }
    function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {
        var index = findFirst(function(i) {
            var part = order[i], ltr = part.level != 1;
            return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, true);
        }, 0, order.length - 1);
        var part = order[index];
        if (index > 0) {
            var ltr = part.level != 1;
            var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
            if (boxIsAfter(start, x, y, true) && start.top > y) {
                part = order[index - 1];
            }
        }
        return part;
    }
    function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
        var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
        var begin = ref.begin;
        var end = ref.end;
        if (/\s/.test(lineObj.text.charAt(end - 1))) {
            end--;
        }
        var part = null, closestDist = null;
        for(var i = 0; i < order.length; i++){
            var p = order[i];
            if (p.from >= end || p.to <= begin) {
                continue;
            }
            var ltr = p.level != 1;
            var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
            var dist = endX < x ? x - endX + 1000000000 : endX - x;
            if (!part || closestDist > dist) {
                part = p;
                closestDist = dist;
            }
        }
        if (!part) {
            part = order[order.length - 1];
        }
        if (part.from < begin) {
            part = {
                from: begin,
                to: part.to,
                level: part.level
            };
        }
        if (part.to > end) {
            part = {
                from: part.from,
                to: end,
                level: part.level
            };
        }
        return part;
    }
    var measureText;
    function textHeight(display) {
        if (display.cachedTextHeight != null) {
            return display.cachedTextHeight;
        }
        if (measureText == null) {
            measureText = elt("pre", null, "CodeMirror-line-like");
            for(var i = 0; i < 49; ++i){
                measureText.appendChild(document.createTextNode("x"));
                measureText.appendChild(elt("br"));
            }
            measureText.appendChild(document.createTextNode("x"));
        }
        removeChildrenAndAdd(display.measure, measureText);
        var height = measureText.offsetHeight / 50;
        if (height > 3) {
            display.cachedTextHeight = height;
        }
        removeChildren(display.measure);
        return height || 1;
    }
    function charWidth(display) {
        if (display.cachedCharWidth != null) {
            return display.cachedCharWidth;
        }
        var anchor = elt("span", "xxxxxxxxxx");
        var pre = elt("pre", [
            anchor
        ], "CodeMirror-line-like");
        removeChildrenAndAdd(display.measure, pre);
        var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
        if (width > 2) {
            display.cachedCharWidth = width;
        }
        return width || 10;
    }
    function getDimensions(cm) {
        var d = cm.display, left = {
        }, width = {
        };
        var gutterLeft = d.gutters.clientLeft;
        for(var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i){
            var id = cm.display.gutterSpecs[i].className;
            left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
            width[id] = n.clientWidth;
        }
        return {
            fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth
        };
    }
    function compensateForHScroll(display) {
        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
    }
    function estimateHeight(cm) {
        var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
        var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return function(line) {
            if (lineIsHidden(cm.doc, line)) {
                return 0;
            }
            var widgetsHeight = 0;
            if (line.widgets) {
                for(var i = 0; i < line.widgets.length; i++){
                    if (line.widgets[i].height) {
                        widgetsHeight += line.widgets[i].height;
                    }
                }
            }
            if (wrapping) {
                return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
            } else {
                return widgetsHeight + th;
            }
        };
    }
    function estimateLineHeights(cm) {
        var doc = cm.doc, est = estimateHeight(cm);
        doc.iter(function(line) {
            var estHeight = est(line);
            if (estHeight != line.height) {
                updateLineHeight(line, estHeight);
            }
        });
    }
    function posFromMouse(cm, e, liberal, forRect) {
        var display = cm.display;
        if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
            return null;
        }
        var x, y, space = display.lineSpace.getBoundingClientRect();
        try {
            x = e.clientX - space.left;
            y = e.clientY - space.top;
        } catch (e$1) {
            return null;
        }
        var coords = coordsChar(cm, x, y), line;
        if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
            var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
            coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
        }
        return coords;
    }
    function findViewIndex(cm, n) {
        if (n >= cm.display.viewTo) {
            return null;
        }
        n -= cm.display.viewFrom;
        if (n < 0) {
            return null;
        }
        var view = cm.display.view;
        for(var i = 0; i < view.length; i++){
            n -= view[i].size;
            if (n < 0) {
                return i;
            }
        }
    }
    function regChange(cm, from, to, lendiff) {
        if (from == null) {
            from = cm.doc.first;
        }
        if (to == null) {
            to = cm.doc.first + cm.doc.size;
        }
        if (!lendiff) {
            lendiff = 0;
        }
        var display = cm.display;
        if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
            display.updateLineNumbers = from;
        }
        cm.curOp.viewChanged = true;
        if (from >= display.viewTo) {
            if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
                resetView(cm);
            }
        } else if (to <= display.viewFrom) {
            if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
                resetView(cm);
            } else {
                display.viewFrom += lendiff;
                display.viewTo += lendiff;
            }
        } else if (from <= display.viewFrom && to >= display.viewTo) {
            resetView(cm);
        } else if (from <= display.viewFrom) {
            var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
            if (cut) {
                display.view = display.view.slice(cut.index);
                display.viewFrom = cut.lineN;
                display.viewTo += lendiff;
            } else {
                resetView(cm);
            }
        } else if (to >= display.viewTo) {
            var cut$1 = viewCuttingPoint(cm, from, from, -1);
            if (cut$1) {
                display.view = display.view.slice(0, cut$1.index);
                display.viewTo = cut$1.lineN;
            } else {
                resetView(cm);
            }
        } else {
            var cutTop = viewCuttingPoint(cm, from, from, -1);
            var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
            if (cutTop && cutBot) {
                display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
                display.viewTo += lendiff;
            } else {
                resetView(cm);
            }
        }
        var ext = display.externalMeasured;
        if (ext) {
            if (to < ext.lineN) {
                ext.lineN += lendiff;
            } else if (from < ext.lineN + ext.size) {
                display.externalMeasured = null;
            }
        }
    }
    function regLineChange(cm, line, type) {
        cm.curOp.viewChanged = true;
        var display = cm.display, ext = cm.display.externalMeasured;
        if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
            display.externalMeasured = null;
        }
        if (line < display.viewFrom || line >= display.viewTo) {
            return;
        }
        var lineView = display.view[findViewIndex(cm, line)];
        if (lineView.node == null) {
            return;
        }
        var arr = lineView.changes || (lineView.changes = []);
        if (indexOf(arr, type) == -1) {
            arr.push(type);
        }
    }
    function resetView(cm) {
        cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
        cm.display.view = [];
        cm.display.viewOffset = 0;
    }
    function viewCuttingPoint(cm, oldN, newN, dir) {
        var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
        if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
            return {
                index: index,
                lineN: newN
            };
        }
        var n = cm.display.viewFrom;
        for(var i = 0; i < index; i++){
            n += view[i].size;
        }
        if (n != oldN) {
            if (dir > 0) {
                if (index == view.length - 1) {
                    return null;
                }
                diff = n + view[index].size - oldN;
                index++;
            } else {
                diff = n - oldN;
            }
            oldN += diff;
            newN += diff;
        }
        while(visualLineNo(cm.doc, newN) != newN){
            if (index == (dir < 0 ? 0 : view.length - 1)) {
                return null;
            }
            newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
            index += dir;
        }
        return {
            index: index,
            lineN: newN
        };
    }
    function adjustView(cm, from, to) {
        var display = cm.display, view = display.view;
        if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
            display.view = buildViewArray(cm, from, to);
            display.viewFrom = from;
        } else {
            if (display.viewFrom > from) {
                display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
            } else if (display.viewFrom < from) {
                display.view = display.view.slice(findViewIndex(cm, from));
            }
            display.viewFrom = from;
            if (display.viewTo < to) {
                display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
            } else if (display.viewTo > to) {
                display.view = display.view.slice(0, findViewIndex(cm, to));
            }
        }
        display.viewTo = to;
    }
    function countDirtyView(cm) {
        var view = cm.display.view, dirty = 0;
        for(var i = 0; i < view.length; i++){
            var lineView = view[i];
            if (!lineView.hidden && (!lineView.node || lineView.changes)) {
                ++dirty;
            }
        }
        return dirty;
    }
    function updateSelection(cm) {
        cm.display.input.showSelection(cm.display.input.prepareSelection());
    }
    function prepareSelection(cm, primary) {
        if (primary === void 0) primary = true;
        var doc = cm.doc, result = {
        };
        var curFragment = result.cursors = document.createDocumentFragment();
        var selFragment = result.selection = document.createDocumentFragment();
        for(var i = 0; i < doc.sel.ranges.length; i++){
            if (!primary && i == doc.sel.primIndex) {
                continue;
            }
            var range = doc.sel.ranges[i];
            if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) {
                continue;
            }
            var collapsed = range.empty();
            if (collapsed || cm.options.showCursorWhenSelecting) {
                drawSelectionCursor(cm, range.head, curFragment);
            }
            if (!collapsed) {
                drawSelectionRange(cm, range, selFragment);
            }
        }
        return result;
    }
    function drawSelectionCursor(cm, head, output) {
        var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
        var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
        cursor.style.left = pos.left + "px";
        cursor.style.top = pos.top + "px";
        cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
        if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
            var charPos = charCoords(cm, head, "div", null, null);
            cursor.style.width = Math.max(0, charPos.right - charPos.left) + "px";
        }
        if (pos.other) {
            var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
            otherCursor.style.display = "";
            otherCursor.style.left = pos.other.left + "px";
            otherCursor.style.top = pos.other.top + "px";
            otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";
        }
    }
    function cmpCoords(a, b) {
        return a.top - b.top || a.left - b.left;
    }
    function drawSelectionRange(cm, range, output) {
        var display = cm.display, doc = cm.doc;
        var fragment = document.createDocumentFragment();
        var padding = paddingH(cm.display), leftSide = padding.left;
        var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
        var docLTR = doc.direction == "ltr";
        function add(left, top, width, bottom) {
            if (top < 0) {
                top = 0;
            }
            top = Math.round(top);
            bottom = Math.round(bottom);
            fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
        }
        function drawForLine(line, fromArg, toArg) {
            var lineObj = getLine(doc, line);
            var lineLen = lineObj.text.length;
            var start, end;
            function coords(ch, bias) {
                return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
            }
            function wrapX(pos, dir, side) {
                var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
                var prop = dir == "ltr" == (side == "after") ? "left" : "right";
                var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
                return coords(ch, prop)[prop];
            }
            var order = getOrder(lineObj, doc.direction);
            iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir, i) {
                var ltr = dir == "ltr";
                var fromPos = coords(from, ltr ? "left" : "right");
                var toPos = coords(to - 1, ltr ? "right" : "left");
                var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
                var first = i == 0, last = !order || i == order.length - 1;
                if (toPos.top - fromPos.top <= 3) {
                    var openLeft = (docLTR ? openStart : openEnd) && first;
                    var openRight = (docLTR ? openEnd : openStart) && last;
                    var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
                    var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
                    add(left, fromPos.top, right - left, fromPos.bottom);
                } else {
                    var topLeft, topRight, botLeft, botRight;
                    if (ltr) {
                        topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
                        topRight = docLTR ? rightSide : wrapX(from, dir, "before");
                        botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
                        botRight = docLTR && openEnd && last ? rightSide : toPos.right;
                    } else {
                        topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
                        topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
                        botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
                        botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
                    }
                    add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
                    if (fromPos.bottom < toPos.top) {
                        add(leftSide, fromPos.bottom, null, toPos.top);
                    }
                    add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
                }
                if (!start || cmpCoords(fromPos, start) < 0) {
                    start = fromPos;
                }
                if (cmpCoords(toPos, start) < 0) {
                    start = toPos;
                }
                if (!end || cmpCoords(fromPos, end) < 0) {
                    end = fromPos;
                }
                if (cmpCoords(toPos, end) < 0) {
                    end = toPos;
                }
            });
            return {
                start: start,
                end: end
            };
        }
        var sFrom = range.from(), sTo = range.to();
        if (sFrom.line == sTo.line) {
            drawForLine(sFrom.line, sFrom.ch, sTo.ch);
        } else {
            var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
            var singleVLine = visualLine(fromLine) == visualLine(toLine);
            var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
            var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
            if (singleVLine) {
                if (leftEnd.top < rightStart.top - 2) {
                    add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
                    add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
                } else {
                    add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
                }
            }
            if (leftEnd.bottom < rightStart.top) {
                add(leftSide, leftEnd.bottom, null, rightStart.top);
            }
        }
        output.appendChild(fragment);
    }
    function restartBlink(cm) {
        if (!cm.state.focused) {
            return;
        }
        var display = cm.display;
        clearInterval(display.blinker);
        var on = true;
        display.cursorDiv.style.visibility = "";
        if (cm.options.cursorBlinkRate > 0) {
            display.blinker = setInterval(function() {
                if (!cm.hasFocus()) {
                    onBlur(cm);
                }
                display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
            }, cm.options.cursorBlinkRate);
        } else if (cm.options.cursorBlinkRate < 0) {
            display.cursorDiv.style.visibility = "hidden";
        }
    }
    function ensureFocus(cm) {
        if (!cm.hasFocus()) {
            cm.display.input.focus();
            if (!cm.state.focused) {
                onFocus(cm);
            }
        }
    }
    function delayBlurEvent(cm) {
        cm.state.delayingBlurEvent = true;
        setTimeout(function() {
            if (cm.state.delayingBlurEvent) {
                cm.state.delayingBlurEvent = false;
                if (cm.state.focused) {
                    onBlur(cm);
                }
            }
        }, 100);
    }
    function onFocus(cm, e) {
        if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
            cm.state.delayingBlurEvent = false;
        }
        if (cm.options.readOnly == "nocursor") {
            return;
        }
        if (!cm.state.focused) {
            signal(cm, "focus", cm, e);
            cm.state.focused = true;
            addClass(cm.display.wrapper, "CodeMirror-focused");
            if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
                cm.display.input.reset();
                if (webkit) {
                    setTimeout(function() {
                        return cm.display.input.reset(true);
                    }, 20);
                }
            }
            cm.display.input.receivedFocus();
        }
        restartBlink(cm);
    }
    function onBlur(cm, e) {
        if (cm.state.delayingBlurEvent) {
            return;
        }
        if (cm.state.focused) {
            signal(cm, "blur", cm, e);
            cm.state.focused = false;
            rmClass(cm.display.wrapper, "CodeMirror-focused");
        }
        clearInterval(cm.display.blinker);
        setTimeout(function() {
            if (!cm.state.focused) {
                cm.display.shift = false;
            }
        }, 150);
    }
    function updateHeightsInViewport(cm) {
        var display = cm.display;
        var prevBottom = display.lineDiv.offsetTop;
        for(var i = 0; i < display.view.length; i++){
            var cur = display.view[i], wrapping = cm.options.lineWrapping;
            var height = void 0, width = 0;
            if (cur.hidden) {
                continue;
            }
            if (ie && ie_version < 8) {
                var bot = cur.node.offsetTop + cur.node.offsetHeight;
                height = bot - prevBottom;
                prevBottom = bot;
            } else {
                var box = cur.node.getBoundingClientRect();
                height = box.bottom - box.top;
                if (!wrapping && cur.text.firstChild) {
                    width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
                }
            }
            var diff = cur.line.height - height;
            if (diff > 0.005 || diff < -0.005) {
                updateLineHeight(cur.line, height);
                updateWidgetHeight(cur.line);
                if (cur.rest) {
                    for(var j = 0; j < cur.rest.length; j++){
                        updateWidgetHeight(cur.rest[j]);
                    }
                }
            }
            if (width > cm.display.sizerWidth) {
                var chWidth = Math.ceil(width / charWidth(cm.display));
                if (chWidth > cm.display.maxLineLength) {
                    cm.display.maxLineLength = chWidth;
                    cm.display.maxLine = cur.line;
                    cm.display.maxLineChanged = true;
                }
            }
        }
    }
    function updateWidgetHeight(line) {
        if (line.widgets) {
            for(var i = 0; i < line.widgets.length; ++i){
                var w = line.widgets[i], parent = w.node.parentNode;
                if (parent) {
                    w.height = parent.offsetHeight;
                }
            }
        }
    }
    function visibleLines(display, doc, viewport) {
        var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
        top = Math.floor(top - paddingTop(display));
        var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
        var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
        if (viewport && viewport.ensure) {
            var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
            if (ensureFrom < from) {
                from = ensureFrom;
                to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
            } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
                from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
                to = ensureTo;
            }
        }
        return {
            from: from,
            to: Math.max(to, from + 1)
        };
    }
    function maybeScrollWindow(cm, rect) {
        if (signalDOMEvent(cm, "scrollCursorIntoView")) {
            return;
        }
        var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
        if (rect.top + box.top < 0) {
            doScroll = true;
        } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
            doScroll = false;
        }
        if (doScroll != null && !phantom) {
            var scrollNode = elt("div", "\u200b", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
            cm.display.lineSpace.appendChild(scrollNode);
            scrollNode.scrollIntoView(doScroll);
            cm.display.lineSpace.removeChild(scrollNode);
        }
    }
    function scrollPosIntoView(cm, pos, end, margin) {
        if (margin == null) {
            margin = 0;
        }
        var rect;
        if (!cm.options.lineWrapping && pos == end) {
            end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
            pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
        }
        for(var limit = 0; limit < 5; limit++){
            var changed = false;
            var coords = cursorCoords(cm, pos);
            var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
            rect = {
                left: Math.min(coords.left, endCoords.left),
                top: Math.min(coords.top, endCoords.top) - margin,
                right: Math.max(coords.left, endCoords.left),
                bottom: Math.max(coords.bottom, endCoords.bottom) + margin
            };
            var scrollPos = calculateScrollPos(cm, rect);
            var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
            if (scrollPos.scrollTop != null) {
                updateScrollTop(cm, scrollPos.scrollTop);
                if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
                    changed = true;
                }
            }
            if (scrollPos.scrollLeft != null) {
                setScrollLeft(cm, scrollPos.scrollLeft);
                if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
                    changed = true;
                }
            }
            if (!changed) {
                break;
            }
        }
        return rect;
    }
    function scrollIntoView(cm, rect) {
        var scrollPos = calculateScrollPos(cm, rect);
        if (scrollPos.scrollTop != null) {
            updateScrollTop(cm, scrollPos.scrollTop);
        }
        if (scrollPos.scrollLeft != null) {
            setScrollLeft(cm, scrollPos.scrollLeft);
        }
    }
    function calculateScrollPos(cm, rect) {
        var display = cm.display, snapMargin = textHeight(cm.display);
        if (rect.top < 0) {
            rect.top = 0;
        }
        var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
        var screen = displayHeight(cm), result = {
        };
        if (rect.bottom - rect.top > screen) {
            rect.bottom = rect.top + screen;
        }
        var docBottom = cm.doc.height + paddingVert(display);
        var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
        if (rect.top < screentop) {
            result.scrollTop = atTop ? 0 : rect.top;
        } else if (rect.bottom > screentop + screen) {
            var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
            if (newTop != screentop) {
                result.scrollTop = newTop;
            }
        }
        var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
        var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
        var screenw = displayWidth(cm) - display.gutters.offsetWidth;
        var tooWide = rect.right - rect.left > screenw;
        if (tooWide) {
            rect.right = rect.left + screenw;
        }
        if (rect.left < 10) {
            result.scrollLeft = 0;
        } else if (rect.left < screenleft) {
            result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));
        } else if (rect.right > screenw + screenleft - 3) {
            result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
        }
        return result;
    }
    function addToScrollTop(cm, top) {
        if (top == null) {
            return;
        }
        resolveScrollToPos(cm);
        cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
    }
    function ensureCursorVisible(cm) {
        resolveScrollToPos(cm);
        var cur = cm.getCursor();
        cm.curOp.scrollToPos = {
            from: cur,
            to: cur,
            margin: cm.options.cursorScrollMargin
        };
    }
    function scrollToCoords(cm, x, y) {
        if (x != null || y != null) {
            resolveScrollToPos(cm);
        }
        if (x != null) {
            cm.curOp.scrollLeft = x;
        }
        if (y != null) {
            cm.curOp.scrollTop = y;
        }
    }
    function scrollToRange(cm, range) {
        resolveScrollToPos(cm);
        cm.curOp.scrollToPos = range;
    }
    function resolveScrollToPos(cm) {
        var range = cm.curOp.scrollToPos;
        if (range) {
            cm.curOp.scrollToPos = null;
            var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
            scrollToCoordsRange(cm, from, to, range.margin);
        }
    }
    function scrollToCoordsRange(cm, from, to, margin) {
        var sPos = calculateScrollPos(cm, {
            left: Math.min(from.left, to.left),
            top: Math.min(from.top, to.top) - margin,
            right: Math.max(from.right, to.right),
            bottom: Math.max(from.bottom, to.bottom) + margin
        });
        scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
    }
    function updateScrollTop(cm, val) {
        if (Math.abs(cm.doc.scrollTop - val) < 2) {
            return;
        }
        if (!gecko) {
            updateDisplaySimple(cm, {
                top: val
            });
        }
        setScrollTop(cm, val, true);
        if (gecko) {
            updateDisplaySimple(cm);
        }
        startWorker(cm, 100);
    }
    function setScrollTop(cm, val, forceScroll) {
        val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
        if (cm.display.scroller.scrollTop == val && !forceScroll) {
            return;
        }
        cm.doc.scrollTop = val;
        cm.display.scrollbars.setScrollTop(val);
        if (cm.display.scroller.scrollTop != val) {
            cm.display.scroller.scrollTop = val;
        }
    }
    function setScrollLeft(cm, val, isScroller, forceScroll) {
        val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
        if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
            return;
        }
        cm.doc.scrollLeft = val;
        alignHorizontally(cm);
        if (cm.display.scroller.scrollLeft != val) {
            cm.display.scroller.scrollLeft = val;
        }
        cm.display.scrollbars.setScrollLeft(val);
    }
    function measureForScrollbars(cm) {
        var d = cm.display, gutterW = d.gutters.offsetWidth;
        var docH = Math.round(cm.doc.height + paddingVert(cm.display));
        return {
            clientHeight: d.scroller.clientHeight,
            viewHeight: d.wrapper.clientHeight,
            scrollWidth: d.scroller.scrollWidth,
            clientWidth: d.scroller.clientWidth,
            viewWidth: d.wrapper.clientWidth,
            barLeft: cm.options.fixedGutter ? gutterW : 0,
            docHeight: docH,
            scrollHeight: docH + scrollGap(cm) + d.barHeight,
            nativeBarWidth: d.nativeBarWidth,
            gutterWidth: gutterW
        };
    }
    var NativeScrollbars = function(place, scroll, cm) {
        this.cm = cm;
        var vert = this.vert = elt("div", [
            elt("div", null, null, "min-width: 1px")
        ], "CodeMirror-vscrollbar");
        var horiz = this.horiz = elt("div", [
            elt("div", null, null, "height: 100%; min-height: 1px")
        ], "CodeMirror-hscrollbar");
        vert.tabIndex = horiz.tabIndex = -1;
        place(vert);
        place(horiz);
        on(vert, "scroll", function() {
            if (vert.clientHeight) {
                scroll(vert.scrollTop, "vertical");
            }
        });
        on(horiz, "scroll", function() {
            if (horiz.clientWidth) {
                scroll(horiz.scrollLeft, "horizontal");
            }
        });
        this.checkedZeroWidth = false;
        if (ie && ie_version < 8) {
            this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
        }
    };
    NativeScrollbars.prototype.update = function(measure) {
        var needsH = measure.scrollWidth > measure.clientWidth + 1;
        var needsV = measure.scrollHeight > measure.clientHeight + 1;
        var sWidth = measure.nativeBarWidth;
        if (needsV) {
            this.vert.style.display = "block";
            this.vert.style.bottom = needsH ? sWidth + "px" : "0";
            var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
            this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
        } else {
            this.vert.style.display = "";
            this.vert.firstChild.style.height = "0";
        }
        if (needsH) {
            this.horiz.style.display = "block";
            this.horiz.style.right = needsV ? sWidth + "px" : "0";
            this.horiz.style.left = measure.barLeft + "px";
            var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
            this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
        } else {
            this.horiz.style.display = "";
            this.horiz.firstChild.style.width = "0";
        }
        if (!this.checkedZeroWidth && measure.clientHeight > 0) {
            if (sWidth == 0) {
                this.zeroWidthHack();
            }
            this.checkedZeroWidth = true;
        }
        return {
            right: needsV ? sWidth : 0,
            bottom: needsH ? sWidth : 0
        };
    };
    NativeScrollbars.prototype.setScrollLeft = function(pos) {
        if (this.horiz.scrollLeft != pos) {
            this.horiz.scrollLeft = pos;
        }
        if (this.disableHoriz) {
            this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
        }
    };
    NativeScrollbars.prototype.setScrollTop = function(pos) {
        if (this.vert.scrollTop != pos) {
            this.vert.scrollTop = pos;
        }
        if (this.disableVert) {
            this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
        }
    };
    NativeScrollbars.prototype.zeroWidthHack = function() {
        var w = mac && !mac_geMountainLion ? "12px" : "18px";
        this.horiz.style.height = this.vert.style.width = w;
        this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
        this.disableHoriz = new Delayed;
        this.disableVert = new Delayed;
    };
    NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type) {
        bar.style.pointerEvents = "auto";
        function maybeDisable() {
            var box = bar.getBoundingClientRect();
            var elt = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
            if (elt != bar) {
                bar.style.pointerEvents = "none";
            } else {
                delay.set(1000, maybeDisable);
            }
        }
        delay.set(1000, maybeDisable);
    };
    NativeScrollbars.prototype.clear = function() {
        var parent = this.horiz.parentNode;
        parent.removeChild(this.horiz);
        parent.removeChild(this.vert);
    };
    var NullScrollbars = function() {
    };
    NullScrollbars.prototype.update = function() {
        return {
            bottom: 0,
            right: 0
        };
    };
    NullScrollbars.prototype.setScrollLeft = function() {
    };
    NullScrollbars.prototype.setScrollTop = function() {
    };
    NullScrollbars.prototype.clear = function() {
    };
    function updateScrollbars(cm, measure) {
        if (!measure) {
            measure = measureForScrollbars(cm);
        }
        var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
        updateScrollbarsInner(cm, measure);
        for(var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++){
            if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
                updateHeightsInViewport(cm);
            }
            updateScrollbarsInner(cm, measureForScrollbars(cm));
            startWidth = cm.display.barWidth;
            startHeight = cm.display.barHeight;
        }
    }
    function updateScrollbarsInner(cm, measure) {
        var d = cm.display;
        var sizes = d.scrollbars.update(measure);
        d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
        d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
        d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
        if (sizes.right && sizes.bottom) {
            d.scrollbarFiller.style.display = "block";
            d.scrollbarFiller.style.height = sizes.bottom + "px";
            d.scrollbarFiller.style.width = sizes.right + "px";
        } else {
            d.scrollbarFiller.style.display = "";
        }
        if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
            d.gutterFiller.style.display = "block";
            d.gutterFiller.style.height = sizes.bottom + "px";
            d.gutterFiller.style.width = measure.gutterWidth + "px";
        } else {
            d.gutterFiller.style.display = "";
        }
    }
    var scrollbarModel = {
        "native": NativeScrollbars,
        "null": NullScrollbars
    };
    function initScrollbars(cm) {
        if (cm.display.scrollbars) {
            cm.display.scrollbars.clear();
            if (cm.display.scrollbars.addClass) {
                rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
            }
        }
        cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
            cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
            on(node, "mousedown", function() {
                if (cm.state.focused) {
                    setTimeout(function() {
                        return cm.display.input.focus();
                    }, 0);
                }
            });
            node.setAttribute("cm-not-content", "true");
        }, function(pos, axis) {
            if (axis == "horizontal") {
                setScrollLeft(cm, pos);
            } else {
                updateScrollTop(cm, pos);
            }
        }, cm);
        if (cm.display.scrollbars.addClass) {
            addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
        }
    }
    var nextOpId = 0;
    function startOperation(cm) {
        cm.curOp = {
            cm: cm,
            viewChanged: false,
            startHeight: cm.doc.height,
            forceUpdate: false,
            updateInput: 0,
            typing: false,
            changeObjs: null,
            cursorActivityHandlers: null,
            cursorActivityCalled: 0,
            selectionChanged: false,
            updateMaxLine: false,
            scrollLeft: null,
            scrollTop: null,
            scrollToPos: null,
            focus: false,
            id: ++nextOpId,
            markArrays: null
        };
        pushOperation(cm.curOp);
    }
    function endOperation(cm) {
        var op = cm.curOp;
        if (op) {
            finishOperation(op, function(group) {
                for(var i = 0; i < group.ops.length; i++){
                    group.ops[i].cm.curOp = null;
                }
                endOperations(group);
            });
        }
    }
    function endOperations(group) {
        var ops = group.ops;
        for(var i = 0; i < ops.length; i++){
            endOperation_R1(ops[i]);
        }
        for(var i$1 = 0; i$1 < ops.length; i$1++){
            endOperation_W1(ops[i$1]);
        }
        for(var i$2 = 0; i$2 < ops.length; i$2++){
            endOperation_R2(ops[i$2]);
        }
        for(var i$3 = 0; i$3 < ops.length; i$3++){
            endOperation_W2(ops[i$3]);
        }
        for(var i$4 = 0; i$4 < ops.length; i$4++){
            endOperation_finish(ops[i$4]);
        }
    }
    function endOperation_R1(op) {
        var cm = op.cm, display = cm.display;
        maybeClipScrollbars(cm);
        if (op.updateMaxLine) {
            findMaxLine(cm);
        }
        op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
        op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
            top: op.scrollTop,
            ensure: op.scrollToPos
        }, op.forceUpdate);
    }
    function endOperation_W1(op) {
        op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
    }
    function endOperation_R2(op) {
        var cm = op.cm, display = cm.display;
        if (op.updatedDisplay) {
            updateHeightsInViewport(cm);
        }
        op.barMeasure = measureForScrollbars(cm);
        if (display.maxLineChanged && !cm.options.lineWrapping) {
            op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
            cm.display.sizerWidth = op.adjustWidthTo;
            op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
            op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
        }
        if (op.updatedDisplay || op.selectionChanged) {
            op.preparedSelection = display.input.prepareSelection();
        }
    }
    function endOperation_W2(op) {
        var cm = op.cm;
        if (op.adjustWidthTo != null) {
            cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
            if (op.maxScrollLeft < cm.doc.scrollLeft) {
                setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
            }
            cm.display.maxLineChanged = false;
        }
        var takeFocus = op.focus && op.focus == activeElt();
        if (op.preparedSelection) {
            cm.display.input.showSelection(op.preparedSelection, takeFocus);
        }
        if (op.updatedDisplay || op.startHeight != cm.doc.height) {
            updateScrollbars(cm, op.barMeasure);
        }
        if (op.updatedDisplay) {
            setDocumentHeight(cm, op.barMeasure);
        }
        if (op.selectionChanged) {
            restartBlink(cm);
        }
        if (cm.state.focused && op.updateInput) {
            cm.display.input.reset(op.typing);
        }
        if (takeFocus) {
            ensureFocus(op.cm);
        }
    }
    function endOperation_finish(op) {
        var cm = op.cm, display = cm.display, doc = cm.doc;
        if (op.updatedDisplay) {
            postUpdateDisplay(cm, op.update);
        }
        if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
            display.wheelStartX = display.wheelStartY = null;
        }
        if (op.scrollTop != null) {
            setScrollTop(cm, op.scrollTop, op.forceScroll);
        }
        if (op.scrollLeft != null) {
            setScrollLeft(cm, op.scrollLeft, true, true);
        }
        if (op.scrollToPos) {
            var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
            maybeScrollWindow(cm, rect);
        }
        var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
        if (hidden) {
            for(var i = 0; i < hidden.length; ++i){
                if (!hidden[i].lines.length) {
                    signal(hidden[i], "hide");
                }
            }
        }
        if (unhidden) {
            for(var i$1 = 0; i$1 < unhidden.length; ++i$1){
                if (unhidden[i$1].lines.length) {
                    signal(unhidden[i$1], "unhide");
                }
            }
        }
        if (display.wrapper.offsetHeight) {
            doc.scrollTop = cm.display.scroller.scrollTop;
        }
        if (op.changeObjs) {
            signal(cm, "changes", cm, op.changeObjs);
        }
        if (op.update) {
            op.update.finish();
        }
    }
    function runInOp(cm, f) {
        if (cm.curOp) {
            return f();
        }
        startOperation(cm);
        try {
            return f();
        } finally{
            endOperation(cm);
        }
    }
    function operation(cm, f) {
        return function() {
            if (cm.curOp) {
                return f.apply(cm, arguments);
            }
            startOperation(cm);
            try {
                return f.apply(cm, arguments);
            } finally{
                endOperation(cm);
            }
        };
    }
    function methodOp(f) {
        return function() {
            if (this.curOp) {
                return f.apply(this, arguments);
            }
            startOperation(this);
            try {
                return f.apply(this, arguments);
            } finally{
                endOperation(this);
            }
        };
    }
    function docMethodOp(f) {
        return function() {
            var cm = this.cm;
            if (!cm || cm.curOp) {
                return f.apply(this, arguments);
            }
            startOperation(cm);
            try {
                return f.apply(this, arguments);
            } finally{
                endOperation(cm);
            }
        };
    }
    function startWorker(cm, time) {
        if (cm.doc.highlightFrontier < cm.display.viewTo) {
            cm.state.highlight.set(time, bind(highlightWorker, cm));
        }
    }
    function highlightWorker(cm) {
        var doc = cm.doc;
        if (doc.highlightFrontier >= cm.display.viewTo) {
            return;
        }
        var end = +new Date + cm.options.workTime;
        var context = getContextBefore(cm, doc.highlightFrontier);
        var changedLines = [];
        doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
            if (context.line >= cm.display.viewFrom) {
                var oldStyles = line.styles;
                var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
                var highlighted = highlightLine(cm, line, context, true);
                if (resetState) {
                    context.state = resetState;
                }
                line.styles = highlighted.styles;
                var oldCls = line.styleClasses, newCls = highlighted.classes;
                if (newCls) {
                    line.styleClasses = newCls;
                } else if (oldCls) {
                    line.styleClasses = null;
                }
                var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
                for(var i = 0; !ischange && i < oldStyles.length; ++i){
                    ischange = oldStyles[i] != line.styles[i];
                }
                if (ischange) {
                    changedLines.push(context.line);
                }
                line.stateAfter = context.save();
                context.nextLine();
            } else {
                if (line.text.length <= cm.options.maxHighlightLength) {
                    processLine(cm, line.text, context);
                }
                line.stateAfter = context.line % 5 == 0 ? context.save() : null;
                context.nextLine();
            }
            if (+new Date > end) {
                startWorker(cm, cm.options.workDelay);
                return true;
            }
        });
        doc.highlightFrontier = context.line;
        doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
        if (changedLines.length) {
            runInOp(cm, function() {
                for(var i = 0; i < changedLines.length; i++){
                    regLineChange(cm, changedLines[i], "text");
                }
            });
        }
    }
    var DisplayUpdate = function(cm, viewport, force) {
        var display = cm.display;
        this.viewport = viewport;
        this.visible = visibleLines(display, cm.doc, viewport);
        this.editorIsHidden = !display.wrapper.offsetWidth;
        this.wrapperHeight = display.wrapper.clientHeight;
        this.wrapperWidth = display.wrapper.clientWidth;
        this.oldDisplayWidth = displayWidth(cm);
        this.force = force;
        this.dims = getDimensions(cm);
        this.events = [];
    };
    DisplayUpdate.prototype.signal = function(emitter, type) {
        if (hasHandler(emitter, type)) {
            this.events.push(arguments);
        }
    };
    DisplayUpdate.prototype.finish = function() {
        for(var i = 0; i < this.events.length; i++){
            signal.apply(null, this.events[i]);
        }
    };
    function maybeClipScrollbars(cm) {
        var display = cm.display;
        if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
            display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
            display.heightForcer.style.height = scrollGap(cm) + "px";
            display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
            display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
            display.scrollbarsClipped = true;
        }
    }
    function selectionSnapshot(cm) {
        if (cm.hasFocus()) {
            return null;
        }
        var active = activeElt();
        if (!active || !contains(cm.display.lineDiv, active)) {
            return null;
        }
        var result = {
            activeElt: active
        };
        if (window.getSelection) {
            var sel = window.getSelection();
            if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
                result.anchorNode = sel.anchorNode;
                result.anchorOffset = sel.anchorOffset;
                result.focusNode = sel.focusNode;
                result.focusOffset = sel.focusOffset;
            }
        }
        return result;
    }
    function restoreSelection(snapshot) {
        if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {
            return;
        }
        snapshot.activeElt.focus();
        if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
            var sel = window.getSelection(), range = document.createRange();
            range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
            range.collapse(false);
            sel.removeAllRanges();
            sel.addRange(range);
            sel.extend(snapshot.focusNode, snapshot.focusOffset);
        }
    }
    function updateDisplayIfNeeded(cm, update) {
        var display = cm.display, doc = cm.doc;
        if (update.editorIsHidden) {
            resetView(cm);
            return false;
        }
        if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
            return false;
        }
        if (maybeUpdateLineNumberWidth(cm)) {
            resetView(cm);
            update.dims = getDimensions(cm);
        }
        var end = doc.first + doc.size;
        var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
        var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
        if (display.viewFrom < from && from - display.viewFrom < 20) {
            from = Math.max(doc.first, display.viewFrom);
        }
        if (display.viewTo > to && display.viewTo - to < 20) {
            to = Math.min(end, display.viewTo);
        }
        if (sawCollapsedSpans) {
            from = visualLineNo(cm.doc, from);
            to = visualLineEndNo(cm.doc, to);
        }
        var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
        adjustView(cm, from, to);
        display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
        cm.display.mover.style.top = display.viewOffset + "px";
        var toUpdate = countDirtyView(cm);
        if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
            return false;
        }
        var selSnapshot = selectionSnapshot(cm);
        if (toUpdate > 4) {
            display.lineDiv.style.display = "none";
        }
        patchDisplay(cm, display.updateLineNumbers, update.dims);
        if (toUpdate > 4) {
            display.lineDiv.style.display = "";
        }
        display.renderedView = display.view;
        restoreSelection(selSnapshot);
        removeChildren(display.cursorDiv);
        removeChildren(display.selectionDiv);
        display.gutters.style.height = display.sizer.style.minHeight = 0;
        if (different) {
            display.lastWrapHeight = update.wrapperHeight;
            display.lastWrapWidth = update.wrapperWidth;
            startWorker(cm, 400);
        }
        display.updateLineNumbers = null;
        return true;
    }
    function postUpdateDisplay(cm, update) {
        var viewport = update.viewport;
        for(var first = true;; first = false){
            if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
                if (viewport && viewport.top != null) {
                    viewport = {
                        top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)
                    };
                }
                update.visible = visibleLines(cm.display, cm.doc, viewport);
                if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
                    break;
                }
            } else if (first) {
                update.visible = visibleLines(cm.display, cm.doc, viewport);
            }
            if (!updateDisplayIfNeeded(cm, update)) {
                break;
            }
            updateHeightsInViewport(cm);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm);
            updateScrollbars(cm, barMeasure);
            setDocumentHeight(cm, barMeasure);
            update.force = false;
        }
        update.signal(cm, "update", cm);
        if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
            update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
            cm.display.reportedViewFrom = cm.display.viewFrom;
            cm.display.reportedViewTo = cm.display.viewTo;
        }
    }
    function updateDisplaySimple(cm, viewport) {
        var update = new DisplayUpdate(cm, viewport);
        if (updateDisplayIfNeeded(cm, update)) {
            updateHeightsInViewport(cm);
            postUpdateDisplay(cm, update);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm);
            updateScrollbars(cm, barMeasure);
            setDocumentHeight(cm, barMeasure);
            update.finish();
        }
    }
    function patchDisplay(cm, updateNumbersFrom, dims) {
        var display = cm.display, lineNumbers = cm.options.lineNumbers;
        var container = display.lineDiv, cur = container.firstChild;
        function rm(node) {
            var next = node.nextSibling;
            if (webkit && mac && cm.display.currentWheelTarget == node) {
                node.style.display = "none";
            } else {
                node.parentNode.removeChild(node);
            }
            return next;
        }
        var view = display.view, lineN = display.viewFrom;
        for(var i = 0; i < view.length; i++){
            var lineView = view[i];
            if (lineView.hidden) ;
            else if (!lineView.node || lineView.node.parentNode != container) {
                var node = buildLineElement(cm, lineView, lineN, dims);
                container.insertBefore(node, cur);
            } else {
                while(cur != lineView.node){
                    cur = rm(cur);
                }
                var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
                if (lineView.changes) {
                    if (indexOf(lineView.changes, "gutter") > -1) {
                        updateNumber = false;
                    }
                    updateLineForChanges(cm, lineView, lineN, dims);
                }
                if (updateNumber) {
                    removeChildren(lineView.lineNumber);
                    lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
                }
                cur = lineView.node.nextSibling;
            }
            lineN += lineView.size;
        }
        while(cur){
            cur = rm(cur);
        }
    }
    function updateGutterSpace(display) {
        var width = display.gutters.offsetWidth;
        display.sizer.style.marginLeft = width + "px";
        signalLater(display, "gutterChanged", display);
    }
    function setDocumentHeight(cm, measure) {
        cm.display.sizer.style.minHeight = measure.docHeight + "px";
        cm.display.heightForcer.style.top = measure.docHeight + "px";
        cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
    }
    function alignHorizontally(cm) {
        var display = cm.display, view = display.view;
        if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
            return;
        }
        var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
        var gutterW = display.gutters.offsetWidth, left = comp + "px";
        for(var i = 0; i < view.length; i++){
            if (!view[i].hidden) {
                if (cm.options.fixedGutter) {
                    if (view[i].gutter) {
                        view[i].gutter.style.left = left;
                    }
                    if (view[i].gutterBackground) {
                        view[i].gutterBackground.style.left = left;
                    }
                }
                var align = view[i].alignable;
                if (align) {
                    for(var j = 0; j < align.length; j++){
                        align[j].style.left = left;
                    }
                }
            }
        }
        if (cm.options.fixedGutter) {
            display.gutters.style.left = comp + gutterW + "px";
        }
    }
    function maybeUpdateLineNumberWidth(cm) {
        if (!cm.options.lineNumbers) {
            return false;
        }
        var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
        if (last.length != display.lineNumChars) {
            var test = display.measure.appendChild(elt("div", [
                elt("div", last)
            ], "CodeMirror-linenumber CodeMirror-gutter-elt"));
            var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
            display.lineGutter.style.width = "";
            display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
            display.lineNumWidth = display.lineNumInnerWidth + padding;
            display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
            display.lineGutter.style.width = display.lineNumWidth + "px";
            updateGutterSpace(cm.display);
            return true;
        }
        return false;
    }
    function getGutters(gutters, lineNumbers) {
        var result = [], sawLineNumbers = false;
        for(var i = 0; i < gutters.length; i++){
            var name = gutters[i], style = null;
            if (typeof name != "string") {
                style = name.style;
                name = name.className;
            }
            if (name == "CodeMirror-linenumbers") {
                if (!lineNumbers) {
                    continue;
                } else {
                    sawLineNumbers = true;
                }
            }
            result.push({
                className: name,
                style: style
            });
        }
        if (lineNumbers && !sawLineNumbers) {
            result.push({
                className: "CodeMirror-linenumbers",
                style: null
            });
        }
        return result;
    }
    function renderGutters(display) {
        var gutters = display.gutters, specs = display.gutterSpecs;
        removeChildren(gutters);
        display.lineGutter = null;
        for(var i = 0; i < specs.length; ++i){
            var ref = specs[i];
            var className = ref.className;
            var style = ref.style;
            var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
            if (style) {
                gElt.style.cssText = style;
            }
            if (className == "CodeMirror-linenumbers") {
                display.lineGutter = gElt;
                gElt.style.width = (display.lineNumWidth || 1) + "px";
            }
        }
        gutters.style.display = specs.length ? "" : "none";
        updateGutterSpace(display);
    }
    function updateGutters(cm) {
        renderGutters(cm.display);
        regChange(cm);
        alignHorizontally(cm);
    }
    function Display(place, doc, input, options) {
        var d = this;
        this.input = input;
        d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
        d.scrollbarFiller.setAttribute("cm-not-content", "true");
        d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
        d.gutterFiller.setAttribute("cm-not-content", "true");
        d.lineDiv = eltP("div", null, "CodeMirror-code");
        d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
        d.cursorDiv = elt("div", null, "CodeMirror-cursors");
        d.measure = elt("div", null, "CodeMirror-measure");
        d.lineMeasure = elt("div", null, "CodeMirror-measure");
        d.lineSpace = eltP("div", [
            d.measure,
            d.lineMeasure,
            d.selectionDiv,
            d.cursorDiv,
            d.lineDiv
        ], null, "position: relative; outline: none");
        var lines = eltP("div", [
            d.lineSpace
        ], "CodeMirror-lines");
        d.mover = elt("div", [
            lines
        ], null, "position: relative");
        d.sizer = elt("div", [
            d.mover
        ], "CodeMirror-sizer");
        d.sizerWidth = null;
        d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
        d.gutters = elt("div", null, "CodeMirror-gutters");
        d.lineGutter = null;
        d.scroller = elt("div", [
            d.sizer,
            d.heightForcer,
            d.gutters
        ], "CodeMirror-scroll");
        d.scroller.setAttribute("tabIndex", "-1");
        d.wrapper = elt("div", [
            d.scrollbarFiller,
            d.gutterFiller,
            d.scroller
        ], "CodeMirror");
        d.wrapper.setAttribute('translate', 'no');
        if (ie && ie_version < 8) {
            d.gutters.style.zIndex = -1;
            d.scroller.style.paddingRight = 0;
        }
        if (!webkit && !(gecko && mobile)) {
            d.scroller.draggable = true;
        }
        if (place) {
            if (place.appendChild) {
                place.appendChild(d.wrapper);
            } else {
                place(d.wrapper);
            }
        }
        d.viewFrom = d.viewTo = doc.first;
        d.reportedViewFrom = d.reportedViewTo = doc.first;
        d.view = [];
        d.renderedView = null;
        d.externalMeasured = null;
        d.viewOffset = 0;
        d.lastWrapHeight = d.lastWrapWidth = 0;
        d.updateLineNumbers = null;
        d.nativeBarWidth = d.barHeight = d.barWidth = 0;
        d.scrollbarsClipped = false;
        d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
        d.alignWidgets = false;
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.maxLine = null;
        d.maxLineLength = 0;
        d.maxLineChanged = false;
        d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
        d.shift = false;
        d.selForContextMenu = null;
        d.activeTouch = null;
        d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
        renderGutters(d);
        input.init(d);
    }
    var wheelSamples = 0, wheelPixelsPerUnit = null;
    if (ie) {
        wheelPixelsPerUnit = -0.53;
    } else if (gecko) {
        wheelPixelsPerUnit = 15;
    } else if (chrome) {
        wheelPixelsPerUnit = -0.7;
    } else if (safari) {
        wheelPixelsPerUnit = -1 / 3;
    }
    function wheelEventDelta(e) {
        var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
        if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
            dx = e.detail;
        }
        if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
            dy = e.detail;
        } else if (dy == null) {
            dy = e.wheelDelta;
        }
        return {
            x: dx,
            y: dy
        };
    }
    function wheelEventPixels(e) {
        var delta = wheelEventDelta(e);
        delta.x *= wheelPixelsPerUnit;
        delta.y *= wheelPixelsPerUnit;
        return delta;
    }
    function onScrollWheel(cm, e) {
        var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
        var display = cm.display, scroll = display.scroller;
        var canScrollX = scroll.scrollWidth > scroll.clientWidth;
        var canScrollY = scroll.scrollHeight > scroll.clientHeight;
        if (!(dx && canScrollX || dy && canScrollY)) {
            return;
        }
        if (dy && mac && webkit) {
            outer: for(var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode){
                for(var i = 0; i < view.length; i++){
                    if (view[i].node == cur) {
                        cm.display.currentWheelTarget = cur;
                        break outer;
                    }
                }
            }
        }
        if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
            if (dy && canScrollY) {
                updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit));
            }
            setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
            if (!dy || dy && canScrollY) {
                e_preventDefault(e);
            }
            display.wheelStartX = null;
            return;
        }
        if (dy && wheelPixelsPerUnit != null) {
            var pixels = dy * wheelPixelsPerUnit;
            var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
            if (pixels < 0) {
                top = Math.max(0, top + pixels - 50);
            } else {
                bot = Math.min(cm.doc.height, bot + pixels + 50);
            }
            updateDisplaySimple(cm, {
                top: top,
                bottom: bot
            });
        }
        if (wheelSamples < 20) {
            if (display.wheelStartX == null) {
                display.wheelStartX = scroll.scrollLeft;
                display.wheelStartY = scroll.scrollTop;
                display.wheelDX = dx;
                display.wheelDY = dy;
                setTimeout(function() {
                    if (display.wheelStartX == null) {
                        return;
                    }
                    var movedX = scroll.scrollLeft - display.wheelStartX;
                    var movedY = scroll.scrollTop - display.wheelStartY;
                    var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                    display.wheelStartX = display.wheelStartY = null;
                    if (!sample) {
                        return;
                    }
                    wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
                    ++wheelSamples;
                }, 200);
            } else {
                display.wheelDX += dx;
                display.wheelDY += dy;
            }
        }
    }
    var Selection = function(ranges, primIndex) {
        this.ranges = ranges;
        this.primIndex = primIndex;
    };
    Selection.prototype.primary = function() {
        return this.ranges[this.primIndex];
    };
    Selection.prototype.equals = function(other) {
        if (other == this) {
            return true;
        }
        if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
            return false;
        }
        for(var i = 0; i < this.ranges.length; i++){
            var here = this.ranges[i], there = other.ranges[i];
            if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
                return false;
            }
        }
        return true;
    };
    Selection.prototype.deepCopy = function() {
        var out = [];
        for(var i = 0; i < this.ranges.length; i++){
            out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
        }
        return new Selection(out, this.primIndex);
    };
    Selection.prototype.somethingSelected = function() {
        for(var i = 0; i < this.ranges.length; i++){
            if (!this.ranges[i].empty()) {
                return true;
            }
        }
        return false;
    };
    Selection.prototype.contains = function(pos, end) {
        if (!end) {
            end = pos;
        }
        for(var i = 0; i < this.ranges.length; i++){
            var range = this.ranges[i];
            if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) {
                return i;
            }
        }
        return -1;
    };
    var Range = function(anchor, head) {
        this.anchor = anchor;
        this.head = head;
    };
    Range.prototype.from = function() {
        return minPos(this.anchor, this.head);
    };
    Range.prototype.to = function() {
        return maxPos(this.anchor, this.head);
    };
    Range.prototype.empty = function() {
        return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    };
    function normalizeSelection(cm, ranges, primIndex) {
        var mayTouch = cm && cm.options.selectionsMayTouch;
        var prim = ranges[primIndex];
        ranges.sort(function(a, b) {
            return cmp(a.from(), b.from());
        });
        primIndex = indexOf(ranges, prim);
        for(var i = 1; i < ranges.length; i++){
            var cur = ranges[i], prev = ranges[i - 1];
            var diff = cmp(prev.to(), cur.from());
            if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
                var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
                var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
                if (i <= primIndex) {
                    --primIndex;
                }
                ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
            }
        }
        return new Selection(ranges, primIndex);
    }
    function simpleSelection(anchor, head) {
        return new Selection([
            new Range(anchor, head || anchor)
        ], 0);
    }
    function changeEnd(change) {
        if (!change.text) {
            return change.to;
        }
        return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
    }
    function adjustForChange(pos, change) {
        if (cmp(pos, change.from) < 0) {
            return pos;
        }
        if (cmp(pos, change.to) <= 0) {
            return changeEnd(change);
        }
        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
        if (pos.line == change.to.line) {
            ch += changeEnd(change).ch - change.to.ch;
        }
        return Pos(line, ch);
    }
    function computeSelAfterChange(doc, change) {
        var out = [];
        for(var i = 0; i < doc.sel.ranges.length; i++){
            var range = doc.sel.ranges[i];
            out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
        }
        return normalizeSelection(doc.cm, out, doc.sel.primIndex);
    }
    function offsetPos(pos, old, nw) {
        if (pos.line == old.line) {
            return Pos(nw.line, pos.ch - old.ch + nw.ch);
        } else {
            return Pos(nw.line + (pos.line - old.line), pos.ch);
        }
    }
    function computeReplacedSel(doc, changes, hint) {
        var out = [];
        var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
        for(var i = 0; i < changes.length; i++){
            var change = changes[i];
            var from = offsetPos(change.from, oldPrev, newPrev);
            var to = offsetPos(changeEnd(change), oldPrev, newPrev);
            oldPrev = change.to;
            newPrev = to;
            if (hint == "around") {
                var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
                out[i] = new Range(inv ? to : from, inv ? from : to);
            } else {
                out[i] = new Range(from, from);
            }
        }
        return new Selection(out, doc.sel.primIndex);
    }
    function loadMode(cm) {
        cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
        resetModeState(cm);
    }
    function resetModeState(cm) {
        cm.doc.iter(function(line) {
            if (line.stateAfter) {
                line.stateAfter = null;
            }
            if (line.styles) {
                line.styles = null;
            }
        });
        cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
        startWorker(cm, 100);
        cm.state.modeGen++;
        if (cm.curOp) {
            regChange(cm);
        }
    }
    function isWholeLineUpdate(doc, change) {
        return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
    }
    function updateDoc(doc, change, markedSpans, estimateHeight) {
        function spansFor(n) {
            return markedSpans ? markedSpans[n] : null;
        }
        function update(line, text, spans) {
            updateLine(line, text, spans, estimateHeight);
            signalLater(line, "change", line, change);
        }
        function linesFor(start, end) {
            var result = [];
            for(var i = start; i < end; ++i){
                result.push(new Line(text[i], spansFor(i), estimateHeight));
            }
            return result;
        }
        var from = change.from, to = change.to, text = change.text;
        var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
        var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
        if (change.full) {
            doc.insert(0, linesFor(0, text.length));
            doc.remove(text.length, doc.size - text.length);
        } else if (isWholeLineUpdate(doc, change)) {
            var added = linesFor(0, text.length - 1);
            update(lastLine, lastLine.text, lastSpans);
            if (nlines) {
                doc.remove(from.line, nlines);
            }
            if (added.length) {
                doc.insert(from.line, added);
            }
        } else if (firstLine == lastLine) {
            if (text.length == 1) {
                update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
            } else {
                var added$1 = linesFor(1, text.length - 1);
                added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
                update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
                doc.insert(from.line + 1, added$1);
            }
        } else if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
            doc.remove(from.line + 1, nlines);
        } else {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
            update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
            var added$2 = linesFor(1, text.length - 1);
            if (nlines > 1) {
                doc.remove(from.line + 1, nlines - 1);
            }
            doc.insert(from.line + 1, added$2);
        }
        signalLater(doc, "change", doc, change);
    }
    function linkedDocs(doc, f, sharedHistOnly) {
        function propagate(doc, skip, sharedHist) {
            if (doc.linked) {
                for(var i = 0; i < doc.linked.length; ++i){
                    var rel = doc.linked[i];
                    if (rel.doc == skip) {
                        continue;
                    }
                    var shared = sharedHist && rel.sharedHist;
                    if (sharedHistOnly && !shared) {
                        continue;
                    }
                    f(rel.doc, shared);
                    propagate(rel.doc, doc, shared);
                }
            }
        }
        propagate(doc, null, true);
    }
    function attachDoc(cm, doc) {
        if (doc.cm) {
            throw new Error("This document is already in use.");
        }
        cm.doc = doc;
        doc.cm = cm;
        estimateLineHeights(cm);
        loadMode(cm);
        setDirectionClass(cm);
        cm.options.direction = doc.direction;
        if (!cm.options.lineWrapping) {
            findMaxLine(cm);
        }
        cm.options.mode = doc.modeOption;
        regChange(cm);
    }
    function setDirectionClass(cm) {
        (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
    }
    function directionChanged(cm) {
        runInOp(cm, function() {
            setDirectionClass(cm);
            regChange(cm);
        });
    }
    function History(prev) {
        this.done = [];
        this.undone = [];
        this.undoDepth = prev ? prev.undoDepth : Infinity;
        this.lastModTime = this.lastSelTime = 0;
        this.lastOp = this.lastSelOp = null;
        this.lastOrigin = this.lastSelOrigin = null;
        this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
    }
    function historyChangeFromChange(doc, change) {
        var histChange = {
            from: copyPos(change.from),
            to: changeEnd(change),
            text: getBetween(doc, change.from, change.to)
        };
        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        linkedDocs(doc, function(doc) {
            return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        }, true);
        return histChange;
    }
    function clearSelectionEvents(array) {
        while(array.length){
            var last = lst(array);
            if (last.ranges) {
                array.pop();
            } else {
                break;
            }
        }
    }
    function lastChangeEvent(hist, force) {
        if (force) {
            clearSelectionEvents(hist.done);
            return lst(hist.done);
        } else if (hist.done.length && !lst(hist.done).ranges) {
            return lst(hist.done);
        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
            hist.done.pop();
            return lst(hist.done);
        }
    }
    function addChangeToHistory(doc, change, selAfter, opId) {
        var hist = doc.history;
        hist.undone.length = 0;
        var time = +new Date, cur;
        var last;
        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
            last = lst(cur.changes);
            if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
                last.to = changeEnd(change);
            } else {
                cur.changes.push(historyChangeFromChange(doc, change));
            }
        } else {
            var before = lst(hist.done);
            if (!before || !before.ranges) {
                pushSelectionToHistory(doc.sel, hist.done);
            }
            cur = {
                changes: [
                    historyChangeFromChange(doc, change)
                ],
                generation: hist.generation
            };
            hist.done.push(cur);
            while(hist.done.length > hist.undoDepth){
                hist.done.shift();
                if (!hist.done[0].ranges) {
                    hist.done.shift();
                }
            }
        }
        hist.done.push(selAfter);
        hist.generation = ++hist.maxGeneration;
        hist.lastModTime = hist.lastSelTime = time;
        hist.lastOp = hist.lastSelOp = opId;
        hist.lastOrigin = hist.lastSelOrigin = change.origin;
        if (!last) {
            signal(doc, "historyAdded");
        }
    }
    function selectionEventCanBeMerged(doc, origin, prev, sel) {
        var ch = origin.charAt(0);
        return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
    }
    function addSelectionToHistory(doc, sel, opId, options) {
        var hist = doc.history, origin = options && options.origin;
        if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {
            hist.done[hist.done.length - 1] = sel;
        } else {
            pushSelectionToHistory(sel, hist.done);
        }
        hist.lastSelTime = +new Date;
        hist.lastSelOrigin = origin;
        hist.lastSelOp = opId;
        if (options && options.clearRedo !== false) {
            clearSelectionEvents(hist.undone);
        }
    }
    function pushSelectionToHistory(sel, dest) {
        var top = lst(dest);
        if (!(top && top.ranges && top.equals(sel))) {
            dest.push(sel);
        }
    }
    function attachLocalSpans(doc, change, from, to) {
        var existing = change["spans_" + doc.id], n = 0;
        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
            if (line.markedSpans) {
                (existing || (existing = change["spans_" + doc.id] = {
                }))[n] = line.markedSpans;
            }
            ++n;
        });
    }
    function removeClearedSpans(spans) {
        if (!spans) {
            return null;
        }
        var out;
        for(var i = 0; i < spans.length; ++i){
            if (spans[i].marker.explicitlyCleared) {
                if (!out) {
                    out = spans.slice(0, i);
                }
            } else if (out) {
                out.push(spans[i]);
            }
        }
        return !out ? spans : out.length ? out : null;
    }
    function getOldSpans(doc, change) {
        var found = change["spans_" + doc.id];
        if (!found) {
            return null;
        }
        var nw = [];
        for(var i = 0; i < change.text.length; ++i){
            nw.push(removeClearedSpans(found[i]));
        }
        return nw;
    }
    function mergeOldSpans(doc, change) {
        var old = getOldSpans(doc, change);
        var stretched = stretchSpansOverChange(doc, change);
        if (!old) {
            return stretched;
        }
        if (!stretched) {
            return old;
        }
        for(var i = 0; i < old.length; ++i){
            var oldCur = old[i], stretchCur = stretched[i];
            if (oldCur && stretchCur) {
                spans: for(var j = 0; j < stretchCur.length; ++j){
                    var span = stretchCur[j];
                    for(var k = 0; k < oldCur.length; ++k){
                        if (oldCur[k].marker == span.marker) {
                            continue spans;
                        }
                    }
                    oldCur.push(span);
                }
            } else if (stretchCur) {
                old[i] = stretchCur;
            }
        }
        return old;
    }
    function copyHistoryArray(events, newGroup, instantiateSel) {
        var copy = [];
        for(var i = 0; i < events.length; ++i){
            var event = events[i];
            if (event.ranges) {
                copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
                continue;
            }
            var changes = event.changes, newChanges = [];
            copy.push({
                changes: newChanges
            });
            for(var j = 0; j < changes.length; ++j){
                var change = changes[j], m = void 0;
                newChanges.push({
                    from: change.from,
                    to: change.to,
                    text: change.text
                });
                if (newGroup) {
                    for(var prop in change){
                        if (m = prop.match(/^spans_(\d+)$/)) {
                            if (indexOf(newGroup, Number(m[1])) > -1) {
                                lst(newChanges)[prop] = change[prop];
                                delete change[prop];
                            }
                        }
                    }
                }
            }
        }
        return copy;
    }
    function extendRange(range, head, other, extend) {
        if (extend) {
            var anchor = range.anchor;
            if (other) {
                var posBefore = cmp(head, anchor) < 0;
                if (posBefore != cmp(other, anchor) < 0) {
                    anchor = head;
                    head = other;
                } else if (posBefore != cmp(head, other) < 0) {
                    head = other;
                }
            }
            return new Range(anchor, head);
        } else {
            return new Range(other || head, head);
        }
    }
    function extendSelection(doc, head, other, options, extend) {
        if (extend == null) {
            extend = doc.cm && (doc.cm.display.shift || doc.extend);
        }
        setSelection(doc, new Selection([
            extendRange(doc.sel.primary(), head, other, extend)
        ], 0), options);
    }
    function extendSelections(doc, heads, options) {
        var out = [];
        var extend = doc.cm && (doc.cm.display.shift || doc.extend);
        for(var i = 0; i < doc.sel.ranges.length; i++){
            out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);
        }
        var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
        setSelection(doc, newSel, options);
    }
    function replaceOneSelection(doc, i, range, options) {
        var ranges = doc.sel.ranges.slice(0);
        ranges[i] = range;
        setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
    }
    function setSimpleSelection(doc, anchor, head, options) {
        setSelection(doc, simpleSelection(anchor, head), options);
    }
    function filterSelectionChange(doc, sel, options) {
        var obj = {
            ranges: sel.ranges,
            update: function(ranges) {
                this.ranges = [];
                for(var i = 0; i < ranges.length; i++){
                    this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head));
                }
            },
            origin: options && options.origin
        };
        signal(doc, "beforeSelectionChange", doc, obj);
        if (doc.cm) {
            signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
        }
        if (obj.ranges != sel.ranges) {
            return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);
        } else {
            return sel;
        }
    }
    function setSelectionReplaceHistory(doc, sel, options) {
        var done = doc.history.done, last = lst(done);
        if (last && last.ranges) {
            done[done.length - 1] = sel;
            setSelectionNoUndo(doc, sel, options);
        } else {
            setSelection(doc, sel, options);
        }
    }
    function setSelection(doc, sel, options) {
        setSelectionNoUndo(doc, sel, options);
        addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
    }
    function setSelectionNoUndo(doc, sel, options) {
        if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
            sel = filterSelectionChange(doc, sel, options);
        }
        var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
        setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
        if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor") {
            ensureCursorVisible(doc.cm);
        }
    }
    function setSelectionInner(doc, sel) {
        if (sel.equals(doc.sel)) {
            return;
        }
        doc.sel = sel;
        if (doc.cm) {
            doc.cm.curOp.updateInput = 1;
            doc.cm.curOp.selectionChanged = true;
            signalCursorActivity(doc.cm);
        }
        signalLater(doc, "cursorActivity", doc);
    }
    function reCheckSelection(doc) {
        setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
    }
    function skipAtomicInSelection(doc, sel, bias, mayClear) {
        var out;
        for(var i = 0; i < sel.ranges.length; i++){
            var range = sel.ranges[i];
            var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
            var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
            var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
            if (out || newAnchor != range.anchor || newHead != range.head) {
                if (!out) {
                    out = sel.ranges.slice(0, i);
                }
                out[i] = new Range(newAnchor, newHead);
            }
        }
        return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;
    }
    function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
        var line = getLine(doc, pos.line);
        if (line.markedSpans) {
            for(var i = 0; i < line.markedSpans.length; ++i){
                var sp = line.markedSpans[i], m = sp.marker;
                var preventCursorLeft = "selectLeft" in m ? !m.selectLeft : m.inclusiveLeft;
                var preventCursorRight = "selectRight" in m ? !m.selectRight : m.inclusiveRight;
                if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
                    if (mayClear) {
                        signal(m, "beforeCursorEnter");
                        if (m.explicitlyCleared) {
                            if (!line.markedSpans) {
                                break;
                            } else {
                                --i;
                                continue;
                            }
                        }
                    }
                    if (!m.atomic) {
                        continue;
                    }
                    if (oldPos) {
                        var near = m.find(dir < 0 ? 1 : -1), diff = void 0;
                        if (dir < 0 ? preventCursorRight : preventCursorLeft) {
                            near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
                        }
                        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
                            return skipAtomicInner(doc, near, pos, dir, mayClear);
                        }
                    }
                    var far = m.find(dir < 0 ? -1 : 1);
                    if (dir < 0 ? preventCursorLeft : preventCursorRight) {
                        far = movePos(doc, far, dir, far.line == pos.line ? line : null);
                    }
                    return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
                }
            }
        }
        return pos;
    }
    function skipAtomic(doc, pos, oldPos, bias, mayClear) {
        var dir = bias || 1;
        var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);
        if (!found) {
            doc.cantEdit = true;
            return Pos(doc.first, 0);
        }
        return found;
    }
    function movePos(doc, pos, dir, line) {
        if (dir < 0 && pos.ch == 0) {
            if (pos.line > doc.first) {
                return clipPos(doc, Pos(pos.line - 1));
            } else {
                return null;
            }
        } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
            if (pos.line < doc.first + doc.size - 1) {
                return Pos(pos.line + 1, 0);
            } else {
                return null;
            }
        } else {
            return new Pos(pos.line, pos.ch + dir);
        }
    }
    function selectAll(cm) {
        cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
    }
    function filterChange(doc, change, update) {
        var obj = {
            canceled: false,
            from: change.from,
            to: change.to,
            text: change.text,
            origin: change.origin,
            cancel: function() {
                return obj.canceled = true;
            }
        };
        if (update) {
            obj.update = function(from, to, text, origin) {
                if (from) {
                    obj.from = clipPos(doc, from);
                }
                if (to) {
                    obj.to = clipPos(doc, to);
                }
                if (text) {
                    obj.text = text;
                }
                if (origin !== undefined) {
                    obj.origin = origin;
                }
            };
        }
        signal(doc, "beforeChange", doc, obj);
        if (doc.cm) {
            signal(doc.cm, "beforeChange", doc.cm, obj);
        }
        if (obj.canceled) {
            if (doc.cm) {
                doc.cm.curOp.updateInput = 2;
            }
            return null;
        }
        return {
            from: obj.from,
            to: obj.to,
            text: obj.text,
            origin: obj.origin
        };
    }
    function makeChange(doc, change, ignoreReadOnly) {
        if (doc.cm) {
            if (!doc.cm.curOp) {
                return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
            }
            if (doc.cm.state.suppressEdits) {
                return;
            }
        }
        if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
            change = filterChange(doc, change, true);
            if (!change) {
                return;
            }
        }
        var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
        if (split) {
            for(var i = split.length - 1; i >= 0; --i){
                makeChangeInner(doc, {
                    from: split[i].from,
                    to: split[i].to,
                    text: i ? [
                        ""
                    ] : change.text,
                    origin: change.origin
                });
            }
        } else {
            makeChangeInner(doc, change);
        }
    }
    function makeChangeInner(doc, change) {
        if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
            return;
        }
        var selAfter = computeSelAfterChange(doc, change);
        addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
        makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
        var rebased = [];
        linkedDocs(doc, function(doc, sharedHist) {
            if (!sharedHist && indexOf(rebased, doc.history) == -1) {
                rebaseHist(doc.history, change);
                rebased.push(doc.history);
            }
            makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
        });
    }
    function makeChangeFromHistory(doc, type, allowSelectionOnly) {
        var suppress = doc.cm && doc.cm.state.suppressEdits;
        if (suppress && !allowSelectionOnly) {
            return;
        }
        var hist = doc.history, event, selAfter = doc.sel;
        var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;
        var i = 0;
        for(; i < source.length; i++){
            event = source[i];
            if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {
                break;
            }
        }
        if (i == source.length) {
            return;
        }
        hist.lastOrigin = hist.lastSelOrigin = null;
        for(;;){
            event = source.pop();
            if (event.ranges) {
                pushSelectionToHistory(event, dest);
                if (allowSelectionOnly && !event.equals(doc.sel)) {
                    setSelection(doc, event, {
                        clearRedo: false
                    });
                    return;
                }
                selAfter = event;
            } else if (suppress) {
                source.push(event);
                return;
            } else {
                break;
            }
        }
        var antiChanges = [];
        pushSelectionToHistory(selAfter, dest);
        dest.push({
            changes: antiChanges,
            generation: hist.generation
        });
        hist.generation = event.generation || ++hist.maxGeneration;
        var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
        var loop = function(i) {
            var change = event.changes[i];
            change.origin = type;
            if (filter && !filterChange(doc, change, false)) {
                source.length = 0;
                return {
                };
            }
            antiChanges.push(historyChangeFromChange(doc, change));
            var after = i ? computeSelAfterChange(doc, change) : lst(source);
            makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
            if (!i && doc.cm) {
                doc.cm.scrollIntoView({
                    from: change.from,
                    to: changeEnd(change)
                });
            }
            var rebased = [];
            linkedDocs(doc, function(doc, sharedHist) {
                if (!sharedHist && indexOf(rebased, doc.history) == -1) {
                    rebaseHist(doc.history, change);
                    rebased.push(doc.history);
                }
                makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
            });
        };
        for(var i$1 = event.changes.length - 1; i$1 >= 0; --i$1){
            var returned = loop(i$1);
            if (returned) return returned.v;
        }
    }
    function shiftDoc(doc, distance) {
        if (distance == 0) {
            return;
        }
        doc.first += distance;
        doc.sel = new Selection(map(doc.sel.ranges, function(range) {
            return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
        }), doc.sel.primIndex);
        if (doc.cm) {
            regChange(doc.cm, doc.first, doc.first - distance, distance);
            for(var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++){
                regLineChange(doc.cm, l, "gutter");
            }
        }
    }
    function makeChangeSingleDoc(doc, change, selAfter, spans) {
        if (doc.cm && !doc.cm.curOp) {
            return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
        }
        if (change.to.line < doc.first) {
            shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
            return;
        }
        if (change.from.line > doc.lastLine()) {
            return;
        }
        if (change.from.line < doc.first) {
            var shift = change.text.length - 1 - (doc.first - change.from.line);
            shiftDoc(doc, shift);
            change = {
                from: Pos(doc.first, 0),
                to: Pos(change.to.line + shift, change.to.ch),
                text: [
                    lst(change.text)
                ],
                origin: change.origin
            };
        }
        var last = doc.lastLine();
        if (change.to.line > last) {
            change = {
                from: change.from,
                to: Pos(last, getLine(doc, last).text.length),
                text: [
                    change.text[0]
                ],
                origin: change.origin
            };
        }
        change.removed = getBetween(doc, change.from, change.to);
        if (!selAfter) {
            selAfter = computeSelAfterChange(doc, change);
        }
        if (doc.cm) {
            makeChangeSingleDocInEditor(doc.cm, change, spans);
        } else {
            updateDoc(doc, change, spans);
        }
        setSelectionNoUndo(doc, selAfter, sel_dontScroll);
        if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {
            doc.cantEdit = false;
        }
    }
    function makeChangeSingleDocInEditor(cm, change, spans) {
        var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
        var recomputeMaxLength = false, checkWidthStart = from.line;
        if (!cm.options.lineWrapping) {
            checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
            doc.iter(checkWidthStart, to.line + 1, function(line) {
                if (line == display.maxLine) {
                    recomputeMaxLength = true;
                    return true;
                }
            });
        }
        if (doc.sel.contains(change.from, change.to) > -1) {
            signalCursorActivity(cm);
        }
        updateDoc(doc, change, spans, estimateHeight(cm));
        if (!cm.options.lineWrapping) {
            doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
                var len = lineLength(line);
                if (len > display.maxLineLength) {
                    display.maxLine = line;
                    display.maxLineLength = len;
                    display.maxLineChanged = true;
                    recomputeMaxLength = false;
                }
            });
            if (recomputeMaxLength) {
                cm.curOp.updateMaxLine = true;
            }
        }
        retreatFrontier(doc, from.line);
        startWorker(cm, 400);
        var lendiff = change.text.length - (to.line - from.line) - 1;
        if (change.full) {
            regChange(cm);
        } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
            regLineChange(cm, from.line, "text");
        } else {
            regChange(cm, from.line, to.line + 1, lendiff);
        }
        var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
        if (changeHandler || changesHandler) {
            var obj = {
                from: from,
                to: to,
                text: change.text,
                removed: change.removed,
                origin: change.origin
            };
            if (changeHandler) {
                signalLater(cm, "change", cm, obj);
            }
            if (changesHandler) {
                (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
            }
        }
        cm.display.selForContextMenu = null;
    }
    function replaceRange(doc, code, from, to, origin) {
        var assign;
        if (!to) {
            to = from;
        }
        if (cmp(to, from) < 0) {
            assign = [
                to,
                from
            ], from = assign[0], to = assign[1];
        }
        if (typeof code == "string") {
            code = doc.splitLines(code);
        }
        makeChange(doc, {
            from: from,
            to: to,
            text: code,
            origin: origin
        });
    }
    function rebaseHistSelSingle(pos, from, to, diff) {
        if (to < pos.line) {
            pos.line += diff;
        } else if (from < pos.line) {
            pos.line = from;
            pos.ch = 0;
        }
    }
    function rebaseHistArray(array, from, to, diff) {
        for(var i = 0; i < array.length; ++i){
            var sub = array[i], ok = true;
            if (sub.ranges) {
                if (!sub.copied) {
                    sub = array[i] = sub.deepCopy();
                    sub.copied = true;
                }
                for(var j = 0; j < sub.ranges.length; j++){
                    rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
                    rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
                }
                continue;
            }
            for(var j$1 = 0; j$1 < sub.changes.length; ++j$1){
                var cur = sub.changes[j$1];
                if (to < cur.from.line) {
                    cur.from = Pos(cur.from.line + diff, cur.from.ch);
                    cur.to = Pos(cur.to.line + diff, cur.to.ch);
                } else if (from <= cur.to.line) {
                    ok = false;
                    break;
                }
            }
            if (!ok) {
                array.splice(0, i + 1);
                i = 0;
            }
        }
    }
    function rebaseHist(hist, change) {
        var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
        rebaseHistArray(hist.done, from, to, diff);
        rebaseHistArray(hist.undone, from, to, diff);
    }
    function changeLine(doc, handle, changeType, op) {
        var no = handle, line = handle;
        if (typeof handle == "number") {
            line = getLine(doc, clipLine(doc, handle));
        } else {
            no = lineNo(handle);
        }
        if (no == null) {
            return null;
        }
        if (op(line, no) && doc.cm) {
            regLineChange(doc.cm, no, changeType);
        }
        return line;
    }
    function LeafChunk(lines) {
        this.lines = lines;
        this.parent = null;
        var height = 0;
        for(var i = 0; i < lines.length; ++i){
            lines[i].parent = this;
            height += lines[i].height;
        }
        this.height = height;
    }
    LeafChunk.prototype = {
        chunkSize: function() {
            return this.lines.length;
        },
        removeInner: function(at, n) {
            for(var i = at, e = at + n; i < e; ++i){
                var line = this.lines[i];
                this.height -= line.height;
                cleanUpLine(line);
                signalLater(line, "delete");
            }
            this.lines.splice(at, n);
        },
        collapse: function(lines) {
            lines.push.apply(lines, this.lines);
        },
        insertInner: function(at, lines, height) {
            this.height += height;
            this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
            for(var i = 0; i < lines.length; ++i){
                lines[i].parent = this;
            }
        },
        iterN: function(at, n, op) {
            for(var e = at + n; at < e; ++at){
                if (op(this.lines[at])) {
                    return true;
                }
            }
        }
    };
    function BranchChunk(children) {
        this.children = children;
        var size = 0, height = 0;
        for(var i = 0; i < children.length; ++i){
            var ch = children[i];
            size += ch.chunkSize();
            height += ch.height;
            ch.parent = this;
        }
        this.size = size;
        this.height = height;
        this.parent = null;
    }
    BranchChunk.prototype = {
        chunkSize: function() {
            return this.size;
        },
        removeInner: function(at, n) {
            this.size -= n;
            for(var i = 0; i < this.children.length; ++i){
                var child = this.children[i], sz = child.chunkSize();
                if (at < sz) {
                    var rm = Math.min(n, sz - at), oldHeight = child.height;
                    child.removeInner(at, rm);
                    this.height -= oldHeight - child.height;
                    if (sz == rm) {
                        this.children.splice(i--, 1);
                        child.parent = null;
                    }
                    if ((n -= rm) == 0) {
                        break;
                    }
                    at = 0;
                } else {
                    at -= sz;
                }
            }
            if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
                var lines = [];
                this.collapse(lines);
                this.children = [
                    new LeafChunk(lines)
                ];
                this.children[0].parent = this;
            }
        },
        collapse: function(lines) {
            for(var i = 0; i < this.children.length; ++i){
                this.children[i].collapse(lines);
            }
        },
        insertInner: function(at, lines, height) {
            this.size += lines.length;
            this.height += height;
            for(var i = 0; i < this.children.length; ++i){
                var child = this.children[i], sz = child.chunkSize();
                if (at <= sz) {
                    child.insertInner(at, lines, height);
                    if (child.lines && child.lines.length > 50) {
                        var remaining = child.lines.length % 25 + 25;
                        for(var pos = remaining; pos < child.lines.length;){
                            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                            child.height -= leaf.height;
                            this.children.splice(++i, 0, leaf);
                            leaf.parent = this;
                        }
                        child.lines = child.lines.slice(0, remaining);
                        this.maybeSpill();
                    }
                    break;
                }
                at -= sz;
            }
        },
        maybeSpill: function() {
            if (this.children.length <= 10) {
                return;
            }
            var me = this;
            do {
                var spilled = me.children.splice(me.children.length - 5, 5);
                var sibling = new BranchChunk(spilled);
                if (!me.parent) {
                    var copy = new BranchChunk(me.children);
                    copy.parent = me;
                    me.children = [
                        copy,
                        sibling
                    ];
                    me = copy;
                } else {
                    me.size -= sibling.size;
                    me.height -= sibling.height;
                    var myIndex = indexOf(me.parent.children, me);
                    me.parent.children.splice(myIndex + 1, 0, sibling);
                }
                sibling.parent = me.parent;
            }while (me.children.length > 10)
            me.parent.maybeSpill();
        },
        iterN: function(at, n, op) {
            for(var i = 0; i < this.children.length; ++i){
                var child = this.children[i], sz = child.chunkSize();
                if (at < sz) {
                    var used = Math.min(n, sz - at);
                    if (child.iterN(at, used, op)) {
                        return true;
                    }
                    if ((n -= used) == 0) {
                        break;
                    }
                    at = 0;
                } else {
                    at -= sz;
                }
            }
        }
    };
    var LineWidget = function(doc, node, options) {
        if (options) {
            for(var opt in options){
                if (options.hasOwnProperty(opt)) {
                    this[opt] = options[opt];
                }
            }
        }
        this.doc = doc;
        this.node = node;
    };
    LineWidget.prototype.clear = function() {
        var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
        if (no == null || !ws) {
            return;
        }
        for(var i = 0; i < ws.length; ++i){
            if (ws[i] == this) {
                ws.splice(i--, 1);
            }
        }
        if (!ws.length) {
            line.widgets = null;
        }
        var height = widgetHeight(this);
        updateLineHeight(line, Math.max(0, line.height - height));
        if (cm) {
            runInOp(cm, function() {
                adjustScrollWhenAboveVisible(cm, line, -height);
                regLineChange(cm, no, "widget");
            });
            signalLater(cm, "lineWidgetCleared", cm, this, no);
        }
    };
    LineWidget.prototype.changed = function() {
        var this$1 = this;
        var oldH = this.height, cm = this.doc.cm, line = this.line;
        this.height = null;
        var diff = widgetHeight(this) - oldH;
        if (!diff) {
            return;
        }
        if (!lineIsHidden(this.doc, line)) {
            updateLineHeight(line, line.height + diff);
        }
        if (cm) {
            runInOp(cm, function() {
                cm.curOp.forceUpdate = true;
                adjustScrollWhenAboveVisible(cm, line, diff);
                signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
            });
        }
    };
    eventMixin(LineWidget);
    function adjustScrollWhenAboveVisible(cm, line, diff) {
        if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
            addToScrollTop(cm, diff);
        }
    }
    function addLineWidget(doc, handle, node, options) {
        var widget = new LineWidget(doc, node, options);
        var cm = doc.cm;
        if (cm && widget.noHScroll) {
            cm.display.alignWidgets = true;
        }
        changeLine(doc, handle, "widget", function(line) {
            var widgets = line.widgets || (line.widgets = []);
            if (widget.insertAt == null) {
                widgets.push(widget);
            } else {
                widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
            }
            widget.line = line;
            if (cm && !lineIsHidden(doc, line)) {
                var aboveVisible = heightAtLine(line) < doc.scrollTop;
                updateLineHeight(line, line.height + widgetHeight(widget));
                if (aboveVisible) {
                    addToScrollTop(cm, widget.height);
                }
                cm.curOp.forceUpdate = true;
            }
            return true;
        });
        if (cm) {
            signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
        }
        return widget;
    }
    var nextMarkerId = 0;
    var TextMarker = function(doc, type) {
        this.lines = [];
        this.type = type;
        this.doc = doc;
        this.id = ++nextMarkerId;
    };
    TextMarker.prototype.clear = function() {
        if (this.explicitlyCleared) {
            return;
        }
        var cm = this.doc.cm, withOp = cm && !cm.curOp;
        if (withOp) {
            startOperation(cm);
        }
        if (hasHandler(this, "clear")) {
            var found = this.find();
            if (found) {
                signalLater(this, "clear", found.from, found.to);
            }
        }
        var min = null, max = null;
        for(var i = 0; i < this.lines.length; ++i){
            var line = this.lines[i];
            var span = getMarkedSpanFor(line.markedSpans, this);
            if (cm && !this.collapsed) {
                regLineChange(cm, lineNo(line), "text");
            } else if (cm) {
                if (span.to != null) {
                    max = lineNo(line);
                }
                if (span.from != null) {
                    min = lineNo(line);
                }
            }
            line.markedSpans = removeMarkedSpan(line.markedSpans, span);
            if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
                updateLineHeight(line, textHeight(cm.display));
            }
        }
        if (cm && this.collapsed && !cm.options.lineWrapping) {
            for(var i$1 = 0; i$1 < this.lines.length; ++i$1){
                var visual = visualLine(this.lines[i$1]), len = lineLength(visual);
                if (len > cm.display.maxLineLength) {
                    cm.display.maxLine = visual;
                    cm.display.maxLineLength = len;
                    cm.display.maxLineChanged = true;
                }
            }
        }
        if (min != null && cm && this.collapsed) {
            regChange(cm, min, max + 1);
        }
        this.lines.length = 0;
        this.explicitlyCleared = true;
        if (this.atomic && this.doc.cantEdit) {
            this.doc.cantEdit = false;
            if (cm) {
                reCheckSelection(cm.doc);
            }
        }
        if (cm) {
            signalLater(cm, "markerCleared", cm, this, min, max);
        }
        if (withOp) {
            endOperation(cm);
        }
        if (this.parent) {
            this.parent.clear();
        }
    };
    TextMarker.prototype.find = function(side, lineObj) {
        if (side == null && this.type == "bookmark") {
            side = 1;
        }
        var from, to;
        for(var i = 0; i < this.lines.length; ++i){
            var line = this.lines[i];
            var span = getMarkedSpanFor(line.markedSpans, this);
            if (span.from != null) {
                from = Pos(lineObj ? line : lineNo(line), span.from);
                if (side == -1) {
                    return from;
                }
            }
            if (span.to != null) {
                to = Pos(lineObj ? line : lineNo(line), span.to);
                if (side == 1) {
                    return to;
                }
            }
        }
        return from && {
            from: from,
            to: to
        };
    };
    TextMarker.prototype.changed = function() {
        var this$1 = this;
        var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
        if (!pos || !cm) {
            return;
        }
        runInOp(cm, function() {
            var line = pos.line, lineN = lineNo(pos.line);
            var view = findViewForLine(cm, lineN);
            if (view) {
                clearLineMeasurementCacheFor(view);
                cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
            }
            cm.curOp.updateMaxLine = true;
            if (!lineIsHidden(widget.doc, line) && widget.height != null) {
                var oldHeight = widget.height;
                widget.height = null;
                var dHeight = widgetHeight(widget) - oldHeight;
                if (dHeight) {
                    updateLineHeight(line, line.height + dHeight);
                }
            }
            signalLater(cm, "markerChanged", cm, this$1);
        });
    };
    TextMarker.prototype.attachLine = function(line) {
        if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
                (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
            }
        }
        this.lines.push(line);
    };
    TextMarker.prototype.detachLine = function(line) {
        this.lines.splice(indexOf(this.lines, line), 1);
        if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
        }
    };
    eventMixin(TextMarker);
    function markText(doc, from, to, options, type) {
        if (options && options.shared) {
            return markTextShared(doc, from, to, options, type);
        }
        if (doc.cm && !doc.cm.curOp) {
            return operation(doc.cm, markText)(doc, from, to, options, type);
        }
        var marker = new TextMarker(doc, type), diff = cmp(from, to);
        if (options) {
            copyObj(options, marker, false);
        }
        if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
            return marker;
        }
        if (marker.replacedWith) {
            marker.collapsed = true;
            marker.widgetNode = eltP("span", [
                marker.replacedWith
            ], "CodeMirror-widget");
            if (!options.handleMouseEvents) {
                marker.widgetNode.setAttribute("cm-ignore-events", "true");
            }
            if (options.insertLeft) {
                marker.widgetNode.insertLeft = true;
            }
        }
        if (marker.collapsed) {
            if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {
                throw new Error("Inserting collapsed marker partially overlapping an existing one");
            }
            seeCollapsedSpans();
        }
        if (marker.addToHistory) {
            addChangeToHistory(doc, {
                from: from,
                to: to,
                origin: "markText"
            }, doc.sel, NaN);
        }
        var curLine = from.line, cm = doc.cm, updateMaxLine;
        doc.iter(curLine, to.line + 1, function(line) {
            if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
                updateMaxLine = true;
            }
            if (marker.collapsed && curLine != from.line) {
                updateLineHeight(line, 0);
            }
            addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);
            ++curLine;
        });
        if (marker.collapsed) {
            doc.iter(from.line, to.line + 1, function(line) {
                if (lineIsHidden(doc, line)) {
                    updateLineHeight(line, 0);
                }
            });
        }
        if (marker.clearOnEnter) {
            on(marker, "beforeCursorEnter", function() {
                return marker.clear();
            });
        }
        if (marker.readOnly) {
            seeReadOnlySpans();
            if (doc.history.done.length || doc.history.undone.length) {
                doc.clearHistory();
            }
        }
        if (marker.collapsed) {
            marker.id = ++nextMarkerId;
            marker.atomic = true;
        }
        if (cm) {
            if (updateMaxLine) {
                cm.curOp.updateMaxLine = true;
            }
            if (marker.collapsed) {
                regChange(cm, from.line, to.line + 1);
            } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
                for(var i = from.line; i <= to.line; i++){
                    regLineChange(cm, i, "text");
                }
            }
            if (marker.atomic) {
                reCheckSelection(cm.doc);
            }
            signalLater(cm, "markerAdded", cm, marker);
        }
        return marker;
    }
    var SharedTextMarker = function(markers, primary) {
        this.markers = markers;
        this.primary = primary;
        for(var i = 0; i < markers.length; ++i){
            markers[i].parent = this;
        }
    };
    SharedTextMarker.prototype.clear = function() {
        if (this.explicitlyCleared) {
            return;
        }
        this.explicitlyCleared = true;
        for(var i = 0; i < this.markers.length; ++i){
            this.markers[i].clear();
        }
        signalLater(this, "clear");
    };
    SharedTextMarker.prototype.find = function(side, lineObj) {
        return this.primary.find(side, lineObj);
    };
    eventMixin(SharedTextMarker);
    function markTextShared(doc, from, to, options, type) {
        options = copyObj(options);
        options.shared = false;
        var markers = [
            markText(doc, from, to, options, type)
        ], primary = markers[0];
        var widget = options.widgetNode;
        linkedDocs(doc, function(doc) {
            if (widget) {
                options.widgetNode = widget.cloneNode(true);
            }
            markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
            for(var i = 0; i < doc.linked.length; ++i){
                if (doc.linked[i].isParent) {
                    return;
                }
            }
            primary = lst(markers);
        });
        return new SharedTextMarker(markers, primary);
    }
    function findSharedMarkers(doc) {
        return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m) {
            return m.parent;
        });
    }
    function copySharedMarkers(doc, markers) {
        for(var i = 0; i < markers.length; i++){
            var marker = markers[i], pos = marker.find();
            var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
            if (cmp(mFrom, mTo)) {
                var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
                marker.markers.push(subMark);
                subMark.parent = marker;
            }
        }
    }
    function detachSharedMarkers(markers) {
        var loop = function(i) {
            var marker = markers[i], linked = [
                marker.primary.doc
            ];
            linkedDocs(marker.primary.doc, function(d) {
                return linked.push(d);
            });
            for(var j = 0; j < marker.markers.length; j++){
                var subMarker = marker.markers[j];
                if (indexOf(linked, subMarker.doc) == -1) {
                    subMarker.parent = null;
                    marker.markers.splice(j--, 1);
                }
            }
        };
        for(var i = 0; i < markers.length; i++)loop(i);
    }
    var nextDocId = 0;
    var Doc = function(text, mode, firstLine, lineSep, direction) {
        if (!(this instanceof Doc)) {
            return new Doc(text, mode, firstLine, lineSep, direction);
        }
        if (firstLine == null) {
            firstLine = 0;
        }
        BranchChunk.call(this, [
            new LeafChunk([
                new Line("", null)
            ])
        ]);
        this.first = firstLine;
        this.scrollTop = this.scrollLeft = 0;
        this.cantEdit = false;
        this.cleanGeneration = 1;
        this.modeFrontier = this.highlightFrontier = firstLine;
        var start = Pos(firstLine, 0);
        this.sel = simpleSelection(start);
        this.history = new History(null);
        this.id = ++nextDocId;
        this.modeOption = mode;
        this.lineSep = lineSep;
        this.direction = direction == "rtl" ? "rtl" : "ltr";
        this.extend = false;
        if (typeof text == "string") {
            text = this.splitLines(text);
        }
        updateDoc(this, {
            from: start,
            to: start,
            text: text
        });
        setSelection(this, simpleSelection(start), sel_dontScroll);
    };
    Doc.prototype = createObj(BranchChunk.prototype, {
        constructor: Doc,
        iter: function(from, to, op) {
            if (op) {
                this.iterN(from - this.first, to - from, op);
            } else {
                this.iterN(this.first, this.first + this.size, from);
            }
        },
        insert: function(at, lines) {
            var height = 0;
            for(var i = 0; i < lines.length; ++i){
                height += lines[i].height;
            }
            this.insertInner(at - this.first, lines, height);
        },
        remove: function(at, n) {
            this.removeInner(at - this.first, n);
        },
        getValue: function(lineSep) {
            var lines = getLines(this, this.first, this.first + this.size);
            if (lineSep === false) {
                return lines;
            }
            return lines.join(lineSep || this.lineSeparator());
        },
        setValue: docMethodOp(function(code) {
            var top = Pos(this.first, 0), last = this.first + this.size - 1;
            makeChange(this, {
                from: top,
                to: Pos(last, getLine(this, last).text.length),
                text: this.splitLines(code),
                origin: "setValue",
                full: true
            }, true);
            if (this.cm) {
                scrollToCoords(this.cm, 0, 0);
            }
            setSelection(this, simpleSelection(top), sel_dontScroll);
        }),
        replaceRange: function(code, from, to, origin) {
            from = clipPos(this, from);
            to = to ? clipPos(this, to) : from;
            replaceRange(this, code, from, to, origin);
        },
        getRange: function(from, to, lineSep) {
            var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
            if (lineSep === false) {
                return lines;
            }
            if (lineSep === '') {
                return lines.join('');
            }
            return lines.join(lineSep || this.lineSeparator());
        },
        getLine: function(line) {
            var l = this.getLineHandle(line);
            return l && l.text;
        },
        getLineHandle: function(line) {
            if (isLine(this, line)) {
                return getLine(this, line);
            }
        },
        getLineNumber: function(line) {
            return lineNo(line);
        },
        getLineHandleVisualStart: function(line) {
            if (typeof line == "number") {
                line = getLine(this, line);
            }
            return visualLine(line);
        },
        lineCount: function() {
            return this.size;
        },
        firstLine: function() {
            return this.first;
        },
        lastLine: function() {
            return this.first + this.size - 1;
        },
        clipPos: function(pos) {
            return clipPos(this, pos);
        },
        getCursor: function(start) {
            var range = this.sel.primary(), pos;
            if (start == null || start == "head") {
                pos = range.head;
            } else if (start == "anchor") {
                pos = range.anchor;
            } else if (start == "end" || start == "to" || start === false) {
                pos = range.to();
            } else {
                pos = range.from();
            }
            return pos;
        },
        listSelections: function() {
            return this.sel.ranges;
        },
        somethingSelected: function() {
            return this.sel.somethingSelected();
        },
        setCursor: docMethodOp(function(line, ch, options) {
            setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
        }),
        setSelection: docMethodOp(function(anchor, head, options) {
            setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
        }),
        extendSelection: docMethodOp(function(head, other, options) {
            extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
        }),
        extendSelections: docMethodOp(function(heads, options) {
            extendSelections(this, clipPosArray(this, heads), options);
        }),
        extendSelectionsBy: docMethodOp(function(f, options) {
            var heads = map(this.sel.ranges, f);
            extendSelections(this, clipPosArray(this, heads), options);
        }),
        setSelections: docMethodOp(function(ranges, primary, options) {
            if (!ranges.length) {
                return;
            }
            var out = [];
            for(var i = 0; i < ranges.length; i++){
                out[i] = new Range(clipPos(this, ranges[i].anchor), clipPos(this, ranges[i].head || ranges[i].anchor));
            }
            if (primary == null) {
                primary = Math.min(ranges.length - 1, this.sel.primIndex);
            }
            setSelection(this, normalizeSelection(this.cm, out, primary), options);
        }),
        addSelection: docMethodOp(function(anchor, head, options) {
            var ranges = this.sel.ranges.slice(0);
            ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
            setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
        }),
        getSelection: function(lineSep) {
            var ranges = this.sel.ranges, lines;
            for(var i = 0; i < ranges.length; i++){
                var sel = getBetween(this, ranges[i].from(), ranges[i].to());
                lines = lines ? lines.concat(sel) : sel;
            }
            if (lineSep === false) {
                return lines;
            } else {
                return lines.join(lineSep || this.lineSeparator());
            }
        },
        getSelections: function(lineSep) {
            var parts = [], ranges = this.sel.ranges;
            for(var i = 0; i < ranges.length; i++){
                var sel = getBetween(this, ranges[i].from(), ranges[i].to());
                if (lineSep !== false) {
                    sel = sel.join(lineSep || this.lineSeparator());
                }
                parts[i] = sel;
            }
            return parts;
        },
        replaceSelection: function(code, collapse, origin) {
            var dup = [];
            for(var i = 0; i < this.sel.ranges.length; i++){
                dup[i] = code;
            }
            this.replaceSelections(dup, collapse, origin || "+input");
        },
        replaceSelections: docMethodOp(function(code, collapse, origin) {
            var changes = [], sel = this.sel;
            for(var i = 0; i < sel.ranges.length; i++){
                var range = sel.ranges[i];
                changes[i] = {
                    from: range.from(),
                    to: range.to(),
                    text: this.splitLines(code[i]),
                    origin: origin
                };
            }
            var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
            for(var i$1 = changes.length - 1; i$1 >= 0; i$1--){
                makeChange(this, changes[i$1]);
            }
            if (newSel) {
                setSelectionReplaceHistory(this, newSel);
            } else if (this.cm) {
                ensureCursorVisible(this.cm);
            }
        }),
        undo: docMethodOp(function() {
            makeChangeFromHistory(this, "undo");
        }),
        redo: docMethodOp(function() {
            makeChangeFromHistory(this, "redo");
        }),
        undoSelection: docMethodOp(function() {
            makeChangeFromHistory(this, "undo", true);
        }),
        redoSelection: docMethodOp(function() {
            makeChangeFromHistory(this, "redo", true);
        }),
        setExtending: function(val) {
            this.extend = val;
        },
        getExtending: function() {
            return this.extend;
        },
        historySize: function() {
            var hist = this.history, done = 0, undone = 0;
            for(var i = 0; i < hist.done.length; i++){
                if (!hist.done[i].ranges) {
                    ++done;
                }
            }
            for(var i$1 = 0; i$1 < hist.undone.length; i$1++){
                if (!hist.undone[i$1].ranges) {
                    ++undone;
                }
            }
            return {
                undo: done,
                redo: undone
            };
        },
        clearHistory: function() {
            var this$1 = this;
            this.history = new History(this.history);
            linkedDocs(this, function(doc) {
                return doc.history = this$1.history;
            }, true);
        },
        markClean: function() {
            this.cleanGeneration = this.changeGeneration(true);
        },
        changeGeneration: function(forceSplit) {
            if (forceSplit) {
                this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
            }
            return this.history.generation;
        },
        isClean: function(gen) {
            return this.history.generation == (gen || this.cleanGeneration);
        },
        getHistory: function() {
            return {
                done: copyHistoryArray(this.history.done),
                undone: copyHistoryArray(this.history.undone)
            };
        },
        setHistory: function(histData) {
            var hist = this.history = new History(this.history);
            hist.done = copyHistoryArray(histData.done.slice(0), null, true);
            hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
        },
        setGutterMarker: docMethodOp(function(line, gutterID, value) {
            return changeLine(this, line, "gutter", function(line) {
                var markers = line.gutterMarkers || (line.gutterMarkers = {
                });
                markers[gutterID] = value;
                if (!value && isEmpty(markers)) {
                    line.gutterMarkers = null;
                }
                return true;
            });
        }),
        clearGutter: docMethodOp(function(gutterID) {
            var this$1 = this;
            this.iter(function(line) {
                if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
                    changeLine(this$1, line, "gutter", function() {
                        line.gutterMarkers[gutterID] = null;
                        if (isEmpty(line.gutterMarkers)) {
                            line.gutterMarkers = null;
                        }
                        return true;
                    });
                }
            });
        }),
        lineInfo: function(line) {
            var n;
            if (typeof line == "number") {
                if (!isLine(this, line)) {
                    return null;
                }
                n = line;
                line = getLine(this, line);
                if (!line) {
                    return null;
                }
            } else {
                n = lineNo(line);
                if (n == null) {
                    return null;
                }
            }
            return {
                line: n,
                handle: line,
                text: line.text,
                gutterMarkers: line.gutterMarkers,
                textClass: line.textClass,
                bgClass: line.bgClass,
                wrapClass: line.wrapClass,
                widgets: line.widgets
            };
        },
        addLineClass: docMethodOp(function(handle, where, cls) {
            return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
                var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
                if (!line[prop]) {
                    line[prop] = cls;
                } else if (classTest(cls).test(line[prop])) {
                    return false;
                } else {
                    line[prop] += " " + cls;
                }
                return true;
            });
        }),
        removeLineClass: docMethodOp(function(handle, where, cls) {
            return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
                var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
                var cur = line[prop];
                if (!cur) {
                    return false;
                } else if (cls == null) {
                    line[prop] = null;
                } else {
                    var found = cur.match(classTest(cls));
                    if (!found) {
                        return false;
                    }
                    var end = found.index + found[0].length;
                    line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
                }
                return true;
            });
        }),
        addLineWidget: docMethodOp(function(handle, node, options) {
            return addLineWidget(this, handle, node, options);
        }),
        removeLineWidget: function(widget) {
            widget.clear();
        },
        markText: function(from, to, options) {
            return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
        },
        setBookmark: function(pos, options) {
            var realOpts = {
                replacedWith: options && (options.nodeType == null ? options.widget : options),
                insertLeft: options && options.insertLeft,
                clearWhenEmpty: false,
                shared: options && options.shared,
                handleMouseEvents: options && options.handleMouseEvents
            };
            pos = clipPos(this, pos);
            return markText(this, pos, pos, realOpts, "bookmark");
        },
        findMarksAt: function(pos) {
            pos = clipPos(this, pos);
            var markers = [], spans = getLine(this, pos.line).markedSpans;
            if (spans) {
                for(var i = 0; i < spans.length; ++i){
                    var span = spans[i];
                    if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
                        markers.push(span.marker.parent || span.marker);
                    }
                }
            }
            return markers;
        },
        findMarks: function(from, to, filter) {
            from = clipPos(this, from);
            to = clipPos(this, to);
            var found = [], lineNo = from.line;
            this.iter(from.line, to.line + 1, function(line) {
                var spans = line.markedSpans;
                if (spans) {
                    for(var i = 0; i < spans.length; i++){
                        var span = spans[i];
                        if (!(span.to != null && lineNo == from.line && from.ch >= span.to || span.from == null && lineNo != from.line || span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
                            found.push(span.marker.parent || span.marker);
                        }
                    }
                }
                ++lineNo;
            });
            return found;
        },
        getAllMarks: function() {
            var markers = [];
            this.iter(function(line) {
                var sps = line.markedSpans;
                if (sps) {
                    for(var i = 0; i < sps.length; ++i){
                        if (sps[i].from != null) {
                            markers.push(sps[i].marker);
                        }
                    }
                }
            });
            return markers;
        },
        posFromIndex: function(off) {
            var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
            this.iter(function(line) {
                var sz = line.text.length + sepSize;
                if (sz > off) {
                    ch = off;
                    return true;
                }
                off -= sz;
                ++lineNo;
            });
            return clipPos(this, Pos(lineNo, ch));
        },
        indexFromPos: function(coords) {
            coords = clipPos(this, coords);
            var index = coords.ch;
            if (coords.line < this.first || coords.ch < 0) {
                return 0;
            }
            var sepSize = this.lineSeparator().length;
            this.iter(this.first, coords.line, function(line) {
                index += line.text.length + sepSize;
            });
            return index;
        },
        copy: function(copyHistory) {
            var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
            doc.scrollTop = this.scrollTop;
            doc.scrollLeft = this.scrollLeft;
            doc.sel = this.sel;
            doc.extend = false;
            if (copyHistory) {
                doc.history.undoDepth = this.history.undoDepth;
                doc.setHistory(this.getHistory());
            }
            return doc;
        },
        linkedDoc: function(options) {
            if (!options) {
                options = {
                };
            }
            var from = this.first, to = this.first + this.size;
            if (options.from != null && options.from > from) {
                from = options.from;
            }
            if (options.to != null && options.to < to) {
                to = options.to;
            }
            var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
            if (options.sharedHist) {
                copy.history = this.history;
            }
            (this.linked || (this.linked = [])).push({
                doc: copy,
                sharedHist: options.sharedHist
            });
            copy.linked = [
                {
                    doc: this,
                    isParent: true,
                    sharedHist: options.sharedHist
                }
            ];
            copySharedMarkers(copy, findSharedMarkers(this));
            return copy;
        },
        unlinkDoc: function(other) {
            if (other instanceof CodeMirror) {
                other = other.doc;
            }
            if (this.linked) {
                for(var i = 0; i < this.linked.length; ++i){
                    var link = this.linked[i];
                    if (link.doc != other) {
                        continue;
                    }
                    this.linked.splice(i, 1);
                    other.unlinkDoc(this);
                    detachSharedMarkers(findSharedMarkers(this));
                    break;
                }
            }
            if (other.history == this.history) {
                var splitIds = [
                    other.id
                ];
                linkedDocs(other, function(doc) {
                    return splitIds.push(doc.id);
                }, true);
                other.history = new History(null);
                other.history.done = copyHistoryArray(this.history.done, splitIds);
                other.history.undone = copyHistoryArray(this.history.undone, splitIds);
            }
        },
        iterLinkedDocs: function(f) {
            linkedDocs(this, f);
        },
        getMode: function() {
            return this.mode;
        },
        getEditor: function() {
            return this.cm;
        },
        splitLines: function(str) {
            if (this.lineSep) {
                return str.split(this.lineSep);
            }
            return splitLinesAuto(str);
        },
        lineSeparator: function() {
            return this.lineSep || "\n";
        },
        setDirection: docMethodOp(function(dir) {
            if (dir != "rtl") {
                dir = "ltr";
            }
            if (dir == this.direction) {
                return;
            }
            this.direction = dir;
            this.iter(function(line) {
                return line.order = null;
            });
            if (this.cm) {
                directionChanged(this.cm);
            }
        })
    });
    Doc.prototype.eachLine = Doc.prototype.iter;
    var lastDrop = 0;
    function onDrop(e) {
        var cm = this;
        clearDragCursor(cm);
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
            return;
        }
        e_preventDefault(e);
        if (ie) {
            lastDrop = +new Date;
        }
        var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
        if (!pos || cm.isReadOnly()) {
            return;
        }
        if (files && files.length && window.FileReader && window.File) {
            var n = files.length, text = Array(n), read = 0;
            var markAsReadAndPasteIfAllFilesAreRead = function() {
                if (++read == n) {
                    operation(cm, function() {
                        pos = clipPos(cm.doc, pos);
                        var change = {
                            from: pos,
                            to: pos,
                            text: cm.doc.splitLines(text.filter(function(t) {
                                return t != null;
                            }).join(cm.doc.lineSeparator())),
                            origin: "paste"
                        };
                        makeChange(cm.doc, change);
                        setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
                    })();
                }
            };
            var readTextFromFile = function(file, i) {
                if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
                    markAsReadAndPasteIfAllFilesAreRead();
                    return;
                }
                var reader = new FileReader;
                reader.onerror = function() {
                    return markAsReadAndPasteIfAllFilesAreRead();
                };
                reader.onload = function() {
                    var content = reader.result;
                    if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
                        markAsReadAndPasteIfAllFilesAreRead();
                        return;
                    }
                    text[i] = content;
                    markAsReadAndPasteIfAllFilesAreRead();
                };
                reader.readAsText(file);
            };
            for(var i = 0; i < files.length; i++){
                readTextFromFile(files[i], i);
            }
        } else {
            if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
                cm.state.draggingText(e);
                setTimeout(function() {
                    return cm.display.input.focus();
                }, 20);
                return;
            }
            try {
                var text$1 = e.dataTransfer.getData("Text");
                if (text$1) {
                    var selected;
                    if (cm.state.draggingText && !cm.state.draggingText.copy) {
                        selected = cm.listSelections();
                    }
                    setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
                    if (selected) {
                        for(var i$1 = 0; i$1 < selected.length; ++i$1){
                            replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag");
                        }
                    }
                    cm.replaceSelection(text$1, "around", "paste");
                    cm.display.input.focus();
                }
            } catch (e$1) {
            }
        }
    }
    function onDragStart(cm, e) {
        if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) {
            e_stop(e);
            return;
        }
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
            return;
        }
        e.dataTransfer.setData("Text", cm.getSelection());
        e.dataTransfer.effectAllowed = "copyMove";
        if (e.dataTransfer.setDragImage && !safari) {
            var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
            img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
            if (presto) {
                img.width = img.height = 1;
                cm.display.wrapper.appendChild(img);
                img._top = img.offsetTop;
            }
            e.dataTransfer.setDragImage(img, 0, 0);
            if (presto) {
                img.parentNode.removeChild(img);
            }
        }
    }
    function onDragOver(cm, e) {
        var pos = posFromMouse(cm, e);
        if (!pos) {
            return;
        }
        var frag = document.createDocumentFragment();
        drawSelectionCursor(cm, pos, frag);
        if (!cm.display.dragCursor) {
            cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
            cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
        }
        removeChildrenAndAdd(cm.display.dragCursor, frag);
    }
    function clearDragCursor(cm) {
        if (cm.display.dragCursor) {
            cm.display.lineSpace.removeChild(cm.display.dragCursor);
            cm.display.dragCursor = null;
        }
    }
    function forEachCodeMirror(f) {
        if (!document.getElementsByClassName) {
            return;
        }
        var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
        for(var i = 0; i < byClass.length; i++){
            var cm = byClass[i].CodeMirror;
            if (cm) {
                editors.push(cm);
            }
        }
        if (editors.length) {
            editors[0].operation(function() {
                for(var i = 0; i < editors.length; i++){
                    f(editors[i]);
                }
            });
        }
    }
    var globalsRegistered = false;
    function ensureGlobalHandlers() {
        if (globalsRegistered) {
            return;
        }
        registerGlobalHandlers();
        globalsRegistered = true;
    }
    function registerGlobalHandlers() {
        var resizeTimer;
        on(window, "resize", function() {
            if (resizeTimer == null) {
                resizeTimer = setTimeout(function() {
                    resizeTimer = null;
                    forEachCodeMirror(onResize);
                }, 100);
            }
        });
        on(window, "blur", function() {
            return forEachCodeMirror(onBlur);
        });
    }
    function onResize(cm) {
        var d = cm.display;
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.scrollbarsClipped = false;
        cm.setSize();
    }
    var keyNames = {
        3: "Pause",
        8: "Backspace",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Esc",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        44: "PrintScrn",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Mod",
        92: "Mod",
        93: "Mod",
        106: "*",
        107: "=",
        109: "-",
        110: ".",
        111: "/",
        145: "ScrollLock",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        224: "Mod",
        63232: "Up",
        63233: "Down",
        63234: "Left",
        63235: "Right",
        63272: "Delete",
        63273: "Home",
        63275: "End",
        63276: "PageUp",
        63277: "PageDown",
        63302: "Insert"
    };
    for(var i = 0; i < 10; i++){
        keyNames[i + 48] = keyNames[i + 96] = String(i);
    }
    for(var i$1 = 65; i$1 <= 90; i$1++){
        keyNames[i$1] = String.fromCharCode(i$1);
    }
    for(var i$2 = 1; i$2 <= 12; i$2++){
        keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
    }
    var keyMap = {
    };
    keyMap.basic = {
        "Left": "goCharLeft",
        "Right": "goCharRight",
        "Up": "goLineUp",
        "Down": "goLineDown",
        "End": "goLineEnd",
        "Home": "goLineStartSmart",
        "PageUp": "goPageUp",
        "PageDown": "goPageDown",
        "Delete": "delCharAfter",
        "Backspace": "delCharBefore",
        "Shift-Backspace": "delCharBefore",
        "Tab": "defaultTab",
        "Shift-Tab": "indentAuto",
        "Enter": "newlineAndIndent",
        "Insert": "toggleOverwrite",
        "Esc": "singleSelection"
    };
    keyMap.pcDefault = {
        "Ctrl-A": "selectAll",
        "Ctrl-D": "deleteLine",
        "Ctrl-Z": "undo",
        "Shift-Ctrl-Z": "redo",
        "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart",
        "Ctrl-End": "goDocEnd",
        "Ctrl-Up": "goLineUp",
        "Ctrl-Down": "goLineDown",
        "Ctrl-Left": "goGroupLeft",
        "Ctrl-Right": "goGroupRight",
        "Alt-Left": "goLineStart",
        "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore",
        "Ctrl-Delete": "delGroupAfter",
        "Ctrl-S": "save",
        "Ctrl-F": "find",
        "Ctrl-G": "findNext",
        "Shift-Ctrl-G": "findPrev",
        "Shift-Ctrl-F": "replace",
        "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess",
        "Ctrl-]": "indentMore",
        "Ctrl-U": "undoSelection",
        "Shift-Ctrl-U": "redoSelection",
        "Alt-U": "redoSelection",
        "fallthrough": "basic"
    };
    keyMap.emacsy = {
        "Ctrl-F": "goCharRight",
        "Ctrl-B": "goCharLeft",
        "Ctrl-P": "goLineUp",
        "Ctrl-N": "goLineDown",
        "Ctrl-A": "goLineStart",
        "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown",
        "Shift-Ctrl-V": "goPageUp",
        "Ctrl-D": "delCharAfter",
        "Ctrl-H": "delCharBefore",
        "Alt-Backspace": "delWordBefore",
        "Ctrl-K": "killLine",
        "Ctrl-T": "transposeChars",
        "Ctrl-O": "openLine"
    };
    keyMap.macDefault = {
        "Cmd-A": "selectAll",
        "Cmd-D": "deleteLine",
        "Cmd-Z": "undo",
        "Shift-Cmd-Z": "redo",
        "Cmd-Y": "redo",
        "Cmd-Home": "goDocStart",
        "Cmd-Up": "goDocStart",
        "Cmd-End": "goDocEnd",
        "Cmd-Down": "goDocEnd",
        "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight",
        "Cmd-Left": "goLineLeft",
        "Cmd-Right": "goLineRight",
        "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter",
        "Alt-Delete": "delGroupAfter",
        "Cmd-S": "save",
        "Cmd-F": "find",
        "Cmd-G": "findNext",
        "Shift-Cmd-G": "findPrev",
        "Cmd-Alt-F": "replace",
        "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess",
        "Cmd-]": "indentMore",
        "Cmd-Backspace": "delWrappedLineLeft",
        "Cmd-Delete": "delWrappedLineRight",
        "Cmd-U": "undoSelection",
        "Shift-Cmd-U": "redoSelection",
        "Ctrl-Up": "goDocStart",
        "Ctrl-Down": "goDocEnd",
        "fallthrough": [
            "basic",
            "emacsy"
        ]
    };
    keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
    function normalizeKeyName(name) {
        var parts = name.split(/-(?!$)/);
        name = parts[parts.length - 1];
        var alt, ctrl, shift, cmd;
        for(var i = 0; i < parts.length - 1; i++){
            var mod = parts[i];
            if (/^(cmd|meta|m)$/i.test(mod)) {
                cmd = true;
            } else if (/^a(lt)?$/i.test(mod)) {
                alt = true;
            } else if (/^(c|ctrl|control)$/i.test(mod)) {
                ctrl = true;
            } else if (/^s(hift)?$/i.test(mod)) {
                shift = true;
            } else {
                throw new Error("Unrecognized modifier name: " + mod);
            }
        }
        if (alt) {
            name = "Alt-" + name;
        }
        if (ctrl) {
            name = "Ctrl-" + name;
        }
        if (cmd) {
            name = "Cmd-" + name;
        }
        if (shift) {
            name = "Shift-" + name;
        }
        return name;
    }
    function normalizeKeyMap(keymap) {
        var copy = {
        };
        for(var keyname in keymap){
            if (keymap.hasOwnProperty(keyname)) {
                var value = keymap[keyname];
                if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
                    continue;
                }
                if (value == "...") {
                    delete keymap[keyname];
                    continue;
                }
                var keys = map(keyname.split(" "), normalizeKeyName);
                for(var i = 0; i < keys.length; i++){
                    var val = void 0, name = void 0;
                    if (i == keys.length - 1) {
                        name = keys.join(" ");
                        val = value;
                    } else {
                        name = keys.slice(0, i + 1).join(" ");
                        val = "...";
                    }
                    var prev = copy[name];
                    if (!prev) {
                        copy[name] = val;
                    } else if (prev != val) {
                        throw new Error("Inconsistent bindings for " + name);
                    }
                }
                delete keymap[keyname];
            }
        }
        for(var prop in copy){
            keymap[prop] = copy[prop];
        }
        return keymap;
    }
    function lookupKey(key, map, handle, context) {
        map = getKeyMap(map);
        var found = map.call ? map.call(key, context) : map[key];
        if (found === false) {
            return "nothing";
        }
        if (found === "...") {
            return "multi";
        }
        if (found != null && handle(found)) {
            return "handled";
        }
        if (map.fallthrough) {
            if (Object.prototype.toString.call(map.fallthrough) != "[object Array]") {
                return lookupKey(key, map.fallthrough, handle, context);
            }
            for(var i = 0; i < map.fallthrough.length; i++){
                var result = lookupKey(key, map.fallthrough[i], handle, context);
                if (result) {
                    return result;
                }
            }
        }
    }
    function isModifierKey(value) {
        var name = typeof value == "string" ? value : keyNames[value.keyCode];
        return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
    }
    function addModifierNames(name, event, noShift) {
        var base = name;
        if (event.altKey && base != "Alt") {
            name = "Alt-" + name;
        }
        if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
            name = "Ctrl-" + name;
        }
        if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") {
            name = "Cmd-" + name;
        }
        if (!noShift && event.shiftKey && base != "Shift") {
            name = "Shift-" + name;
        }
        return name;
    }
    function keyName(event, noShift) {
        if (presto && event.keyCode == 34 && event["char"]) {
            return false;
        }
        var name = keyNames[event.keyCode];
        if (name == null || event.altGraphKey) {
            return false;
        }
        if (event.keyCode == 3 && event.code) {
            name = event.code;
        }
        return addModifierNames(name, event, noShift);
    }
    function getKeyMap(val) {
        return typeof val == "string" ? keyMap[val] : val;
    }
    function deleteNearSelection(cm, compute) {
        var ranges = cm.doc.sel.ranges, kill = [];
        for(var i = 0; i < ranges.length; i++){
            var toKill = compute(ranges[i]);
            while(kill.length && cmp(toKill.from, lst(kill).to) <= 0){
                var replaced = kill.pop();
                if (cmp(replaced.from, toKill.from) < 0) {
                    toKill.from = replaced.from;
                    break;
                }
            }
            kill.push(toKill);
        }
        runInOp(cm, function() {
            for(var i = kill.length - 1; i >= 0; i--){
                replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
            }
            ensureCursorVisible(cm);
        });
    }
    function moveCharLogically(line, ch, dir) {
        var target = skipExtendingChars(line.text, ch + dir, dir);
        return target < 0 || target > line.text.length ? null : target;
    }
    function moveLogically(line, start, dir) {
        var ch = moveCharLogically(line, start.ch, dir);
        return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
    }
    function endOfLine(visually, cm, lineObj, lineNo, dir) {
        if (visually) {
            if (cm.doc.direction == "rtl") {
                dir = -dir;
            }
            var order = getOrder(lineObj, cm.doc.direction);
            if (order) {
                var part = dir < 0 ? lst(order) : order[0];
                var moveInStorageOrder = dir < 0 == (part.level == 1);
                var sticky = moveInStorageOrder ? "after" : "before";
                var ch;
                if (part.level > 0 || cm.doc.direction == "rtl") {
                    var prep = prepareMeasureForLine(cm, lineObj);
                    ch = dir < 0 ? lineObj.text.length - 1 : 0;
                    var targetTop = measureCharPrepared(cm, prep, ch).top;
                    ch = findFirst(function(ch) {
                        return measureCharPrepared(cm, prep, ch).top == targetTop;
                    }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
                    if (sticky == "before") {
                        ch = moveCharLogically(lineObj, ch, 1);
                    }
                } else {
                    ch = dir < 0 ? part.to : part.from;
                }
                return new Pos(lineNo, ch, sticky);
            }
        }
        return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
    }
    function moveVisually(cm, line, start, dir) {
        var bidi = getOrder(line, cm.doc.direction);
        if (!bidi) {
            return moveLogically(line, start, dir);
        }
        if (start.ch >= line.text.length) {
            start.ch = line.text.length;
            start.sticky = "before";
        } else if (start.ch <= 0) {
            start.ch = 0;
            start.sticky = "after";
        }
        var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
        if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
            return moveLogically(line, start, dir);
        }
        var mv = function(pos, dir) {
            return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir);
        };
        var prep;
        var getWrappedLineExtent = function(ch) {
            if (!cm.options.lineWrapping) {
                return {
                    begin: 0,
                    end: line.text.length
                };
            }
            prep = prep || prepareMeasureForLine(cm, line);
            return wrappedLineExtentChar(cm, line, prep, ch);
        };
        var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);
        if (cm.doc.direction == "rtl" || part.level == 1) {
            var moveInStorageOrder = part.level == 1 == dir < 0;
            var ch = mv(start, moveInStorageOrder ? 1 : -1);
            if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
                var sticky = moveInStorageOrder ? "before" : "after";
                return new Pos(start.line, ch, sticky);
            }
        }
        var searchInVisualLine = function(partPos, dir, wrappedLineExtent) {
            var getRes = function(ch, moveInStorageOrder) {
                return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), "before") : new Pos(start.line, ch, "after");
            };
            for(; partPos >= 0 && partPos < bidi.length; partPos += dir){
                var part = bidi[partPos];
                var moveInStorageOrder = dir > 0 == (part.level != 1);
                var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
                if (part.from <= ch && ch < part.to) {
                    return getRes(ch, moveInStorageOrder);
                }
                ch = moveInStorageOrder ? part.from : mv(part.to, -1);
                if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) {
                    return getRes(ch, moveInStorageOrder);
                }
            }
        };
        var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
        if (res) {
            return res;
        }
        var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
        if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
            res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
            if (res) {
                return res;
            }
        }
        return null;
    }
    var commands = {
        selectAll: selectAll,
        singleSelection: function(cm) {
            return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
        },
        killLine: function(cm) {
            return deleteNearSelection(cm, function(range) {
                if (range.empty()) {
                    var len = getLine(cm.doc, range.head.line).text.length;
                    if (range.head.ch == len && range.head.line < cm.lastLine()) {
                        return {
                            from: range.head,
                            to: Pos(range.head.line + 1, 0)
                        };
                    } else {
                        return {
                            from: range.head,
                            to: Pos(range.head.line, len)
                        };
                    }
                } else {
                    return {
                        from: range.from(),
                        to: range.to()
                    };
                }
            });
        },
        deleteLine: function(cm) {
            return deleteNearSelection(cm, function(range) {
                return {
                    from: Pos(range.from().line, 0),
                    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
                };
            });
        },
        delLineLeft: function(cm) {
            return deleteNearSelection(cm, function(range) {
                return {
                    from: Pos(range.from().line, 0),
                    to: range.from()
                };
            });
        },
        delWrappedLineLeft: function(cm) {
            return deleteNearSelection(cm, function(range) {
                var top = cm.charCoords(range.head, "div").top + 5;
                var leftPos = cm.coordsChar({
                    left: 0,
                    top: top
                }, "div");
                return {
                    from: leftPos,
                    to: range.from()
                };
            });
        },
        delWrappedLineRight: function(cm) {
            return deleteNearSelection(cm, function(range) {
                var top = cm.charCoords(range.head, "div").top + 5;
                var rightPos = cm.coordsChar({
                    left: cm.display.lineDiv.offsetWidth + 100,
                    top: top
                }, "div");
                return {
                    from: range.from(),
                    to: rightPos
                };
            });
        },
        undo: function(cm) {
            return cm.undo();
        },
        redo: function(cm) {
            return cm.redo();
        },
        undoSelection: function(cm) {
            return cm.undoSelection();
        },
        redoSelection: function(cm) {
            return cm.redoSelection();
        },
        goDocStart: function(cm) {
            return cm.extendSelection(Pos(cm.firstLine(), 0));
        },
        goDocEnd: function(cm) {
            return cm.extendSelection(Pos(cm.lastLine()));
        },
        goLineStart: function(cm) {
            return cm.extendSelectionsBy(function(range) {
                return lineStart(cm, range.head.line);
            }, {
                origin: "+move",
                bias: 1
            });
        },
        goLineStartSmart: function(cm) {
            return cm.extendSelectionsBy(function(range) {
                return lineStartSmart(cm, range.head);
            }, {
                origin: "+move",
                bias: 1
            });
        },
        goLineEnd: function(cm) {
            return cm.extendSelectionsBy(function(range) {
                return lineEnd(cm, range.head.line);
            }, {
                origin: "+move",
                bias: -1
            });
        },
        goLineRight: function(cm) {
            return cm.extendSelectionsBy(function(range) {
                var top = cm.cursorCoords(range.head, "div").top + 5;
                return cm.coordsChar({
                    left: cm.display.lineDiv.offsetWidth + 100,
                    top: top
                }, "div");
            }, sel_move);
        },
        goLineLeft: function(cm) {
            return cm.extendSelectionsBy(function(range) {
                var top = cm.cursorCoords(range.head, "div").top + 5;
                return cm.coordsChar({
                    left: 0,
                    top: top
                }, "div");
            }, sel_move);
        },
        goLineLeftSmart: function(cm) {
            return cm.extendSelectionsBy(function(range) {
                var top = cm.cursorCoords(range.head, "div").top + 5;
                var pos = cm.coordsChar({
                    left: 0,
                    top: top
                }, "div");
                if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
                    return lineStartSmart(cm, range.head);
                }
                return pos;
            }, sel_move);
        },
        goLineUp: function(cm) {
            return cm.moveV(-1, "line");
        },
        goLineDown: function(cm) {
            return cm.moveV(1, "line");
        },
        goPageUp: function(cm) {
            return cm.moveV(-1, "page");
        },
        goPageDown: function(cm) {
            return cm.moveV(1, "page");
        },
        goCharLeft: function(cm) {
            return cm.moveH(-1, "char");
        },
        goCharRight: function(cm) {
            return cm.moveH(1, "char");
        },
        goColumnLeft: function(cm) {
            return cm.moveH(-1, "column");
        },
        goColumnRight: function(cm) {
            return cm.moveH(1, "column");
        },
        goWordLeft: function(cm) {
            return cm.moveH(-1, "word");
        },
        goGroupRight: function(cm) {
            return cm.moveH(1, "group");
        },
        goGroupLeft: function(cm) {
            return cm.moveH(-1, "group");
        },
        goWordRight: function(cm) {
            return cm.moveH(1, "word");
        },
        delCharBefore: function(cm) {
            return cm.deleteH(-1, "codepoint");
        },
        delCharAfter: function(cm) {
            return cm.deleteH(1, "char");
        },
        delWordBefore: function(cm) {
            return cm.deleteH(-1, "word");
        },
        delWordAfter: function(cm) {
            return cm.deleteH(1, "word");
        },
        delGroupBefore: function(cm) {
            return cm.deleteH(-1, "group");
        },
        delGroupAfter: function(cm) {
            return cm.deleteH(1, "group");
        },
        indentAuto: function(cm) {
            return cm.indentSelection("smart");
        },
        indentMore: function(cm) {
            return cm.indentSelection("add");
        },
        indentLess: function(cm) {
            return cm.indentSelection("subtract");
        },
        insertTab: function(cm) {
            return cm.replaceSelection("\t");
        },
        insertSoftTab: function(cm) {
            var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
            for(var i = 0; i < ranges.length; i++){
                var pos = ranges[i].from();
                var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
                spaces.push(spaceStr(tabSize - col % tabSize));
            }
            cm.replaceSelections(spaces);
        },
        defaultTab: function(cm) {
            if (cm.somethingSelected()) {
                cm.indentSelection("add");
            } else {
                cm.execCommand("insertTab");
            }
        },
        transposeChars: function(cm) {
            return runInOp(cm, function() {
                var ranges = cm.listSelections(), newSel = [];
                for(var i = 0; i < ranges.length; i++){
                    if (!ranges[i].empty()) {
                        continue;
                    }
                    var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
                    if (line) {
                        if (cur.ch == line.length) {
                            cur = new Pos(cur.line, cur.ch - 1);
                        }
                        if (cur.ch > 0) {
                            cur = new Pos(cur.line, cur.ch + 1);
                            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
                        } else if (cur.line > cm.doc.first) {
                            var prev = getLine(cm.doc, cur.line - 1).text;
                            if (prev) {
                                cur = new Pos(cur.line, 1);
                                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
                            }
                        }
                    }
                    newSel.push(new Range(cur, cur));
                }
                cm.setSelections(newSel);
            });
        },
        newlineAndIndent: function(cm) {
            return runInOp(cm, function() {
                var sels = cm.listSelections();
                for(var i = sels.length - 1; i >= 0; i--){
                    cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
                }
                sels = cm.listSelections();
                for(var i$1 = 0; i$1 < sels.length; i$1++){
                    cm.indentLine(sels[i$1].from().line, null, true);
                }
                ensureCursorVisible(cm);
            });
        },
        openLine: function(cm) {
            return cm.replaceSelection("\n", "start");
        },
        toggleOverwrite: function(cm) {
            return cm.toggleOverwrite();
        }
    };
    function lineStart(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLine(line);
        if (visual != line) {
            lineN = lineNo(visual);
        }
        return endOfLine(true, cm, visual, lineN, 1);
    }
    function lineEnd(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLineEnd(line);
        if (visual != line) {
            lineN = lineNo(visual);
        }
        return endOfLine(true, cm, line, lineN, -1);
    }
    function lineStartSmart(cm, pos) {
        var start = lineStart(cm, pos.line);
        var line = getLine(cm.doc, start.line);
        var order = getOrder(line, cm.doc.direction);
        if (!order || order[0].level == 0) {
            var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
            var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
            return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
        }
        return start;
    }
    function doHandleBinding(cm, bound, dropShift) {
        if (typeof bound == "string") {
            bound = commands[bound];
            if (!bound) {
                return false;
            }
        }
        cm.display.input.ensurePolled();
        var prevShift = cm.display.shift, done = false;
        try {
            if (cm.isReadOnly()) {
                cm.state.suppressEdits = true;
            }
            if (dropShift) {
                cm.display.shift = false;
            }
            done = bound(cm) != Pass;
        } finally{
            cm.display.shift = prevShift;
            cm.state.suppressEdits = false;
        }
        return done;
    }
    function lookupKeyForEditor(cm, name, handle) {
        for(var i = 0; i < cm.state.keyMaps.length; i++){
            var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
            if (result) {
                return result;
            }
        }
        return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
    }
    var stopSeq = new Delayed;
    function dispatchKey(cm, name, e, handle) {
        var seq = cm.state.keySeq;
        if (seq) {
            if (isModifierKey(name)) {
                return "handled";
            }
            if (/\'$/.test(name)) {
                cm.state.keySeq = null;
            } else {
                stopSeq.set(50, function() {
                    if (cm.state.keySeq == seq) {
                        cm.state.keySeq = null;
                        cm.display.input.reset();
                    }
                });
            }
            if (dispatchKeyInner(cm, seq + " " + name, e, handle)) {
                return true;
            }
        }
        return dispatchKeyInner(cm, name, e, handle);
    }
    function dispatchKeyInner(cm, name, e, handle) {
        var result = lookupKeyForEditor(cm, name, handle);
        if (result == "multi") {
            cm.state.keySeq = name;
        }
        if (result == "handled") {
            signalLater(cm, "keyHandled", cm, name, e);
        }
        if (result == "handled" || result == "multi") {
            e_preventDefault(e);
            restartBlink(cm);
        }
        return !!result;
    }
    function handleKeyBinding(cm, e) {
        var name = keyName(e, true);
        if (!name) {
            return false;
        }
        if (e.shiftKey && !cm.state.keySeq) {
            return dispatchKey(cm, "Shift-" + name, e, function(b) {
                return doHandleBinding(cm, b, true);
            }) || dispatchKey(cm, name, e, function(b) {
                if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
                    return doHandleBinding(cm, b);
                }
            });
        } else {
            return dispatchKey(cm, name, e, function(b) {
                return doHandleBinding(cm, b);
            });
        }
    }
    function handleCharBinding(cm, e, ch) {
        return dispatchKey(cm, "'" + ch + "'", e, function(b) {
            return doHandleBinding(cm, b, true);
        });
    }
    var lastStoppedKey = null;
    function onKeyDown(e) {
        var cm = this;
        if (e.target && e.target != cm.display.input.getField()) {
            return;
        }
        cm.curOp.focus = activeElt();
        if (signalDOMEvent(cm, e)) {
            return;
        }
        if (ie && ie_version < 11 && e.keyCode == 27) {
            e.returnValue = false;
        }
        var code = e.keyCode;
        cm.display.shift = code == 16 || e.shiftKey;
        var handled = handleKeyBinding(cm, e);
        if (presto) {
            lastStoppedKey = handled ? code : null;
            if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
                cm.replaceSelection("", null, "cut");
            }
        }
        if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {
            document.execCommand("cut");
        }
        if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
            showCrossHair(cm);
        }
    }
    function showCrossHair(cm) {
        var lineDiv = cm.display.lineDiv;
        addClass(lineDiv, "CodeMirror-crosshair");
        function up(e) {
            if (e.keyCode == 18 || !e.altKey) {
                rmClass(lineDiv, "CodeMirror-crosshair");
                off(document, "keyup", up);
                off(document, "mouseover", up);
            }
        }
        on(document, "keyup", up);
        on(document, "mouseover", up);
    }
    function onKeyUp(e) {
        if (e.keyCode == 16) {
            this.doc.sel.shift = false;
        }
        signalDOMEvent(this, e);
    }
    function onKeyPress(e) {
        var cm = this;
        if (e.target && e.target != cm.display.input.getField()) {
            return;
        }
        if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
            return;
        }
        var keyCode = e.keyCode, charCode = e.charCode;
        if (presto && keyCode == lastStoppedKey) {
            lastStoppedKey = null;
            e_preventDefault(e);
            return;
        }
        if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
            return;
        }
        var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
        if (ch == "\x08") {
            return;
        }
        if (handleCharBinding(cm, e, ch)) {
            return;
        }
        cm.display.input.onKeyPress(e);
    }
    var DOUBLECLICK_DELAY = 400;
    var PastClick = function(time, pos, button) {
        this.time = time;
        this.pos = pos;
        this.button = button;
    };
    PastClick.prototype.compare = function(time, pos, button) {
        return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
    };
    var lastClick, lastDoubleClick;
    function clickRepeat(pos, button) {
        var now = +new Date;
        if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
            lastClick = lastDoubleClick = null;
            return "triple";
        } else if (lastClick && lastClick.compare(now, pos, button)) {
            lastDoubleClick = new PastClick(now, pos, button);
            lastClick = null;
            return "double";
        } else {
            lastClick = new PastClick(now, pos, button);
            lastDoubleClick = null;
            return "single";
        }
    }
    function onMouseDown(e) {
        var cm = this, display = cm.display;
        if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
            return;
        }
        display.input.ensurePolled();
        display.shift = e.shiftKey;
        if (eventInWidget(display, e)) {
            if (!webkit) {
                display.scroller.draggable = false;
                setTimeout(function() {
                    return display.scroller.draggable = true;
                }, 100);
            }
            return;
        }
        if (clickInGutter(cm, e)) {
            return;
        }
        var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
        window.focus();
        if (button == 1 && cm.state.selectingText) {
            cm.state.selectingText(e);
        }
        if (pos && handleMappedButton(cm, button, pos, repeat, e)) {
            return;
        }
        if (button == 1) {
            if (pos) {
                leftButtonDown(cm, pos, repeat, e);
            } else if (e_target(e) == display.scroller) {
                e_preventDefault(e);
            }
        } else if (button == 2) {
            if (pos) {
                extendSelection(cm.doc, pos);
            }
            setTimeout(function() {
                return display.input.focus();
            }, 20);
        } else if (button == 3) {
            if (captureRightClick) {
                cm.display.input.onContextMenu(e);
            } else {
                delayBlurEvent(cm);
            }
        }
    }
    function handleMappedButton(cm, button, pos, repeat, event) {
        var name = "Click";
        if (repeat == "double") {
            name = "Double" + name;
        } else if (repeat == "triple") {
            name = "Triple" + name;
        }
        name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
        return dispatchKey(cm, addModifierNames(name, event), event, function(bound) {
            if (typeof bound == "string") {
                bound = commands[bound];
            }
            if (!bound) {
                return false;
            }
            var done = false;
            try {
                if (cm.isReadOnly()) {
                    cm.state.suppressEdits = true;
                }
                done = bound(cm, pos) != Pass;
            } finally{
                cm.state.suppressEdits = false;
            }
            return done;
        });
    }
    function configureMouse(cm, repeat, event) {
        var option = cm.getOption("configureMouse");
        var value = option ? option(cm, repeat, event) : {
        };
        if (value.unit == null) {
            var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
            value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
        }
        if (value.extend == null || cm.doc.extend) {
            value.extend = cm.doc.extend || event.shiftKey;
        }
        if (value.addNew == null) {
            value.addNew = mac ? event.metaKey : event.ctrlKey;
        }
        if (value.moveOnDrag == null) {
            value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
        }
        return value;
    }
    function leftButtonDown(cm, pos, repeat, event) {
        if (ie) {
            setTimeout(bind(ensureFocus, cm), 0);
        } else {
            cm.curOp.focus = activeElt();
        }
        var behavior = configureMouse(cm, repeat, event);
        var sel = cm.doc.sel, contained;
        if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
            leftButtonStartDrag(cm, event, pos, behavior);
        } else {
            leftButtonSelect(cm, event, pos, behavior);
        }
    }
    function leftButtonStartDrag(cm, event, pos, behavior) {
        var display = cm.display, moved = false;
        var dragEnd = operation(cm, function(e) {
            if (webkit) {
                display.scroller.draggable = false;
            }
            cm.state.draggingText = false;
            if (cm.state.delayingBlurEvent) {
                if (cm.hasFocus()) {
                    cm.state.delayingBlurEvent = false;
                } else {
                    delayBlurEvent(cm);
                }
            }
            off(display.wrapper.ownerDocument, "mouseup", dragEnd);
            off(display.wrapper.ownerDocument, "mousemove", mouseMove);
            off(display.scroller, "dragstart", dragStart);
            off(display.scroller, "drop", dragEnd);
            if (!moved) {
                e_preventDefault(e);
                if (!behavior.addNew) {
                    extendSelection(cm.doc, pos, null, null, behavior.extend);
                }
                if (webkit && !safari || ie && ie_version == 9) {
                    setTimeout(function() {
                        display.wrapper.ownerDocument.body.focus({
                            preventScroll: true
                        });
                        display.input.focus();
                    }, 20);
                } else {
                    display.input.focus();
                }
            }
        });
        var mouseMove = function(e2) {
            moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
        };
        var dragStart = function() {
            return moved = true;
        };
        if (webkit) {
            display.scroller.draggable = true;
        }
        cm.state.draggingText = dragEnd;
        dragEnd.copy = !behavior.moveOnDrag;
        on(display.wrapper.ownerDocument, "mouseup", dragEnd);
        on(display.wrapper.ownerDocument, "mousemove", mouseMove);
        on(display.scroller, "dragstart", dragStart);
        on(display.scroller, "drop", dragEnd);
        cm.state.delayingBlurEvent = true;
        setTimeout(function() {
            return display.input.focus();
        }, 20);
        if (display.scroller.dragDrop) {
            display.scroller.dragDrop();
        }
    }
    function rangeForUnit(cm, pos, unit) {
        if (unit == "char") {
            return new Range(pos, pos);
        }
        if (unit == "word") {
            return cm.findWordAt(pos);
        }
        if (unit == "line") {
            return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
        }
        var result = unit(cm, pos);
        return new Range(result.from, result.to);
    }
    function leftButtonSelect(cm, event, start, behavior) {
        if (ie) {
            delayBlurEvent(cm);
        }
        var display = cm.display, doc = cm.doc;
        e_preventDefault(event);
        var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
        if (behavior.addNew && !behavior.extend) {
            ourIndex = doc.sel.contains(start);
            if (ourIndex > -1) {
                ourRange = ranges[ourIndex];
            } else {
                ourRange = new Range(start, start);
            }
        } else {
            ourRange = doc.sel.primary();
            ourIndex = doc.sel.primIndex;
        }
        if (behavior.unit == "rectangle") {
            if (!behavior.addNew) {
                ourRange = new Range(start, start);
            }
            start = posFromMouse(cm, event, true, true);
            ourIndex = -1;
        } else {
            var range = rangeForUnit(cm, start, behavior.unit);
            if (behavior.extend) {
                ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend);
            } else {
                ourRange = range;
            }
        }
        if (!behavior.addNew) {
            ourIndex = 0;
            setSelection(doc, new Selection([
                ourRange
            ], 0), sel_mouse);
            startSel = doc.sel;
        } else if (ourIndex == -1) {
            ourIndex = ranges.length;
            setSelection(doc, normalizeSelection(cm, ranges.concat([
                ourRange
            ]), ourIndex), {
                scroll: false,
                origin: "*mouse"
            });
        } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
            setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {
                scroll: false,
                origin: "*mouse"
            });
            startSel = doc.sel;
        } else {
            replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
        }
        var lastPos = start;
        function extendTo(pos) {
            if (cmp(lastPos, pos) == 0) {
                return;
            }
            lastPos = pos;
            if (behavior.unit == "rectangle") {
                var ranges = [], tabSize = cm.options.tabSize;
                var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
                var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
                var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
                for(var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++){
                    var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
                    if (left == right) {
                        ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
                    } else if (text.length > leftPos) {
                        ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
                    }
                }
                if (!ranges.length) {
                    ranges.push(new Range(start, start));
                }
                setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
                    origin: "*mouse",
                    scroll: false
                });
                cm.scrollIntoView(pos);
            } else {
                var oldRange = ourRange;
                var range = rangeForUnit(cm, pos, behavior.unit);
                var anchor = oldRange.anchor, head;
                if (cmp(range.anchor, anchor) > 0) {
                    head = range.head;
                    anchor = minPos(oldRange.from(), range.anchor);
                } else {
                    head = range.anchor;
                    anchor = maxPos(oldRange.to(), range.head);
                }
                var ranges$1 = startSel.ranges.slice(0);
                ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
                setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
            }
        }
        var editorSize = display.wrapper.getBoundingClientRect();
        var counter = 0;
        function extend(e) {
            var curCount = ++counter;
            var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
            if (!cur) {
                return;
            }
            if (cmp(cur, lastPos) != 0) {
                cm.curOp.focus = activeElt();
                extendTo(cur);
                var visible = visibleLines(display, doc);
                if (cur.line >= visible.to || cur.line < visible.from) {
                    setTimeout(operation(cm, function() {
                        if (counter == curCount) {
                            extend(e);
                        }
                    }), 150);
                }
            } else {
                var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
                if (outside) {
                    setTimeout(operation(cm, function() {
                        if (counter != curCount) {
                            return;
                        }
                        display.scroller.scrollTop += outside;
                        extend(e);
                    }), 50);
                }
            }
        }
        function done(e) {
            cm.state.selectingText = false;
            counter = Infinity;
            if (e) {
                e_preventDefault(e);
                display.input.focus();
            }
            off(display.wrapper.ownerDocument, "mousemove", move);
            off(display.wrapper.ownerDocument, "mouseup", up);
            doc.history.lastSelOrigin = null;
        }
        var move = operation(cm, function(e) {
            if (e.buttons === 0 || !e_button(e)) {
                done(e);
            } else {
                extend(e);
            }
        });
        var up = operation(cm, done);
        cm.state.selectingText = up;
        on(display.wrapper.ownerDocument, "mousemove", move);
        on(display.wrapper.ownerDocument, "mouseup", up);
    }
    function bidiSimplify(cm, range) {
        var anchor = range.anchor;
        var head = range.head;
        var anchorLine = getLine(cm.doc, anchor.line);
        if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
            return range;
        }
        var order = getOrder(anchorLine);
        if (!order) {
            return range;
        }
        var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
        if (part.from != anchor.ch && part.to != anchor.ch) {
            return range;
        }
        var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
        if (boundary == 0 || boundary == order.length) {
            return range;
        }
        var leftSide;
        if (head.line != anchor.line) {
            leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
        } else {
            var headIndex = getBidiPartAt(order, head.ch, head.sticky);
            var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
            if (headIndex == boundary - 1 || headIndex == boundary) {
                leftSide = dir < 0;
            } else {
                leftSide = dir > 0;
            }
        }
        var usePart = order[boundary + (leftSide ? -1 : 0)];
        var from = leftSide == (usePart.level == 1);
        var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
        return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head);
    }
    function gutterEvent(cm, e, type, prevent) {
        var mX, mY;
        if (e.touches) {
            mX = e.touches[0].clientX;
            mY = e.touches[0].clientY;
        } else {
            try {
                mX = e.clientX;
                mY = e.clientY;
            } catch (e$1) {
                return false;
            }
        }
        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
            return false;
        }
        if (prevent) {
            e_preventDefault(e);
        }
        var display = cm.display;
        var lineBox = display.lineDiv.getBoundingClientRect();
        if (mY > lineBox.bottom || !hasHandler(cm, type)) {
            return e_defaultPrevented(e);
        }
        mY -= lineBox.top - display.viewOffset;
        for(var i = 0; i < cm.display.gutterSpecs.length; ++i){
            var g = display.gutters.childNodes[i];
            if (g && g.getBoundingClientRect().right >= mX) {
                var line = lineAtHeight(cm.doc, mY);
                var gutter = cm.display.gutterSpecs[i];
                signal(cm, type, cm, line, gutter.className, e);
                return e_defaultPrevented(e);
            }
        }
    }
    function clickInGutter(cm, e) {
        return gutterEvent(cm, e, "gutterClick", true);
    }
    function onContextMenu(cm, e) {
        if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
            return;
        }
        if (signalDOMEvent(cm, e, "contextmenu")) {
            return;
        }
        if (!captureRightClick) {
            cm.display.input.onContextMenu(e);
        }
    }
    function contextMenuInGutter(cm, e) {
        if (!hasHandler(cm, "gutterContextMenu")) {
            return false;
        }
        return gutterEvent(cm, e, "gutterContextMenu", false);
    }
    function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
        clearCaches(cm);
    }
    var Init = {
        toString: function() {
            return "CodeMirror.Init";
        }
    };
    var defaults = {
    };
    var optionHandlers = {
    };
    function defineOptions(CodeMirror) {
        var optionHandlers = CodeMirror.optionHandlers;
        function option(name, deflt, handle, notOnInit) {
            CodeMirror.defaults[name] = deflt;
            if (handle) {
                optionHandlers[name] = notOnInit ? function(cm, val, old) {
                    if (old != Init) {
                        handle(cm, val, old);
                    }
                } : handle;
            }
        }
        CodeMirror.defineOption = option;
        CodeMirror.Init = Init;
        option("value", "", function(cm, val) {
            return cm.setValue(val);
        }, true);
        option("mode", null, function(cm, val) {
            cm.doc.modeOption = val;
            loadMode(cm);
        }, true);
        option("indentUnit", 2, loadMode, true);
        option("indentWithTabs", false);
        option("smartIndent", true);
        option("tabSize", 4, function(cm) {
            resetModeState(cm);
            clearCaches(cm);
            regChange(cm);
        }, true);
        option("lineSeparator", null, function(cm, val) {
            cm.doc.lineSep = val;
            if (!val) {
                return;
            }
            var newBreaks = [], lineNo = cm.doc.first;
            cm.doc.iter(function(line) {
                for(var pos = 0;;){
                    var found = line.text.indexOf(val, pos);
                    if (found == -1) {
                        break;
                    }
                    pos = found + val.length;
                    newBreaks.push(Pos(lineNo, found));
                }
                lineNo++;
            });
            for(var i = newBreaks.length - 1; i >= 0; i--){
                replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
            }
        });
        option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function(cm, val, old) {
            cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
            if (old != Init) {
                cm.refresh();
            }
        });
        option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
            return cm.refresh();
        }, true);
        option("electricChars", true);
        option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
            throw new Error("inputStyle can not (yet) be changed in a running editor");
        }, true);
        option("spellcheck", false, function(cm, val) {
            return cm.getInputField().spellcheck = val;
        }, true);
        option("autocorrect", false, function(cm, val) {
            return cm.getInputField().autocorrect = val;
        }, true);
        option("autocapitalize", false, function(cm, val) {
            return cm.getInputField().autocapitalize = val;
        }, true);
        option("rtlMoveVisually", !windows);
        option("wholeLineUpdateBefore", true);
        option("theme", "default", function(cm) {
            themeChanged(cm);
            updateGutters(cm);
        }, true);
        option("keyMap", "default", function(cm, val, old) {
            var next = getKeyMap(val);
            var prev = old != Init && getKeyMap(old);
            if (prev && prev.detach) {
                prev.detach(cm, next);
            }
            if (next.attach) {
                next.attach(cm, prev || null);
            }
        });
        option("extraKeys", null);
        option("configureMouse", null);
        option("lineWrapping", false, wrappingChanged, true);
        option("gutters", [], function(cm, val) {
            cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
            updateGutters(cm);
        }, true);
        option("fixedGutter", true, function(cm, val) {
            cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
            cm.refresh();
        }, true);
        option("coverGutterNextToScrollbar", false, function(cm) {
            return updateScrollbars(cm);
        }, true);
        option("scrollbarStyle", "native", function(cm) {
            initScrollbars(cm);
            updateScrollbars(cm);
            cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
            cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
        }, true);
        option("lineNumbers", false, function(cm, val) {
            cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
            updateGutters(cm);
        }, true);
        option("firstLineNumber", 1, updateGutters, true);
        option("lineNumberFormatter", function(integer) {
            return integer;
        }, updateGutters, true);
        option("showCursorWhenSelecting", false, updateSelection, true);
        option("resetSelectionOnContextMenu", true);
        option("lineWiseCopyCut", true);
        option("pasteLinesPerSelection", true);
        option("selectionsMayTouch", false);
        option("readOnly", false, function(cm, val) {
            if (val == "nocursor") {
                onBlur(cm);
                cm.display.input.blur();
            }
            cm.display.input.readOnlyChanged(val);
        });
        option("screenReaderLabel", null, function(cm, val) {
            val = val === '' ? null : val;
            cm.display.input.screenReaderLabelChanged(val);
        });
        option("disableInput", false, function(cm, val) {
            if (!val) {
                cm.display.input.reset();
            }
        }, true);
        option("dragDrop", true, dragDropChanged);
        option("allowDropFileTypes", null);
        option("cursorBlinkRate", 530);
        option("cursorScrollMargin", 0);
        option("cursorHeight", 1, updateSelection, true);
        option("singleCursorHeightPerLine", true, updateSelection, true);
        option("workTime", 100);
        option("workDelay", 100);
        option("flattenSpans", true, resetModeState, true);
        option("addModeClass", false, resetModeState, true);
        option("pollInterval", 100);
        option("undoDepth", 200, function(cm, val) {
            return cm.doc.history.undoDepth = val;
        });
        option("historyEventDelay", 1250);
        option("viewportMargin", 10, function(cm) {
            return cm.refresh();
        }, true);
        option("maxHighlightLength", 10000, resetModeState, true);
        option("moveInputWithCursor", true, function(cm, val) {
            if (!val) {
                cm.display.input.resetPosition();
            }
        });
        option("tabindex", null, function(cm, val) {
            return cm.display.input.getField().tabIndex = val || "";
        });
        option("autofocus", null);
        option("direction", "ltr", function(cm, val) {
            return cm.doc.setDirection(val);
        }, true);
        option("phrases", null);
    }
    function dragDropChanged(cm, value, old) {
        var wasOn = old && old != Init;
        if (!value != !wasOn) {
            var funcs = cm.display.dragFunctions;
            var toggle = value ? on : off;
            toggle(cm.display.scroller, "dragstart", funcs.start);
            toggle(cm.display.scroller, "dragenter", funcs.enter);
            toggle(cm.display.scroller, "dragover", funcs.over);
            toggle(cm.display.scroller, "dragleave", funcs.leave);
            toggle(cm.display.scroller, "drop", funcs.drop);
        }
    }
    function wrappingChanged(cm) {
        if (cm.options.lineWrapping) {
            addClass(cm.display.wrapper, "CodeMirror-wrap");
            cm.display.sizer.style.minWidth = "";
            cm.display.sizerWidth = null;
        } else {
            rmClass(cm.display.wrapper, "CodeMirror-wrap");
            findMaxLine(cm);
        }
        estimateLineHeights(cm);
        regChange(cm);
        clearCaches(cm);
        setTimeout(function() {
            return updateScrollbars(cm);
        }, 100);
    }
    function CodeMirror(place, options) {
        var this$1 = this;
        if (!(this instanceof CodeMirror)) {
            return new CodeMirror(place, options);
        }
        this.options = options = options ? copyObj(options) : {
        };
        copyObj(defaults, options, false);
        var doc = options.value;
        if (typeof doc == "string") {
            doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);
        } else if (options.mode) {
            doc.modeOption = options.mode;
        }
        this.doc = doc;
        var input = new CodeMirror.inputStyles[options.inputStyle](this);
        var display = this.display = new Display(place, doc, input, options);
        display.wrapper.CodeMirror = this;
        themeChanged(this);
        if (options.lineWrapping) {
            this.display.wrapper.className += " CodeMirror-wrap";
        }
        initScrollbars(this);
        this.state = {
            keyMaps: [],
            overlays: [],
            modeGen: 0,
            overwrite: false,
            delayingBlurEvent: false,
            focused: false,
            suppressEdits: false,
            pasteIncoming: -1,
            cutIncoming: -1,
            selectingText: false,
            draggingText: false,
            highlight: new Delayed(),
            keySeq: null,
            specialChars: null
        };
        if (options.autofocus && !mobile) {
            display.input.focus();
        }
        if (ie && ie_version < 11) {
            setTimeout(function() {
                return this$1.display.input.reset(true);
            }, 20);
        }
        registerEventHandlers(this);
        ensureGlobalHandlers();
        startOperation(this);
        this.curOp.forceUpdate = true;
        attachDoc(this, doc);
        if (options.autofocus && !mobile || this.hasFocus()) {
            setTimeout(function() {
                if (this$1.hasFocus() && !this$1.state.focused) {
                    onFocus(this$1);
                }
            }, 20);
        } else {
            onBlur(this);
        }
        for(var opt in optionHandlers){
            if (optionHandlers.hasOwnProperty(opt)) {
                optionHandlers[opt](this, options[opt], Init);
            }
        }
        maybeUpdateLineNumberWidth(this);
        if (options.finishInit) {
            options.finishInit(this);
        }
        for(var i = 0; i < initHooks.length; ++i){
            initHooks[i](this);
        }
        endOperation(this);
        if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
            display.lineDiv.style.textRendering = "auto";
        }
    }
    CodeMirror.defaults = defaults;
    CodeMirror.optionHandlers = optionHandlers;
    function registerEventHandlers(cm) {
        var d = cm.display;
        on(d.scroller, "mousedown", operation(cm, onMouseDown));
        if (ie && ie_version < 11) {
            on(d.scroller, "dblclick", operation(cm, function(e) {
                if (signalDOMEvent(cm, e)) {
                    return;
                }
                var pos = posFromMouse(cm, e);
                if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
                    return;
                }
                e_preventDefault(e);
                var word = cm.findWordAt(pos);
                extendSelection(cm.doc, word.anchor, word.head);
            }));
        } else {
            on(d.scroller, "dblclick", function(e) {
                return signalDOMEvent(cm, e) || e_preventDefault(e);
            });
        }
        on(d.scroller, "contextmenu", function(e) {
            return onContextMenu(cm, e);
        });
        on(d.input.getField(), "contextmenu", function(e) {
            if (!d.scroller.contains(e.target)) {
                onContextMenu(cm, e);
            }
        });
        var touchFinished, prevTouch = {
            end: 0
        };
        function finishTouch() {
            if (d.activeTouch) {
                touchFinished = setTimeout(function() {
                    return d.activeTouch = null;
                }, 1000);
                prevTouch = d.activeTouch;
                prevTouch.end = +new Date;
            }
        }
        function isMouseLikeTouchEvent(e) {
            if (e.touches.length != 1) {
                return false;
            }
            var touch = e.touches[0];
            return touch.radiusX <= 1 && touch.radiusY <= 1;
        }
        function farAway(touch, other) {
            if (other.left == null) {
                return true;
            }
            var dx = other.left - touch.left, dy = other.top - touch.top;
            return dx * dx + dy * dy > 20 * 20;
        }
        on(d.scroller, "touchstart", function(e) {
            if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
                d.input.ensurePolled();
                clearTimeout(touchFinished);
                var now = +new Date;
                d.activeTouch = {
                    start: now,
                    moved: false,
                    prev: now - prevTouch.end <= 300 ? prevTouch : null
                };
                if (e.touches.length == 1) {
                    d.activeTouch.left = e.touches[0].pageX;
                    d.activeTouch.top = e.touches[0].pageY;
                }
            }
        });
        on(d.scroller, "touchmove", function() {
            if (d.activeTouch) {
                d.activeTouch.moved = true;
            }
        });
        on(d.scroller, "touchend", function(e) {
            var touch = d.activeTouch;
            if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date - touch.start < 300) {
                var pos = cm.coordsChar(d.activeTouch, "page"), range;
                if (!touch.prev || farAway(touch, touch.prev)) {
                    range = new Range(pos, pos);
                } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
                    range = cm.findWordAt(pos);
                } else {
                    range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
                }
                cm.setSelection(range.anchor, range.head);
                cm.focus();
                e_preventDefault(e);
            }
            finishTouch();
        });
        on(d.scroller, "touchcancel", finishTouch);
        on(d.scroller, "scroll", function() {
            if (d.scroller.clientHeight) {
                updateScrollTop(cm, d.scroller.scrollTop);
                setScrollLeft(cm, d.scroller.scrollLeft, true);
                signal(cm, "scroll", cm);
            }
        });
        on(d.scroller, "mousewheel", function(e) {
            return onScrollWheel(cm, e);
        });
        on(d.scroller, "DOMMouseScroll", function(e) {
            return onScrollWheel(cm, e);
        });
        on(d.wrapper, "scroll", function() {
            return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
        });
        d.dragFunctions = {
            enter: function(e) {
                if (!signalDOMEvent(cm, e)) {
                    e_stop(e);
                }
            },
            over: function(e) {
                if (!signalDOMEvent(cm, e)) {
                    onDragOver(cm, e);
                    e_stop(e);
                }
            },
            start: function(e) {
                return onDragStart(cm, e);
            },
            drop: operation(cm, onDrop),
            leave: function(e) {
                if (!signalDOMEvent(cm, e)) {
                    clearDragCursor(cm);
                }
            }
        };
        var inp = d.input.getField();
        on(inp, "keyup", function(e) {
            return onKeyUp.call(cm, e);
        });
        on(inp, "keydown", operation(cm, onKeyDown));
        on(inp, "keypress", operation(cm, onKeyPress));
        on(inp, "focus", function(e) {
            return onFocus(cm, e);
        });
        on(inp, "blur", function(e) {
            return onBlur(cm, e);
        });
    }
    var initHooks = [];
    CodeMirror.defineInitHook = function(f) {
        return initHooks.push(f);
    };
    function indentLine(cm, n, how, aggressive) {
        var doc = cm.doc, state;
        if (how == null) {
            how = "add";
        }
        if (how == "smart") {
            if (!doc.mode.indent) {
                how = "prev";
            } else {
                state = getContextBefore(cm, n).state;
            }
        }
        var tabSize = cm.options.tabSize;
        var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
        if (line.stateAfter) {
            line.stateAfter = null;
        }
        var curSpaceString = line.text.match(/^\s*/)[0], indentation;
        if (!aggressive && !/\S/.test(line.text)) {
            indentation = 0;
            how = "not";
        } else if (how == "smart") {
            indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
            if (indentation == Pass || indentation > 150) {
                if (!aggressive) {
                    return;
                }
                how = "prev";
            }
        }
        if (how == "prev") {
            if (n > doc.first) {
                indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
            } else {
                indentation = 0;
            }
        } else if (how == "add") {
            indentation = curSpace + cm.options.indentUnit;
        } else if (how == "subtract") {
            indentation = curSpace - cm.options.indentUnit;
        } else if (typeof how == "number") {
            indentation = curSpace + how;
        }
        indentation = Math.max(0, indentation);
        var indentString = "", pos = 0;
        if (cm.options.indentWithTabs) {
            for(var i = Math.floor(indentation / tabSize); i; --i){
                pos += tabSize;
                indentString += "\t";
            }
        }
        if (pos < indentation) {
            indentString += spaceStr(indentation - pos);
        }
        if (indentString != curSpaceString) {
            replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
            line.stateAfter = null;
            return true;
        } else {
            for(var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++){
                var range = doc.sel.ranges[i$1];
                if (range.head.line == n && range.head.ch < curSpaceString.length) {
                    var pos$1 = Pos(n, curSpaceString.length);
                    replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
                    break;
                }
            }
        }
    }
    var lastCopied = null;
    function setLastCopied(newLastCopied) {
        lastCopied = newLastCopied;
    }
    function applyTextInput(cm, inserted, deleted, sel, origin) {
        var doc = cm.doc;
        cm.display.shift = false;
        if (!sel) {
            sel = doc.sel;
        }
        var recent = +new Date - 200;
        var paste = origin == "paste" || cm.state.pasteIncoming > recent;
        var textLines = splitLinesAuto(inserted), multiPaste = null;
        if (paste && sel.ranges.length > 1) {
            if (lastCopied && lastCopied.text.join("\n") == inserted) {
                if (sel.ranges.length % lastCopied.text.length == 0) {
                    multiPaste = [];
                    for(var i = 0; i < lastCopied.text.length; i++){
                        multiPaste.push(doc.splitLines(lastCopied.text[i]));
                    }
                }
            } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
                multiPaste = map(textLines, function(l) {
                    return [
                        l
                    ];
                });
            }
        }
        var updateInput = cm.curOp.updateInput;
        for(var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--){
            var range = sel.ranges[i$1];
            var from = range.from(), to = range.to();
            if (range.empty()) {
                if (deleted && deleted > 0) {
                    from = Pos(from.line, from.ch - deleted);
                } else if (cm.state.overwrite && !paste) {
                    to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
                } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n")) {
                    from = to = Pos(from.line, 0);
                }
            }
            var changeEvent = {
                from: from,
                to: to,
                text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
            };
            makeChange(cm.doc, changeEvent);
            signalLater(cm, "inputRead", cm, changeEvent);
        }
        if (inserted && !paste) {
            triggerElectric(cm, inserted);
        }
        ensureCursorVisible(cm);
        if (cm.curOp.updateInput < 2) {
            cm.curOp.updateInput = updateInput;
        }
        cm.curOp.typing = true;
        cm.state.pasteIncoming = cm.state.cutIncoming = -1;
    }
    function handlePaste(e, cm) {
        var pasted = e.clipboardData && e.clipboardData.getData("Text");
        if (pasted) {
            e.preventDefault();
            if (!cm.isReadOnly() && !cm.options.disableInput) {
                runInOp(cm, function() {
                    return applyTextInput(cm, pasted, 0, null, "paste");
                });
            }
            return true;
        }
    }
    function triggerElectric(cm, inserted) {
        if (!cm.options.electricChars || !cm.options.smartIndent) {
            return;
        }
        var sel = cm.doc.sel;
        for(var i = sel.ranges.length - 1; i >= 0; i--){
            var range = sel.ranges[i];
            if (range.head.ch > 100 || i && sel.ranges[i - 1].head.line == range.head.line) {
                continue;
            }
            var mode = cm.getModeAt(range.head);
            var indented = false;
            if (mode.electricChars) {
                for(var j = 0; j < mode.electricChars.length; j++){
                    if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                        indented = indentLine(cm, range.head.line, "smart");
                        break;
                    }
                }
            } else if (mode.electricInput) {
                if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch))) {
                    indented = indentLine(cm, range.head.line, "smart");
                }
            }
            if (indented) {
                signalLater(cm, "electricInput", cm, range.head.line);
            }
        }
    }
    function copyableRanges(cm) {
        var text = [], ranges = [];
        for(var i = 0; i < cm.doc.sel.ranges.length; i++){
            var line = cm.doc.sel.ranges[i].head.line;
            var lineRange = {
                anchor: Pos(line, 0),
                head: Pos(line + 1, 0)
            };
            ranges.push(lineRange);
            text.push(cm.getRange(lineRange.anchor, lineRange.head));
        }
        return {
            text: text,
            ranges: ranges
        };
    }
    function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
        field.setAttribute("autocorrect", autocorrect ? "" : "off");
        field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
        field.setAttribute("spellcheck", !!spellcheck);
    }
    function hiddenTextarea() {
        var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
        var div = elt("div", [
            te
        ], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
        if (webkit) {
            te.style.width = "1000px";
        } else {
            te.setAttribute("wrap", "off");
        }
        if (ios) {
            te.style.border = "1px solid black";
        }
        disableBrowserMagic(te);
        return div;
    }
    function addEditorMethods(CodeMirror) {
        var optionHandlers = CodeMirror.optionHandlers;
        var helpers = CodeMirror.helpers = {
        };
        CodeMirror.prototype = {
            constructor: CodeMirror,
            focus: function() {
                window.focus();
                this.display.input.focus();
            },
            setOption: function(option, value) {
                var options = this.options, old = options[option];
                if (options[option] == value && option != "mode") {
                    return;
                }
                options[option] = value;
                if (optionHandlers.hasOwnProperty(option)) {
                    operation(this, optionHandlers[option])(this, value, old);
                }
                signal(this, "optionChange", this, option);
            },
            getOption: function(option) {
                return this.options[option];
            },
            getDoc: function() {
                return this.doc;
            },
            addKeyMap: function(map, bottom) {
                this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
            },
            removeKeyMap: function(map) {
                var maps = this.state.keyMaps;
                for(var i = 0; i < maps.length; ++i){
                    if (maps[i] == map || maps[i].name == map) {
                        maps.splice(i, 1);
                        return true;
                    }
                }
            },
            addOverlay: methodOp(function(spec, options) {
                var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
                if (mode.startState) {
                    throw new Error("Overlays may not be stateful.");
                }
                insertSorted(this.state.overlays, {
                    mode: mode,
                    modeSpec: spec,
                    opaque: options && options.opaque,
                    priority: options && options.priority || 0
                }, function(overlay) {
                    return overlay.priority;
                });
                this.state.modeGen++;
                regChange(this);
            }),
            removeOverlay: methodOp(function(spec) {
                var overlays = this.state.overlays;
                for(var i = 0; i < overlays.length; ++i){
                    var cur = overlays[i].modeSpec;
                    if (cur == spec || typeof spec == "string" && cur.name == spec) {
                        overlays.splice(i, 1);
                        this.state.modeGen++;
                        regChange(this);
                        return;
                    }
                }
            }),
            indentLine: methodOp(function(n, dir, aggressive) {
                if (typeof dir != "string" && typeof dir != "number") {
                    if (dir == null) {
                        dir = this.options.smartIndent ? "smart" : "prev";
                    } else {
                        dir = dir ? "add" : "subtract";
                    }
                }
                if (isLine(this.doc, n)) {
                    indentLine(this, n, dir, aggressive);
                }
            }),
            indentSelection: methodOp(function(how) {
                var ranges = this.doc.sel.ranges, end = -1;
                for(var i = 0; i < ranges.length; i++){
                    var range = ranges[i];
                    if (!range.empty()) {
                        var from = range.from(), to = range.to();
                        var start = Math.max(end, from.line);
                        end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                        for(var j = start; j < end; ++j){
                            indentLine(this, j, how);
                        }
                        var newRanges = this.doc.sel.ranges;
                        if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0) {
                            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
                        }
                    } else if (range.head.line > end) {
                        indentLine(this, range.head.line, how, true);
                        end = range.head.line;
                        if (i == this.doc.sel.primIndex) {
                            ensureCursorVisible(this);
                        }
                    }
                }
            }),
            getTokenAt: function(pos, precise) {
                return takeToken(this, pos, precise);
            },
            getLineTokens: function(line, precise) {
                return takeToken(this, Pos(line), precise, true);
            },
            getTokenTypeAt: function(pos) {
                pos = clipPos(this.doc, pos);
                var styles = getLineStyles(this, getLine(this.doc, pos.line));
                var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
                var type;
                if (ch == 0) {
                    type = styles[2];
                } else {
                    for(;;){
                        var mid = before + after >> 1;
                        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
                            after = mid;
                        } else if (styles[mid * 2 + 1] < ch) {
                            before = mid + 1;
                        } else {
                            type = styles[mid * 2 + 2];
                            break;
                        }
                    }
                }
                var cut = type ? type.indexOf("overlay ") : -1;
                return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
            },
            getModeAt: function(pos) {
                var mode = this.doc.mode;
                if (!mode.innerMode) {
                    return mode;
                }
                return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
            },
            getHelper: function(pos, type) {
                return this.getHelpers(pos, type)[0];
            },
            getHelpers: function(pos, type) {
                var found = [];
                if (!helpers.hasOwnProperty(type)) {
                    return found;
                }
                var help = helpers[type], mode = this.getModeAt(pos);
                if (typeof mode[type] == "string") {
                    if (help[mode[type]]) {
                        found.push(help[mode[type]]);
                    }
                } else if (mode[type]) {
                    for(var i = 0; i < mode[type].length; i++){
                        var val = help[mode[type][i]];
                        if (val) {
                            found.push(val);
                        }
                    }
                } else if (mode.helperType && help[mode.helperType]) {
                    found.push(help[mode.helperType]);
                } else if (help[mode.name]) {
                    found.push(help[mode.name]);
                }
                for(var i$1 = 0; i$1 < help._global.length; i$1++){
                    var cur = help._global[i$1];
                    if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {
                        found.push(cur.val);
                    }
                }
                return found;
            },
            getStateAfter: function(line, precise) {
                var doc = this.doc;
                line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
                return getContextBefore(this, line + 1, precise).state;
            },
            cursorCoords: function(start, mode) {
                var pos, range = this.doc.sel.primary();
                if (start == null) {
                    pos = range.head;
                } else if (typeof start == "object") {
                    pos = clipPos(this.doc, start);
                } else {
                    pos = start ? range.from() : range.to();
                }
                return cursorCoords(this, pos, mode || "page");
            },
            charCoords: function(pos, mode) {
                return charCoords(this, clipPos(this.doc, pos), mode || "page");
            },
            coordsChar: function(coords, mode) {
                coords = fromCoordSystem(this, coords, mode || "page");
                return coordsChar(this, coords.left, coords.top);
            },
            lineAtHeight: function(height, mode) {
                height = fromCoordSystem(this, {
                    top: height,
                    left: 0
                }, mode || "page").top;
                return lineAtHeight(this.doc, height + this.display.viewOffset);
            },
            heightAtLine: function(line, mode, includeWidgets) {
                var end = false, lineObj;
                if (typeof line == "number") {
                    var last = this.doc.first + this.doc.size - 1;
                    if (line < this.doc.first) {
                        line = this.doc.first;
                    } else if (line > last) {
                        line = last;
                        end = true;
                    }
                    lineObj = getLine(this.doc, line);
                } else {
                    lineObj = line;
                }
                return intoCoordSystem(this, lineObj, {
                    top: 0,
                    left: 0
                }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
            },
            defaultTextHeight: function() {
                return textHeight(this.display);
            },
            defaultCharWidth: function() {
                return charWidth(this.display);
            },
            getViewport: function() {
                return {
                    from: this.display.viewFrom,
                    to: this.display.viewTo
                };
            },
            addWidget: function(pos, node, scroll, vert, horiz) {
                var display = this.display;
                pos = cursorCoords(this, clipPos(this.doc, pos));
                var top = pos.bottom, left = pos.left;
                node.style.position = "absolute";
                node.setAttribute("cm-ignore-events", "true");
                this.display.input.setUneditable(node);
                display.sizer.appendChild(node);
                if (vert == "over") {
                    top = pos.top;
                } else if (vert == "above" || vert == "near") {
                    var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                    if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
                        top = pos.top - node.offsetHeight;
                    } else if (pos.bottom + node.offsetHeight <= vspace) {
                        top = pos.bottom;
                    }
                    if (left + node.offsetWidth > hspace) {
                        left = hspace - node.offsetWidth;
                    }
                }
                node.style.top = top + "px";
                node.style.left = node.style.right = "";
                if (horiz == "right") {
                    left = display.sizer.clientWidth - node.offsetWidth;
                    node.style.right = "0px";
                } else {
                    if (horiz == "left") {
                        left = 0;
                    } else if (horiz == "middle") {
                        left = (display.sizer.clientWidth - node.offsetWidth) / 2;
                    }
                    node.style.left = left + "px";
                }
                if (scroll) {
                    scrollIntoView(this, {
                        left: left,
                        top: top,
                        right: left + node.offsetWidth,
                        bottom: top + node.offsetHeight
                    });
                }
            },
            triggerOnKeyDown: methodOp(onKeyDown),
            triggerOnKeyPress: methodOp(onKeyPress),
            triggerOnKeyUp: onKeyUp,
            triggerOnMouseDown: methodOp(onMouseDown),
            execCommand: function(cmd) {
                if (commands.hasOwnProperty(cmd)) {
                    return commands[cmd].call(null, this);
                }
            },
            triggerElectric: methodOp(function(text) {
                triggerElectric(this, text);
            }),
            findPosH: function(from, amount, unit, visually) {
                var dir = 1;
                if (amount < 0) {
                    dir = -1;
                    amount = -amount;
                }
                var cur = clipPos(this.doc, from);
                for(var i = 0; i < amount; ++i){
                    cur = findPosH(this.doc, cur, dir, unit, visually);
                    if (cur.hitSide) {
                        break;
                    }
                }
                return cur;
            },
            moveH: methodOp(function(dir, unit) {
                var this$1 = this;
                this.extendSelectionsBy(function(range) {
                    if (this$1.display.shift || this$1.doc.extend || range.empty()) {
                        return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually);
                    } else {
                        return dir < 0 ? range.from() : range.to();
                    }
                }, sel_move);
            }),
            deleteH: methodOp(function(dir, unit) {
                var sel = this.doc.sel, doc = this.doc;
                if (sel.somethingSelected()) {
                    doc.replaceSelection("", null, "+delete");
                } else {
                    deleteNearSelection(this, function(range) {
                        var other = findPosH(doc, range.head, dir, unit, false);
                        return dir < 0 ? {
                            from: other,
                            to: range.head
                        } : {
                            from: range.head,
                            to: other
                        };
                    });
                }
            }),
            findPosV: function(from, amount, unit, goalColumn) {
                var dir = 1, x = goalColumn;
                if (amount < 0) {
                    dir = -1;
                    amount = -amount;
                }
                var cur = clipPos(this.doc, from);
                for(var i = 0; i < amount; ++i){
                    var coords = cursorCoords(this, cur, "div");
                    if (x == null) {
                        x = coords.left;
                    } else {
                        coords.left = x;
                    }
                    cur = findPosV(this, coords, dir, unit);
                    if (cur.hitSide) {
                        break;
                    }
                }
                return cur;
            },
            moveV: methodOp(function(dir, unit) {
                var this$1 = this;
                var doc = this.doc, goals = [];
                var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
                doc.extendSelectionsBy(function(range) {
                    if (collapse) {
                        return dir < 0 ? range.from() : range.to();
                    }
                    var headPos = cursorCoords(this$1, range.head, "div");
                    if (range.goalColumn != null) {
                        headPos.left = range.goalColumn;
                    }
                    goals.push(headPos.left);
                    var pos = findPosV(this$1, headPos, dir, unit);
                    if (unit == "page" && range == doc.sel.primary()) {
                        addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top);
                    }
                    return pos;
                }, sel_move);
                if (goals.length) {
                    for(var i = 0; i < doc.sel.ranges.length; i++){
                        doc.sel.ranges[i].goalColumn = goals[i];
                    }
                }
            }),
            findWordAt: function(pos) {
                var doc = this.doc, line = getLine(doc, pos.line).text;
                var start = pos.ch, end = pos.ch;
                if (line) {
                    var helper = this.getHelper(pos, "wordChars");
                    if ((pos.sticky == "before" || end == line.length) && start) {
                        --start;
                    } else {
                        ++end;
                    }
                    var startChar = line.charAt(start);
                    var check = isWordChar(startChar, helper) ? function(ch) {
                        return isWordChar(ch, helper);
                    } : /\s/.test(startChar) ? function(ch) {
                        return /\s/.test(ch);
                    } : function(ch) {
                        return !/\s/.test(ch) && !isWordChar(ch);
                    };
                    while(start > 0 && check(line.charAt(start - 1))){
                        --start;
                    }
                    while(end < line.length && check(line.charAt(end))){
                        ++end;
                    }
                }
                return new Range(Pos(pos.line, start), Pos(pos.line, end));
            },
            toggleOverwrite: function(value) {
                if (value != null && value == this.state.overwrite) {
                    return;
                }
                if (this.state.overwrite = !this.state.overwrite) {
                    addClass(this.display.cursorDiv, "CodeMirror-overwrite");
                } else {
                    rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
                }
                signal(this, "overwriteToggle", this, this.state.overwrite);
            },
            hasFocus: function() {
                return this.display.input.getField() == activeElt();
            },
            isReadOnly: function() {
                return !!(this.options.readOnly || this.doc.cantEdit);
            },
            scrollTo: methodOp(function(x, y) {
                scrollToCoords(this, x, y);
            }),
            getScrollInfo: function() {
                var scroller = this.display.scroller;
                return {
                    left: scroller.scrollLeft,
                    top: scroller.scrollTop,
                    height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                    width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                    clientHeight: displayHeight(this),
                    clientWidth: displayWidth(this)
                };
            },
            scrollIntoView: methodOp(function(range, margin) {
                if (range == null) {
                    range = {
                        from: this.doc.sel.primary().head,
                        to: null
                    };
                    if (margin == null) {
                        margin = this.options.cursorScrollMargin;
                    }
                } else if (typeof range == "number") {
                    range = {
                        from: Pos(range, 0),
                        to: null
                    };
                } else if (range.from == null) {
                    range = {
                        from: range,
                        to: null
                    };
                }
                if (!range.to) {
                    range.to = range.from;
                }
                range.margin = margin || 0;
                if (range.from.line != null) {
                    scrollToRange(this, range);
                } else {
                    scrollToCoordsRange(this, range.from, range.to, range.margin);
                }
            }),
            setSize: methodOp(function(width, height) {
                var this$1 = this;
                var interpret = function(val) {
                    return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
                };
                if (width != null) {
                    this.display.wrapper.style.width = interpret(width);
                }
                if (height != null) {
                    this.display.wrapper.style.height = interpret(height);
                }
                if (this.options.lineWrapping) {
                    clearLineMeasurementCache(this);
                }
                var lineNo = this.display.viewFrom;
                this.doc.iter(lineNo, this.display.viewTo, function(line) {
                    if (line.widgets) {
                        for(var i = 0; i < line.widgets.length; i++){
                            if (line.widgets[i].noHScroll) {
                                regLineChange(this$1, lineNo, "widget");
                                break;
                            }
                        }
                    }
                    ++lineNo;
                });
                this.curOp.forceUpdate = true;
                signal(this, "refresh", this);
            }),
            operation: function(f) {
                return runInOp(this, f);
            },
            startOperation: function() {
                return startOperation(this);
            },
            endOperation: function() {
                return endOperation(this);
            },
            refresh: methodOp(function() {
                var oldHeight = this.display.cachedTextHeight;
                regChange(this);
                this.curOp.forceUpdate = true;
                clearCaches(this);
                scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
                updateGutterSpace(this.display);
                if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {
                    estimateLineHeights(this);
                }
                signal(this, "refresh", this);
            }),
            swapDoc: methodOp(function(doc) {
                var old = this.doc;
                old.cm = null;
                if (this.state.selectingText) {
                    this.state.selectingText();
                }
                attachDoc(this, doc);
                clearCaches(this);
                this.display.input.reset();
                scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
                this.curOp.forceScroll = true;
                signalLater(this, "swapDoc", this, old);
                return old;
            }),
            phrase: function(phraseText) {
                var phrases = this.options.phrases;
                return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
            },
            getInputField: function() {
                return this.display.input.getField();
            },
            getWrapperElement: function() {
                return this.display.wrapper;
            },
            getScrollerElement: function() {
                return this.display.scroller;
            },
            getGutterElement: function() {
                return this.display.gutters;
            }
        };
        eventMixin(CodeMirror);
        CodeMirror.registerHelper = function(type, name, value) {
            if (!helpers.hasOwnProperty(type)) {
                helpers[type] = CodeMirror[type] = {
                    _global: []
                };
            }
            helpers[type][name] = value;
        };
        CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
            CodeMirror.registerHelper(type, name, value);
            helpers[type]._global.push({
                pred: predicate,
                val: value
            });
        };
    }
    function findPosH(doc, pos, dir, unit, visually) {
        var oldPos = pos;
        var origDir = dir;
        var lineObj = getLine(doc, pos.line);
        var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
        function findNextLine() {
            var l = pos.line + lineDir;
            if (l < doc.first || l >= doc.first + doc.size) {
                return false;
            }
            pos = new Pos(l, pos.ch, pos.sticky);
            return lineObj = getLine(doc, l);
        }
        function moveOnce(boundToLine) {
            var next;
            if (unit == "codepoint") {
                var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
                if (isNaN(ch)) {
                    next = null;
                } else {
                    var astral = dir > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;
                    next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
                }
            } else if (visually) {
                next = moveVisually(doc.cm, lineObj, pos, dir);
            } else {
                next = moveLogically(lineObj, pos, dir);
            }
            if (next == null) {
                if (!boundToLine && findNextLine()) {
                    pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);
                } else {
                    return false;
                }
            } else {
                pos = next;
            }
            return true;
        }
        if (unit == "char" || unit == "codepoint") {
            moveOnce();
        } else if (unit == "column") {
            moveOnce(true);
        } else if (unit == "word" || unit == "group") {
            var sawType = null, group = unit == "group";
            var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
            for(var first = true;; first = false){
                if (dir < 0 && !moveOnce(!first)) {
                    break;
                }
                var cur = lineObj.text.charAt(pos.ch) || "\n";
                var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
                if (group && !first && !type) {
                    type = "s";
                }
                if (sawType && sawType != type) {
                    if (dir < 0) {
                        dir = 1;
                        moveOnce();
                        pos.sticky = "after";
                    }
                    break;
                }
                if (type) {
                    sawType = type;
                }
                if (dir > 0 && !moveOnce(!first)) {
                    break;
                }
            }
        }
        var result = skipAtomic(doc, pos, oldPos, origDir, true);
        if (equalCursorPos(oldPos, result)) {
            result.hitSide = true;
        }
        return result;
    }
    function findPosV(cm, pos, dir, unit) {
        var doc = cm.doc, x = pos.left, y;
        if (unit == "page") {
            var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
            var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);
            y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
        } else if (unit == "line") {
            y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
        }
        var target;
        for(;;){
            target = coordsChar(cm, x, y);
            if (!target.outside) {
                break;
            }
            if (dir < 0 ? y <= 0 : y >= doc.height) {
                target.hitSide = true;
                break;
            }
            y += dir * 5;
        }
        return target;
    }
    var ContentEditableInput = function(cm) {
        this.cm = cm;
        this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
        this.polling = new Delayed();
        this.composing = null;
        this.gracePeriod = false;
        this.readDOMTimeout = null;
    };
    ContentEditableInput.prototype.init = function(display) {
        var this$1 = this;
        var input = this, cm = input.cm;
        var div = input.div = display.lineDiv;
        div.contentEditable = true;
        disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
        function belongsToInput(e) {
            for(var t = e.target; t; t = t.parentNode){
                if (t == div) {
                    return true;
                }
                if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) {
                    break;
                }
            }
            return false;
        }
        on(div, "paste", function(e) {
            if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {
                return;
            }
            if (ie_version <= 11) {
                setTimeout(operation(cm, function() {
                    return this$1.updateFromDOM();
                }), 20);
            }
        });
        on(div, "compositionstart", function(e) {
            this$1.composing = {
                data: e.data,
                done: false
            };
        });
        on(div, "compositionupdate", function(e) {
            if (!this$1.composing) {
                this$1.composing = {
                    data: e.data,
                    done: false
                };
            }
        });
        on(div, "compositionend", function(e) {
            if (this$1.composing) {
                if (e.data != this$1.composing.data) {
                    this$1.readFromDOMSoon();
                }
                this$1.composing.done = true;
            }
        });
        on(div, "touchstart", function() {
            return input.forceCompositionEnd();
        });
        on(div, "input", function() {
            if (!this$1.composing) {
                this$1.readFromDOMSoon();
            }
        });
        function onCopyCut(e) {
            if (!belongsToInput(e) || signalDOMEvent(cm, e)) {
                return;
            }
            if (cm.somethingSelected()) {
                setLastCopied({
                    lineWise: false,
                    text: cm.getSelections()
                });
                if (e.type == "cut") {
                    cm.replaceSelection("", null, "cut");
                }
            } else if (!cm.options.lineWiseCopyCut) {
                return;
            } else {
                var ranges = copyableRanges(cm);
                setLastCopied({
                    lineWise: true,
                    text: ranges.text
                });
                if (e.type == "cut") {
                    cm.operation(function() {
                        cm.setSelections(ranges.ranges, 0, sel_dontScroll);
                        cm.replaceSelection("", null, "cut");
                    });
                }
            }
            if (e.clipboardData) {
                e.clipboardData.clearData();
                var content = lastCopied.text.join("\n");
                e.clipboardData.setData("Text", content);
                if (e.clipboardData.getData("Text") == content) {
                    e.preventDefault();
                    return;
                }
            }
            var kludge = hiddenTextarea(), te = kludge.firstChild;
            cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
            te.value = lastCopied.text.join("\n");
            var hadFocus = activeElt();
            selectInput(te);
            setTimeout(function() {
                cm.display.lineSpace.removeChild(kludge);
                hadFocus.focus();
                if (hadFocus == div) {
                    input.showPrimarySelection();
                }
            }, 50);
        }
        on(div, "copy", onCopyCut);
        on(div, "cut", onCopyCut);
    };
    ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {
        if (label) {
            this.div.setAttribute('aria-label', label);
        } else {
            this.div.removeAttribute('aria-label');
        }
    };
    ContentEditableInput.prototype.prepareSelection = function() {
        var result = prepareSelection(this.cm, false);
        result.focus = activeElt() == this.div;
        return result;
    };
    ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
        if (!info || !this.cm.display.view.length) {
            return;
        }
        if (info.focus || takeFocus) {
            this.showPrimarySelection();
        }
        this.showMultipleSelections(info);
    };
    ContentEditableInput.prototype.getSelection = function() {
        return this.cm.display.wrapper.ownerDocument.getSelection();
    };
    ContentEditableInput.prototype.showPrimarySelection = function() {
        var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
        var from = prim.from(), to = prim.to();
        if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
            sel.removeAllRanges();
            return;
        }
        var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
        if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
            return;
        }
        var view = cm.display.view;
        var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {
            node: view[0].measure.map[2],
            offset: 0
        };
        var end = to.line < cm.display.viewTo && posToDOM(cm, to);
        if (!end) {
            var measure = view[view.length - 1].measure;
            var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
            end = {
                node: map[map.length - 1],
                offset: map[map.length - 2] - map[map.length - 3]
            };
        }
        if (!start || !end) {
            sel.removeAllRanges();
            return;
        }
        var old = sel.rangeCount && sel.getRangeAt(0), rng;
        try {
            rng = range(start.node, start.offset, end.offset, end.node);
        } catch (e) {
        }
        if (rng) {
            if (!gecko && cm.state.focused) {
                sel.collapse(start.node, start.offset);
                if (!rng.collapsed) {
                    sel.removeAllRanges();
                    sel.addRange(rng);
                }
            } else {
                sel.removeAllRanges();
                sel.addRange(rng);
            }
            if (old && sel.anchorNode == null) {
                sel.addRange(old);
            } else if (gecko) {
                this.startGracePeriod();
            }
        }
        this.rememberSelection();
    };
    ContentEditableInput.prototype.startGracePeriod = function() {
        var this$1 = this;
        clearTimeout(this.gracePeriod);
        this.gracePeriod = setTimeout(function() {
            this$1.gracePeriod = false;
            if (this$1.selectionChanged()) {
                this$1.cm.operation(function() {
                    return this$1.cm.curOp.selectionChanged = true;
                });
            }
        }, 20);
    };
    ContentEditableInput.prototype.showMultipleSelections = function(info) {
        removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
        removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
    };
    ContentEditableInput.prototype.rememberSelection = function() {
        var sel = this.getSelection();
        this.lastAnchorNode = sel.anchorNode;
        this.lastAnchorOffset = sel.anchorOffset;
        this.lastFocusNode = sel.focusNode;
        this.lastFocusOffset = sel.focusOffset;
    };
    ContentEditableInput.prototype.selectionInEditor = function() {
        var sel = this.getSelection();
        if (!sel.rangeCount) {
            return false;
        }
        var node = sel.getRangeAt(0).commonAncestorContainer;
        return contains(this.div, node);
    };
    ContentEditableInput.prototype.focus = function() {
        if (this.cm.options.readOnly != "nocursor") {
            if (!this.selectionInEditor() || activeElt() != this.div) {
                this.showSelection(this.prepareSelection(), true);
            }
            this.div.focus();
        }
    };
    ContentEditableInput.prototype.blur = function() {
        this.div.blur();
    };
    ContentEditableInput.prototype.getField = function() {
        return this.div;
    };
    ContentEditableInput.prototype.supportsTouch = function() {
        return true;
    };
    ContentEditableInput.prototype.receivedFocus = function() {
        var input = this;
        if (this.selectionInEditor()) {
            this.pollSelection();
        } else {
            runInOp(this.cm, function() {
                return input.cm.curOp.selectionChanged = true;
            });
        }
        function poll() {
            if (input.cm.state.focused) {
                input.pollSelection();
                input.polling.set(input.cm.options.pollInterval, poll);
            }
        }
        this.polling.set(this.cm.options.pollInterval, poll);
    };
    ContentEditableInput.prototype.selectionChanged = function() {
        var sel = this.getSelection();
        return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
    };
    ContentEditableInput.prototype.pollSelection = function() {
        if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
            return;
        }
        var sel = this.getSelection(), cm = this.cm;
        if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
            this.cm.triggerOnKeyDown({
                type: "keydown",
                keyCode: 8,
                preventDefault: Math.abs
            });
            this.blur();
            this.focus();
            return;
        }
        if (this.composing) {
            return;
        }
        this.rememberSelection();
        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var head = domToPos(cm, sel.focusNode, sel.focusOffset);
        if (anchor && head) {
            runInOp(cm, function() {
                setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
                if (anchor.bad || head.bad) {
                    cm.curOp.selectionChanged = true;
                }
            });
        }
    };
    ContentEditableInput.prototype.pollContent = function() {
        if (this.readDOMTimeout != null) {
            clearTimeout(this.readDOMTimeout);
            this.readDOMTimeout = null;
        }
        var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
        var from = sel.from(), to = sel.to();
        if (from.ch == 0 && from.line > cm.firstLine()) {
            from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
        }
        if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
            to = Pos(to.line + 1, 0);
        }
        if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
            return false;
        }
        var fromIndex, fromLine, fromNode;
        if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
            fromLine = lineNo(display.view[0].line);
            fromNode = display.view[0].node;
        } else {
            fromLine = lineNo(display.view[fromIndex].line);
            fromNode = display.view[fromIndex - 1].node.nextSibling;
        }
        var toIndex = findViewIndex(cm, to.line);
        var toLine, toNode;
        if (toIndex == display.view.length - 1) {
            toLine = display.viewTo - 1;
            toNode = display.lineDiv.lastChild;
        } else {
            toLine = lineNo(display.view[toIndex + 1].line) - 1;
            toNode = display.view[toIndex + 1].node.previousSibling;
        }
        if (!fromNode) {
            return false;
        }
        var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
        var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
        while(newText.length > 1 && oldText.length > 1){
            if (lst(newText) == lst(oldText)) {
                newText.pop();
                oldText.pop();
                toLine--;
            } else if (newText[0] == oldText[0]) {
                newText.shift();
                oldText.shift();
                fromLine++;
            } else {
                break;
            }
        }
        var cutFront = 0, cutEnd = 0;
        var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
        while(cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)){
            ++cutFront;
        }
        var newBot = lst(newText), oldBot = lst(oldText);
        var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
        while(cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)){
            ++cutEnd;
        }
        if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
            while(cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)){
                cutFront--;
                cutEnd++;
            }
        }
        newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
        newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
        var chFrom = Pos(fromLine, cutFront);
        var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
        if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
            replaceRange(cm.doc, newText, chFrom, chTo, "+input");
            return true;
        }
    };
    ContentEditableInput.prototype.ensurePolled = function() {
        this.forceCompositionEnd();
    };
    ContentEditableInput.prototype.reset = function() {
        this.forceCompositionEnd();
    };
    ContentEditableInput.prototype.forceCompositionEnd = function() {
        if (!this.composing) {
            return;
        }
        clearTimeout(this.readDOMTimeout);
        this.composing = null;
        this.updateFromDOM();
        this.div.blur();
        this.div.focus();
    };
    ContentEditableInput.prototype.readFromDOMSoon = function() {
        var this$1 = this;
        if (this.readDOMTimeout != null) {
            return;
        }
        this.readDOMTimeout = setTimeout(function() {
            this$1.readDOMTimeout = null;
            if (this$1.composing) {
                if (this$1.composing.done) {
                    this$1.composing = null;
                } else {
                    return;
                }
            }
            this$1.updateFromDOM();
        }, 80);
    };
    ContentEditableInput.prototype.updateFromDOM = function() {
        var this$1 = this;
        if (this.cm.isReadOnly() || !this.pollContent()) {
            runInOp(this.cm, function() {
                return regChange(this$1.cm);
            });
        }
    };
    ContentEditableInput.prototype.setUneditable = function(node) {
        node.contentEditable = "false";
    };
    ContentEditableInput.prototype.onKeyPress = function(e) {
        if (e.charCode == 0 || this.composing) {
            return;
        }
        e.preventDefault();
        if (!this.cm.isReadOnly()) {
            operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
        }
    };
    ContentEditableInput.prototype.readOnlyChanged = function(val) {
        this.div.contentEditable = String(val != "nocursor");
    };
    ContentEditableInput.prototype.onContextMenu = function() {
    };
    ContentEditableInput.prototype.resetPosition = function() {
    };
    ContentEditableInput.prototype.needsContentAttribute = true;
    function posToDOM(cm, pos) {
        var view = findViewForLine(cm, pos.line);
        if (!view || view.hidden) {
            return null;
        }
        var line = getLine(cm.doc, pos.line);
        var info = mapFromLineView(view, line, pos.line);
        var order = getOrder(line, cm.doc.direction), side = "left";
        if (order) {
            var partPos = getBidiPartAt(order, pos.ch);
            side = partPos % 2 ? "right" : "left";
        }
        var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
        result.offset = result.collapse == "right" ? result.end : result.start;
        return result;
    }
    function isInGutter(node) {
        for(var scan = node; scan; scan = scan.parentNode){
            if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
                return true;
            }
        }
        return false;
    }
    function badPos(pos, bad) {
        if (bad) {
            pos.bad = true;
        }
        return pos;
    }
    function domTextBetween(cm, from, to, fromLine, toLine) {
        var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
        function recognizeMarker(id) {
            return function(marker) {
                return marker.id == id;
            };
        }
        function close() {
            if (closing) {
                text += lineSep;
                if (extraLinebreak) {
                    text += lineSep;
                }
                closing = extraLinebreak = false;
            }
        }
        function addText(str) {
            if (str) {
                close();
                text += str;
            }
        }
        function walk(node) {
            if (node.nodeType == 1) {
                var cmText = node.getAttribute("cm-text");
                if (cmText) {
                    addText(cmText);
                    return;
                }
                var markerID = node.getAttribute("cm-marker"), range;
                if (markerID) {
                    var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
                    if (found.length && (range = found[0].find(0))) {
                        addText(getBetween(cm.doc, range.from, range.to).join(lineSep));
                    }
                    return;
                }
                if (node.getAttribute("contenteditable") == "false") {
                    return;
                }
                var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
                if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
                    return;
                }
                if (isBlock) {
                    close();
                }
                for(var i = 0; i < node.childNodes.length; i++){
                    walk(node.childNodes[i]);
                }
                if (/^(pre|p)$/i.test(node.nodeName)) {
                    extraLinebreak = true;
                }
                if (isBlock) {
                    closing = true;
                }
            } else if (node.nodeType == 3) {
                addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
            }
        }
        for(;;){
            walk(from);
            if (from == to) {
                break;
            }
            from = from.nextSibling;
            extraLinebreak = false;
        }
        return text;
    }
    function domToPos(cm, node, offset) {
        var lineNode;
        if (node == cm.display.lineDiv) {
            lineNode = cm.display.lineDiv.childNodes[offset];
            if (!lineNode) {
                return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
            }
            node = null;
            offset = 0;
        } else {
            for(lineNode = node;; lineNode = lineNode.parentNode){
                if (!lineNode || lineNode == cm.display.lineDiv) {
                    return null;
                }
                if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
                    break;
                }
            }
        }
        for(var i = 0; i < cm.display.view.length; i++){
            var lineView = cm.display.view[i];
            if (lineView.node == lineNode) {
                return locateNodeInLineView(lineView, node, offset);
            }
        }
    }
    function locateNodeInLineView(lineView, node, offset) {
        var wrapper = lineView.text.firstChild, bad = false;
        if (!node || !contains(wrapper, node)) {
            return badPos(Pos(lineNo(lineView.line), 0), true);
        }
        if (node == wrapper) {
            bad = true;
            node = wrapper.childNodes[offset];
            offset = 0;
            if (!node) {
                var line = lineView.rest ? lst(lineView.rest) : lineView.line;
                return badPos(Pos(lineNo(line), line.text.length), bad);
            }
        }
        var textNode = node.nodeType == 3 ? node : null, topNode = node;
        if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
            textNode = node.firstChild;
            if (offset) {
                offset = textNode.nodeValue.length;
            }
        }
        while(topNode.parentNode != wrapper){
            topNode = topNode.parentNode;
        }
        var measure = lineView.measure, maps = measure.maps;
        function find(textNode, topNode, offset) {
            for(var i = -1; i < (maps ? maps.length : 0); i++){
                var map = i < 0 ? measure.map : maps[i];
                for(var j = 0; j < map.length; j += 3){
                    var curNode = map[j + 2];
                    if (curNode == textNode || curNode == topNode) {
                        var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
                        var ch = map[j] + offset;
                        if (offset < 0 || curNode != textNode) {
                            ch = map[j + (offset ? 1 : 0)];
                        }
                        return Pos(line, ch);
                    }
                }
            }
        }
        var found = find(textNode, topNode, offset);
        if (found) {
            return badPos(found, bad);
        }
        for(var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling){
            found = find(after, after.firstChild, 0);
            if (found) {
                return badPos(Pos(found.line, found.ch - dist), bad);
            } else {
                dist += after.textContent.length;
            }
        }
        for(var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling){
            found = find(before, before.firstChild, -1);
            if (found) {
                return badPos(Pos(found.line, found.ch + dist$1), bad);
            } else {
                dist$1 += before.textContent.length;
            }
        }
    }
    var TextareaInput = function(cm) {
        this.cm = cm;
        this.prevInput = "";
        this.pollingFast = false;
        this.polling = new Delayed();
        this.hasSelection = false;
        this.composing = null;
    };
    TextareaInput.prototype.init = function(display) {
        var this$1 = this;
        var input = this, cm = this.cm;
        this.createField(display);
        var te = this.textarea;
        display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
        if (ios) {
            te.style.width = "0px";
        }
        on(te, "input", function() {
            if (ie && ie_version >= 9 && this$1.hasSelection) {
                this$1.hasSelection = null;
            }
            input.poll();
        });
        on(te, "paste", function(e) {
            if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
                return;
            }
            cm.state.pasteIncoming = +new Date;
            input.fastPoll();
        });
        function prepareCopyCut(e) {
            if (signalDOMEvent(cm, e)) {
                return;
            }
            if (cm.somethingSelected()) {
                setLastCopied({
                    lineWise: false,
                    text: cm.getSelections()
                });
            } else if (!cm.options.lineWiseCopyCut) {
                return;
            } else {
                var ranges = copyableRanges(cm);
                setLastCopied({
                    lineWise: true,
                    text: ranges.text
                });
                if (e.type == "cut") {
                    cm.setSelections(ranges.ranges, null, sel_dontScroll);
                } else {
                    input.prevInput = "";
                    te.value = ranges.text.join("\n");
                    selectInput(te);
                }
            }
            if (e.type == "cut") {
                cm.state.cutIncoming = +new Date;
            }
        }
        on(te, "cut", prepareCopyCut);
        on(te, "copy", prepareCopyCut);
        on(display.scroller, "paste", function(e) {
            if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
                return;
            }
            if (!te.dispatchEvent) {
                cm.state.pasteIncoming = +new Date;
                input.focus();
                return;
            }
            var event = new Event("paste");
            event.clipboardData = e.clipboardData;
            te.dispatchEvent(event);
        });
        on(display.lineSpace, "selectstart", function(e) {
            if (!eventInWidget(display, e)) {
                e_preventDefault(e);
            }
        });
        on(te, "compositionstart", function() {
            var start = cm.getCursor("from");
            if (input.composing) {
                input.composing.range.clear();
            }
            input.composing = {
                start: start,
                range: cm.markText(start, cm.getCursor("to"), {
                    className: "CodeMirror-composing"
                })
            };
        });
        on(te, "compositionend", function() {
            if (input.composing) {
                input.poll();
                input.composing.range.clear();
                input.composing = null;
            }
        });
    };
    TextareaInput.prototype.createField = function(_display) {
        this.wrapper = hiddenTextarea();
        this.textarea = this.wrapper.firstChild;
    };
    TextareaInput.prototype.screenReaderLabelChanged = function(label) {
        if (label) {
            this.textarea.setAttribute('aria-label', label);
        } else {
            this.textarea.removeAttribute('aria-label');
        }
    };
    TextareaInput.prototype.prepareSelection = function() {
        var cm = this.cm, display = cm.display, doc = cm.doc;
        var result = prepareSelection(cm);
        if (cm.options.moveInputWithCursor) {
            var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
            var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
            result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
            result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
        }
        return result;
    };
    TextareaInput.prototype.showSelection = function(drawn) {
        var cm = this.cm, display = cm.display;
        removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
        removeChildrenAndAdd(display.selectionDiv, drawn.selection);
        if (drawn.teTop != null) {
            this.wrapper.style.top = drawn.teTop + "px";
            this.wrapper.style.left = drawn.teLeft + "px";
        }
    };
    TextareaInput.prototype.reset = function(typing) {
        if (this.contextMenuPending || this.composing) {
            return;
        }
        var cm = this.cm;
        if (cm.somethingSelected()) {
            this.prevInput = "";
            var content = cm.getSelection();
            this.textarea.value = content;
            if (cm.state.focused) {
                selectInput(this.textarea);
            }
            if (ie && ie_version >= 9) {
                this.hasSelection = content;
            }
        } else if (!typing) {
            this.prevInput = this.textarea.value = "";
            if (ie && ie_version >= 9) {
                this.hasSelection = null;
            }
        }
    };
    TextareaInput.prototype.getField = function() {
        return this.textarea;
    };
    TextareaInput.prototype.supportsTouch = function() {
        return false;
    };
    TextareaInput.prototype.focus = function() {
        if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
            try {
                this.textarea.focus();
            } catch (e) {
            }
        }
    };
    TextareaInput.prototype.blur = function() {
        this.textarea.blur();
    };
    TextareaInput.prototype.resetPosition = function() {
        this.wrapper.style.top = this.wrapper.style.left = 0;
    };
    TextareaInput.prototype.receivedFocus = function() {
        this.slowPoll();
    };
    TextareaInput.prototype.slowPoll = function() {
        var this$1 = this;
        if (this.pollingFast) {
            return;
        }
        this.polling.set(this.cm.options.pollInterval, function() {
            this$1.poll();
            if (this$1.cm.state.focused) {
                this$1.slowPoll();
            }
        });
    };
    TextareaInput.prototype.fastPoll = function() {
        var missed = false, input = this;
        input.pollingFast = true;
        function p() {
            var changed = input.poll();
            if (!changed && !missed) {
                missed = true;
                input.polling.set(60, p);
            } else {
                input.pollingFast = false;
                input.slowPoll();
            }
        }
        input.polling.set(20, p);
    };
    TextareaInput.prototype.poll = function() {
        var this$1 = this;
        var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
        if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
            return false;
        }
        var text = input.value;
        if (text == prevInput && !cm.somethingSelected()) {
            return false;
        }
        if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
            cm.display.input.reset();
            return false;
        }
        if (cm.doc.sel == cm.display.selForContextMenu) {
            var first = text.charCodeAt(0);
            if (first == 8203 && !prevInput) {
                prevInput = "\u200b";
            }
            if (first == 8666) {
                this.reset();
                return this.cm.execCommand("undo");
            }
        }
        var same = 0, l = Math.min(prevInput.length, text.length);
        while(same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)){
            ++same;
        }
        runInOp(cm, function() {
            applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null);
            if (text.length > 1000 || text.indexOf("\n") > -1) {
                input.value = this$1.prevInput = "";
            } else {
                this$1.prevInput = text;
            }
            if (this$1.composing) {
                this$1.composing.range.clear();
                this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), {
                    className: "CodeMirror-composing"
                });
            }
        });
        return true;
    };
    TextareaInput.prototype.ensurePolled = function() {
        if (this.pollingFast && this.poll()) {
            this.pollingFast = false;
        }
    };
    TextareaInput.prototype.onKeyPress = function() {
        if (ie && ie_version >= 9) {
            this.hasSelection = null;
        }
        this.fastPoll();
    };
    TextareaInput.prototype.onContextMenu = function(e) {
        var input = this, cm = input.cm, display = cm.display, te = input.textarea;
        if (input.contextMenuPending) {
            input.contextMenuPending();
        }
        var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
        if (!pos || presto) {
            return;
        }
        var reset = cm.options.resetSelectionOnContextMenu;
        if (reset && cm.doc.sel.contains(pos) == -1) {
            operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
        }
        var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
        var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
        input.wrapper.style.cssText = "position: static";
        te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
        var oldScrollY;
        if (webkit) {
            oldScrollY = window.scrollY;
        }
        display.input.focus();
        if (webkit) {
            window.scrollTo(null, oldScrollY);
        }
        display.input.reset();
        if (!cm.somethingSelected()) {
            te.value = input.prevInput = " ";
        }
        input.contextMenuPending = rehide;
        display.selForContextMenu = cm.doc.sel;
        clearTimeout(display.detectingSelectAll);
        function prepareSelectAllHack() {
            if (te.selectionStart != null) {
                var selected = cm.somethingSelected();
                var extval = "\u200b" + (selected ? te.value : "");
                te.value = "\u21da";
                te.value = extval;
                input.prevInput = selected ? "" : "\u200b";
                te.selectionStart = 1;
                te.selectionEnd = extval.length;
                display.selForContextMenu = cm.doc.sel;
            }
        }
        function rehide() {
            if (input.contextMenuPending != rehide) {
                return;
            }
            input.contextMenuPending = false;
            input.wrapper.style.cssText = oldWrapperCSS;
            te.style.cssText = oldCSS;
            if (ie && ie_version < 9) {
                display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
            }
            if (te.selectionStart != null) {
                if (!ie || ie && ie_version < 9) {
                    prepareSelectAllHack();
                }
                var i = 0, poll = function() {
                    if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200b") {
                        operation(cm, selectAll)(cm);
                    } else if (i++ < 10) {
                        display.detectingSelectAll = setTimeout(poll, 500);
                    } else {
                        display.selForContextMenu = null;
                        display.input.reset();
                    }
                };
                display.detectingSelectAll = setTimeout(poll, 200);
            }
        }
        if (ie && ie_version >= 9) {
            prepareSelectAllHack();
        }
        if (captureRightClick) {
            e_stop(e);
            var mouseup = function() {
                off(window, "mouseup", mouseup);
                setTimeout(rehide, 20);
            };
            on(window, "mouseup", mouseup);
        } else {
            setTimeout(rehide, 50);
        }
    };
    TextareaInput.prototype.readOnlyChanged = function(val) {
        if (!val) {
            this.reset();
        }
        this.textarea.disabled = val == "nocursor";
        this.textarea.readOnly = !!val;
    };
    TextareaInput.prototype.setUneditable = function() {
    };
    TextareaInput.prototype.needsContentAttribute = false;
    function fromTextArea(textarea, options) {
        options = options ? copyObj(options) : {
        };
        options.value = textarea.value;
        if (!options.tabindex && textarea.tabIndex) {
            options.tabindex = textarea.tabIndex;
        }
        if (!options.placeholder && textarea.placeholder) {
            options.placeholder = textarea.placeholder;
        }
        if (options.autofocus == null) {
            var hasFocus = activeElt();
            options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
        }
        function save() {
            textarea.value = cm.getValue();
        }
        var realSubmit;
        if (textarea.form) {
            on(textarea.form, "submit", save);
            if (!options.leaveSubmitMethodAlone) {
                var form = textarea.form;
                realSubmit = form.submit;
                try {
                    var wrappedSubmit = form.submit = function() {
                        save();
                        form.submit = realSubmit;
                        form.submit();
                        form.submit = wrappedSubmit;
                    };
                } catch (e) {
                }
            }
        }
        options.finishInit = function(cm) {
            cm.save = save;
            cm.getTextArea = function() {
                return textarea;
            };
            cm.toTextArea = function() {
                cm.toTextArea = isNaN;
                save();
                textarea.parentNode.removeChild(cm.getWrapperElement());
                textarea.style.display = "";
                if (textarea.form) {
                    off(textarea.form, "submit", save);
                    if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
                        textarea.form.submit = realSubmit;
                    }
                }
            };
        };
        textarea.style.display = "none";
        var cm = CodeMirror(function(node) {
            return textarea.parentNode.insertBefore(node, textarea.nextSibling);
        }, options);
        return cm;
    }
    function addLegacyProps(CodeMirror) {
        CodeMirror.off = off;
        CodeMirror.on = on;
        CodeMirror.wheelEventPixels = wheelEventPixels;
        CodeMirror.Doc = Doc;
        CodeMirror.splitLines = splitLinesAuto;
        CodeMirror.countColumn = countColumn;
        CodeMirror.findColumn = findColumn;
        CodeMirror.isWordChar = isWordCharBasic;
        CodeMirror.Pass = Pass;
        CodeMirror.signal = signal;
        CodeMirror.Line = Line;
        CodeMirror.changeEnd = changeEnd;
        CodeMirror.scrollbarModel = scrollbarModel;
        CodeMirror.Pos = Pos;
        CodeMirror.cmpPos = cmp;
        CodeMirror.modes = modes;
        CodeMirror.mimeModes = mimeModes;
        CodeMirror.resolveMode = resolveMode;
        CodeMirror.getMode = getMode;
        CodeMirror.modeExtensions = modeExtensions;
        CodeMirror.extendMode = extendMode;
        CodeMirror.copyState = copyState;
        CodeMirror.startState = startState;
        CodeMirror.innerMode = innerMode;
        CodeMirror.commands = commands;
        CodeMirror.keyMap = keyMap;
        CodeMirror.keyName = keyName;
        CodeMirror.isModifierKey = isModifierKey;
        CodeMirror.lookupKey = lookupKey;
        CodeMirror.normalizeKeyMap = normalizeKeyMap;
        CodeMirror.StringStream = StringStream;
        CodeMirror.SharedTextMarker = SharedTextMarker;
        CodeMirror.TextMarker = TextMarker;
        CodeMirror.LineWidget = LineWidget;
        CodeMirror.e_preventDefault = e_preventDefault;
        CodeMirror.e_stopPropagation = e_stopPropagation;
        CodeMirror.e_stop = e_stop;
        CodeMirror.addClass = addClass;
        CodeMirror.contains = contains;
        CodeMirror.rmClass = rmClass;
        CodeMirror.keyNames = keyNames;
    }
    defineOptions(CodeMirror);
    addEditorMethods(CodeMirror);
    var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
    for(var prop in Doc.prototype){
        if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
            CodeMirror.prototype[prop] = (function(method) {
                return function() {
                    return method.apply(this.doc, arguments);
                };
            })(Doc.prototype[prop]);
        }
    }
    eventMixin(Doc);
    CodeMirror.inputStyles = {
        "textarea": TextareaInput,
        "contenteditable": ContentEditableInput
    };
    CodeMirror.defineMode = function(name) {
        if (!CodeMirror.defaults.mode && name != "null") {
            CodeMirror.defaults.mode = name;
        }
        defineMode.apply(this, arguments);
    };
    CodeMirror.defineMIME = defineMIME;
    CodeMirror.defineMode("null", function() {
        return {
            token: function(stream) {
                return stream.skipToEnd();
            }
        };
    });
    CodeMirror.defineMIME("text/plain", "null");
    CodeMirror.defineExtension = function(name, func) {
        CodeMirror.prototype[name] = func;
    };
    CodeMirror.defineDocExtension = function(name, func) {
        Doc.prototype[name] = func;
    };
    CodeMirror.fromTextArea = fromTextArea;
    addLegacyProps(CodeMirror);
    CodeMirror.version = "5.62.3";
    return CodeMirror;
});
(function(mod) {
    if (typeof exports == "object" && typeof module == "object") mod(require("../../lib/codemirror"));
    else if (typeof define == "function" && define.amd) define([
        "../../lib/codemirror"
    ], mod);
    else mod(CodeMirror);
})(function(CodeMirror) {
    "use strict";
    CodeMirror.defineMode("sql", function(config, parserConfig) {
        var client = parserConfig.client || {
        }, atoms = parserConfig.atoms || {
            "false": true,
            "true": true,
            "null": true
        }, builtin = parserConfig.builtin || set(defaultBuiltin), keywords = parserConfig.keywords || set(sqlKeywords), operatorChars = parserConfig.operatorChars || /^[*+\-%<>!=&|~^\/]/, support = parserConfig.support || {
        }, hooks = parserConfig.hooks || {
        }, dateSQL = parserConfig.dateSQL || {
            "date": true,
            "time": true,
            "timestamp": true
        }, backslashStringEscapes = parserConfig.backslashStringEscapes !== false, brackets = parserConfig.brackets || /^[\{}\(\)\[\]]/, punctuation = parserConfig.punctuation || /^[;.,:]/;
        function tokenBase(stream, state) {
            var ch = stream.next();
            if (hooks[ch]) {
                var result = hooks[ch](stream, state);
                if (result !== false) return result;
            }
            if (support.hexNumber && (ch == "0" && stream.match(/^[xX][0-9a-fA-F]+/) || (ch == "x" || ch == "X") && stream.match(/^'[0-9a-fA-F]+'/))) {
                return "number";
            } else if (support.binaryNumber && ((ch == "b" || ch == "B") && stream.match(/^'[01]+'/) || ch == "0" && stream.match(/^b[01]+/))) {
                return "number";
            } else if (ch.charCodeAt(0) > 47 && ch.charCodeAt(0) < 58) {
                stream.match(/^[0-9]*(\.[0-9]+)?([eE][-+]?[0-9]+)?/);
                support.decimallessFloat && stream.match(/^\.(?!\.)/);
                return "number";
            } else if (ch == "?" && (stream.eatSpace() || stream.eol() || stream.eat(";"))) {
                return "variable-3";
            } else if (ch == "'" || ch == '"' && support.doubleQuote) {
                state.tokenize = tokenLiteral(ch);
                return state.tokenize(stream, state);
            } else if ((support.nCharCast && (ch == "n" || ch == "N") || support.charsetCast && ch == "_" && stream.match(/[a-z][a-z0-9]*/i)) && (stream.peek() == "'" || stream.peek() == '"')) {
                return "keyword";
            } else if (support.escapeConstant && (ch == "e" || ch == "E") && (stream.peek() == "'" || stream.peek() == '"' && support.doubleQuote)) {
                state.tokenize = function(stream, state) {
                    return (state.tokenize = tokenLiteral(stream.next(), true))(stream, state);
                };
                return "keyword";
            } else if (support.commentSlashSlash && ch == "/" && stream.eat("/")) {
                stream.skipToEnd();
                return "comment";
            } else if (support.commentHash && ch == "#" || ch == "-" && stream.eat("-") && (!support.commentSpaceRequired || stream.eat(" "))) {
                stream.skipToEnd();
                return "comment";
            } else if (ch == "/" && stream.eat("*")) {
                state.tokenize = tokenComment(1);
                return state.tokenize(stream, state);
            } else if (ch == ".") {
                if (support.zerolessFloat && stream.match(/^(?:\d+(?:e[+-]?\d+)?)/i)) return "number";
                if (stream.match(/^\.+/)) return null;
                if (support.ODBCdotTable && stream.match(/^[\w\d_$#]+/)) return "variable-2";
            } else if (operatorChars.test(ch)) {
                stream.eatWhile(operatorChars);
                return "operator";
            } else if (brackets.test(ch)) {
                return "bracket";
            } else if (punctuation.test(ch)) {
                stream.eatWhile(punctuation);
                return "punctuation";
            } else if (ch == '{' && (stream.match(/^( )*(d|D|t|T|ts|TS)( )*'[^']*'( )*}/) || stream.match(/^( )*(d|D|t|T|ts|TS)( )*"[^"]*"( )*}/))) {
                return "number";
            } else {
                stream.eatWhile(/^[_\w\d]/);
                var word = stream.current().toLowerCase();
                if (dateSQL.hasOwnProperty(word) && (stream.match(/^( )+'[^']*'/) || stream.match(/^( )+"[^"]*"/))) return "number";
                if (atoms.hasOwnProperty(word)) return "atom";
                if (builtin.hasOwnProperty(word)) return "builtin";
                if (keywords.hasOwnProperty(word)) return "keyword";
                if (client.hasOwnProperty(word)) return "string-2";
                return null;
            }
        }
        function tokenLiteral(quote, backslashEscapes) {
            return function(stream, state) {
                var escaped = false, ch;
                while((ch = stream.next()) != null){
                    if (ch == quote && !escaped) {
                        state.tokenize = tokenBase;
                        break;
                    }
                    escaped = (backslashStringEscapes || backslashEscapes) && !escaped && ch == "\\";
                }
                return "string";
            };
        }
        function tokenComment(depth) {
            return function(stream, state) {
                var m = stream.match(/^.*?(\/\*|\*\/)/);
                if (!m) stream.skipToEnd();
                else if (m[1] == "/*") state.tokenize = tokenComment(depth + 1);
                else if (depth > 1) state.tokenize = tokenComment(depth - 1);
                else state.tokenize = tokenBase;
                return "comment";
            };
        }
        function pushContext(stream, state, type) {
            state.context = {
                prev: state.context,
                indent: stream.indentation(),
                col: stream.column(),
                type: type
            };
        }
        function popContext(state) {
            state.indent = state.context.indent;
            state.context = state.context.prev;
        }
        return {
            startState: function() {
                return {
                    tokenize: tokenBase,
                    context: null
                };
            },
            token: function(stream, state) {
                if (stream.sol()) {
                    if (state.context && state.context.align == null) state.context.align = false;
                }
                if (state.tokenize == tokenBase && stream.eatSpace()) return null;
                var style = state.tokenize(stream, state);
                if (style == "comment") return style;
                if (state.context && state.context.align == null) state.context.align = true;
                var tok = stream.current();
                if (tok == "(") pushContext(stream, state, ")");
                else if (tok == "[") pushContext(stream, state, "]");
                else if (state.context && state.context.type == tok) popContext(state);
                return style;
            },
            indent: function(state, textAfter) {
                var cx = state.context;
                if (!cx) return CodeMirror.Pass;
                var closing = textAfter.charAt(0) == cx.type;
                if (cx.align) return cx.col + (closing ? 0 : 1);
                else return cx.indent + (closing ? 0 : config.indentUnit);
            },
            blockCommentStart: "/*",
            blockCommentEnd: "*/",
            lineComment: support.commentSlashSlash ? "//" : support.commentHash ? "#" : "--",
            closeBrackets: "()[]{}''\"\"``"
        };
    });
    function hookIdentifier(stream) {
        var ch;
        while((ch = stream.next()) != null){
            if (ch == "`" && !stream.eat("`")) return "variable-2";
        }
        stream.backUp(stream.current().length - 1);
        return stream.eatWhile(/\w/) ? "variable-2" : null;
    }
    function hookIdentifierDoublequote(stream) {
        var ch;
        while((ch = stream.next()) != null){
            if (ch == "\"" && !stream.eat("\"")) return "variable-2";
        }
        stream.backUp(stream.current().length - 1);
        return stream.eatWhile(/\w/) ? "variable-2" : null;
    }
    function hookVar(stream) {
        if (stream.eat("@")) {
            stream.match('session.');
            stream.match('local.');
            stream.match('global.');
        }
        if (stream.eat("'")) {
            stream.match(/^.*'/);
            return "variable-2";
        } else if (stream.eat('"')) {
            stream.match(/^.*"/);
            return "variable-2";
        } else if (stream.eat("`")) {
            stream.match(/^.*`/);
            return "variable-2";
        } else if (stream.match(/^[0-9a-zA-Z$\.\_]+/)) {
            return "variable-2";
        }
        return null;
    }
    function hookClient(stream) {
        if (stream.eat("N")) {
            return "atom";
        }
        return stream.match(/^[a-zA-Z.#!?]/) ? "variable-2" : null;
    }
    var sqlKeywords = "alter and as asc between by count create delete desc distinct drop from group having in insert into is join like not on or order select set table union update values where limit ";
    function set(str) {
        var obj = {
        }, words = str.split(" ");
        for(var i = 0; i < words.length; ++i)obj[words[i]] = true;
        return obj;
    }
    var defaultBuiltin = "bool boolean bit blob enum long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision real date datetime year unsigned signed decimal numeric";
    CodeMirror.defineMIME("text/x-sql", {
        name: "sql",
        keywords: set(sqlKeywords + "begin"),
        builtin: set(defaultBuiltin),
        atoms: set("false true null unknown"),
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable doubleQuote binaryNumber hexNumber")
    });
    CodeMirror.defineMIME("text/x-mssql", {
        name: "sql",
        client: set("$partition binary_checksum checksum connectionproperty context_info current_request_id error_line error_message error_number error_procedure error_severity error_state formatmessage get_filestream_transaction_context getansinull host_id host_name isnull isnumeric min_active_rowversion newid newsequentialid rowcount_big xact_state object_id"),
        keywords: set(sqlKeywords + "begin trigger proc view index for add constraint key primary foreign collate clustered nonclustered declare exec go if use index holdlock nolock nowait paglock readcommitted readcommittedlock readpast readuncommitted repeatableread rowlock serializable snapshot tablock tablockx updlock with"),
        builtin: set("bigint numeric bit smallint decimal smallmoney int tinyint money float real char varchar text nchar nvarchar ntext binary varbinary image cursor timestamp hierarchyid uniqueidentifier sql_variant xml table "),
        atoms: set("is not null like and or in left right between inner outer join all any some cross unpivot pivot exists"),
        operatorChars: /^[*+\-%<>!=^\&|\/]/,
        brackets: /^[\{}\(\)]/,
        punctuation: /^[;.,:/]/,
        backslashStringEscapes: false,
        dateSQL: set("date datetimeoffset datetime2 smalldatetime datetime time"),
        hooks: {
            "@": hookVar
        }
    });
    CodeMirror.defineMIME("text/x-mysql", {
        name: "sql",
        client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),
        keywords: set(sqlKeywords + "accessible action add after algorithm all analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general get global grant grants group group_concat handler hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show signal slave slow smallint snapshot soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),
        builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),
        atoms: set("false true null unknown"),
        operatorChars: /^[*+\-%<>!=&|^]/,
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),
        hooks: {
            "@": hookVar,
            "`": hookIdentifier,
            "\\": hookClient
        }
    });
    CodeMirror.defineMIME("text/x-mariadb", {
        name: "sql",
        client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),
        keywords: set(sqlKeywords + "accessible action add after algorithm all always analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general generated get global grant grants group groupby_concat handler hard hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password persistent phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show shutdown signal slave slow smallint snapshot soft soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views virtual warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),
        builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),
        atoms: set("false true null unknown"),
        operatorChars: /^[*+\-%<>!=&|^]/,
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),
        hooks: {
            "@": hookVar,
            "`": hookIdentifier,
            "\\": hookClient
        }
    });
    CodeMirror.defineMIME("text/x-sqlite", {
        name: "sql",
        client: set("auth backup bail binary changes check clone databases dbinfo dump echo eqp exit explain fullschema headers help import imposter indexes iotrace limit lint load log mode nullvalue once open output print prompt quit read restore save scanstats schema separator session shell show stats system tables testcase timeout timer trace vfsinfo vfslist vfsname width"),
        keywords: set(sqlKeywords + "abort action add after all analyze attach autoincrement before begin cascade case cast check collate column commit conflict constraint cross current_date current_time current_timestamp database default deferrable deferred detach each else end escape except exclusive exists explain fail for foreign full glob if ignore immediate index indexed initially inner instead intersect isnull key left limit match natural no notnull null of offset outer plan pragma primary query raise recursive references regexp reindex release rename replace restrict right rollback row savepoint temp temporary then to transaction trigger unique using vacuum view virtual when with without"),
        builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text clob bigint int int2 int8 integer float double char varchar date datetime year unsigned signed numeric real"),
        atoms: set("null current_date current_time current_timestamp"),
        operatorChars: /^[*+\-%<>!=&|/~]/,
        dateSQL: set("date time timestamp datetime"),
        support: set("decimallessFloat zerolessFloat"),
        identifierQuote: "\"",
        hooks: {
            "@": hookVar,
            ":": hookVar,
            "?": hookVar,
            "$": hookVar,
            "\"": hookIdentifierDoublequote,
            "`": hookIdentifier
        }
    });
    CodeMirror.defineMIME("text/x-cassandra", {
        name: "sql",
        client: {
        },
        keywords: set("add all allow alter and any apply as asc authorize batch begin by clustering columnfamily compact consistency count create custom delete desc distinct drop each_quorum exists filtering from grant if in index insert into key keyspace keyspaces level limit local_one local_quorum modify nan norecursive nosuperuser not of on one order password permission permissions primary quorum rename revoke schema select set storage superuser table three to token truncate ttl two type unlogged update use user users using values where with writetime"),
        builtin: set("ascii bigint blob boolean counter decimal double float frozen inet int list map static text timestamp timeuuid tuple uuid varchar varint"),
        atoms: set("false true infinity NaN"),
        operatorChars: /^[<>=]/,
        dateSQL: {
        },
        support: set("commentSlashSlash decimallessFloat"),
        hooks: {
        }
    });
    CodeMirror.defineMIME("text/x-plsql", {
        name: "sql",
        client: set("appinfo arraysize autocommit autoprint autorecovery autotrace blockterminator break btitle cmdsep colsep compatibility compute concat copycommit copytypecheck define describe echo editfile embedded escape exec execute feedback flagger flush heading headsep instance linesize lno loboffset logsource long longchunksize markup native newpage numformat numwidth pagesize pause pno recsep recsepchar release repfooter repheader serveroutput shiftinout show showmode size spool sqlblanklines sqlcase sqlcode sqlcontinue sqlnumber sqlpluscompatibility sqlprefix sqlprompt sqlterminator suffix tab term termout time timing trimout trimspool ttitle underline verify version wrap"),
        keywords: set("abort accept access add all alter and any array arraylen as asc assert assign at attributes audit authorization avg base_table begin between binary_integer body boolean by case cast char char_base check close cluster clusters colauth column comment commit compress connect connected constant constraint crash create current currval cursor data_base database date dba deallocate debugoff debugon decimal declare default definition delay delete desc digits dispose distinct do drop else elseif elsif enable end entry escape exception exception_init exchange exclusive exists exit external fast fetch file for force form from function generic goto grant group having identified if immediate in increment index indexes indicator initial initrans insert interface intersect into is key level library like limited local lock log logging long loop master maxextents maxtrans member minextents minus mislabel mode modify multiset new next no noaudit nocompress nologging noparallel not nowait number_base object of off offline on online only open option or order out package parallel partition pctfree pctincrease pctused pls_integer positive positiven pragma primary prior private privileges procedure public raise range raw read rebuild record ref references refresh release rename replace resource restrict return returning returns reverse revoke rollback row rowid rowlabel rownum rows run savepoint schema segment select separate session set share snapshot some space split sql start statement storage subtype successful synonym tabauth table tables tablespace task terminate then to trigger truncate type union unique unlimited unrecoverable unusable update use using validate value values variable view views when whenever where while with work"),
        builtin: set("abs acos add_months ascii asin atan atan2 average bfile bfilename bigserial bit blob ceil character chartorowid chr clob concat convert cos cosh count dec decode deref dual dump dup_val_on_index empty error exp false float floor found glb greatest hextoraw initcap instr instrb int integer isopen last_day least length lengthb ln lower lpad ltrim lub make_ref max min mlslabel mod months_between natural naturaln nchar nclob new_time next_day nextval nls_charset_decl_len nls_charset_id nls_charset_name nls_initcap nls_lower nls_sort nls_upper nlssort no_data_found notfound null number numeric nvarchar2 nvl others power rawtohex real reftohex round rowcount rowidtochar rowtype rpad rtrim serial sign signtype sin sinh smallint soundex sqlcode sqlerrm sqrt stddev string substr substrb sum sysdate tan tanh to_char text to_date to_label to_multi_byte to_number to_single_byte translate true trunc uid unlogged upper user userenv varchar varchar2 variance varying vsize xml"),
        operatorChars: /^[*\/+\-%<>!=~]/,
        dateSQL: set("date time timestamp"),
        support: set("doubleQuote nCharCast zerolessFloat binaryNumber hexNumber")
    });
    CodeMirror.defineMIME("text/x-hive", {
        name: "sql",
        keywords: set("select alter $elem$ $key$ $value$ add after all analyze and archive as asc before between binary both bucket buckets by cascade case cast change cluster clustered clusterstatus collection column columns comment compute concatenate continue create cross cursor data database databases dbproperties deferred delete delimited desc describe directory disable distinct distribute drop else enable end escaped exclusive exists explain export extended external fetch fields fileformat first format formatted from full function functions grant group having hold_ddltime idxproperties if import in index indexes inpath inputdriver inputformat insert intersect into is items join keys lateral left like limit lines load local location lock locks mapjoin materialized minus msck no_drop nocompress not of offline on option or order out outer outputdriver outputformat overwrite partition partitioned partitions percent plus preserve procedure purge range rcfile read readonly reads rebuild recordreader recordwriter recover reduce regexp rename repair replace restrict revoke right rlike row schema schemas semi sequencefile serde serdeproperties set shared show show_database sort sorted ssl statistics stored streamtable table tables tablesample tblproperties temporary terminated textfile then tmp to touch transform trigger unarchive undo union uniquejoin unlock update use using utc utc_tmestamp view when where while with admin authorization char compact compactions conf cube current current_date current_timestamp day decimal defined dependency directories elem_type exchange file following for grouping hour ignore inner interval jar less logical macro minute month more none noscan over owner partialscan preceding pretty principals protection reload rewrite role roles rollup rows second server sets skewed transactions truncate unbounded unset uri user values window year"),
        builtin: set("bool boolean long timestamp tinyint smallint bigint int float double date datetime unsigned string array struct map uniontype key_type utctimestamp value_type varchar"),
        atoms: set("false true null unknown"),
        operatorChars: /^[*+\-%<>!=]/,
        dateSQL: set("date timestamp"),
        support: set("ODBCdotTable doubleQuote binaryNumber hexNumber")
    });
    CodeMirror.defineMIME("text/x-pgsql", {
        name: "sql",
        client: set("source"),
        keywords: set(sqlKeywords + "a abort abs absent absolute access according action ada add admin after aggregate alias all allocate also alter always analyse analyze and any are array array_agg array_max_cardinality as asc asensitive assert assertion assignment asymmetric at atomic attach attribute attributes authorization avg backward base64 before begin begin_frame begin_partition bernoulli between bigint binary bit bit_length blob blocked bom boolean both breadth by c cache call called cardinality cascade cascaded case cast catalog catalog_name ceil ceiling chain char char_length character character_length character_set_catalog character_set_name character_set_schema characteristics characters check checkpoint class class_origin clob close cluster coalesce cobol collate collation collation_catalog collation_name collation_schema collect column column_name columns command_function command_function_code comment comments commit committed concurrently condition condition_number configuration conflict connect connection connection_name constant constraint constraint_catalog constraint_name constraint_schema constraints constructor contains content continue control conversion convert copy corr corresponding cost count covar_pop covar_samp create cross csv cube cume_dist current current_catalog current_date current_default_transform_group current_path current_role current_row current_schema current_time current_timestamp current_transform_group_for_type current_user cursor cursor_name cycle data database datalink datatype date datetime_interval_code datetime_interval_precision day db deallocate debug dec decimal declare default defaults deferrable deferred defined definer degree delete delimiter delimiters dense_rank depends depth deref derived desc describe descriptor detach detail deterministic diagnostics dictionary disable discard disconnect dispatch distinct dlnewcopy dlpreviouscopy dlurlcomplete dlurlcompleteonly dlurlcompletewrite dlurlpath dlurlpathonly dlurlpathwrite dlurlscheme dlurlserver dlvalue do document domain double drop dump dynamic dynamic_function dynamic_function_code each element else elseif elsif empty enable encoding encrypted end end_frame end_partition endexec enforced enum equals errcode error escape event every except exception exclude excluding exclusive exec execute exists exit exp explain expression extension external extract false family fetch file filter final first first_value flag float floor following for force foreach foreign fortran forward found frame_row free freeze from fs full function functions fusion g general generated get global go goto grant granted greatest group grouping groups handler having header hex hierarchy hint hold hour id identity if ignore ilike immediate immediately immutable implementation implicit import in include including increment indent index indexes indicator info inherit inherits initially inline inner inout input insensitive insert instance instantiable instead int integer integrity intersect intersection interval into invoker is isnull isolation join k key key_member key_type label lag language large last last_value lateral lead leading leakproof least left length level library like like_regex limit link listen ln load local localtime localtimestamp location locator lock locked log logged loop lower m map mapping match matched materialized max max_cardinality maxvalue member merge message message_length message_octet_length message_text method min minute minvalue mod mode modifies module month more move multiset mumps name names namespace national natural nchar nclob nesting new next nfc nfd nfkc nfkd nil no none normalize normalized not nothing notice notify notnull nowait nth_value ntile null nullable nullif nulls number numeric object occurrences_regex octet_length octets of off offset oids old on only open operator option options or order ordering ordinality others out outer output over overlaps overlay overriding owned owner p pad parallel parameter parameter_mode parameter_name parameter_ordinal_position parameter_specific_catalog parameter_specific_name parameter_specific_schema parser partial partition pascal passing passthrough password path percent percent_rank percentile_cont percentile_disc perform period permission pg_context pg_datatype_name pg_exception_context pg_exception_detail pg_exception_hint placing plans pli policy portion position position_regex power precedes preceding precision prepare prepared preserve primary print_strict_params prior privileges procedural procedure procedures program public publication query quote raise range rank read reads real reassign recheck recovery recursive ref references referencing refresh regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy regr_syy reindex relative release rename repeatable replace replica requiring reset respect restart restore restrict result result_oid return returned_cardinality returned_length returned_octet_length returned_sqlstate returning returns reverse revoke right role rollback rollup routine routine_catalog routine_name routine_schema routines row row_count row_number rows rowtype rule savepoint scale schema schema_name schemas scope scope_catalog scope_name scope_schema scroll search second section security select selective self sensitive sequence sequences serializable server server_name session session_user set setof sets share show similar simple size skip slice smallint snapshot some source space specific specific_name specifictype sql sqlcode sqlerror sqlexception sqlstate sqlwarning sqrt stable stacked standalone start state statement static statistics stddev_pop stddev_samp stdin stdout storage strict strip structure style subclass_origin submultiset subscription substring substring_regex succeeds sum symmetric sysid system system_time system_user t table table_name tables tablesample tablespace temp template temporary text then ties time timestamp timezone_hour timezone_minute to token top_level_count trailing transaction transaction_active transactions_committed transactions_rolled_back transform transforms translate translate_regex translation treat trigger trigger_catalog trigger_name trigger_schema trim trim_array true truncate trusted type types uescape unbounded uncommitted under unencrypted union unique unknown unlink unlisten unlogged unnamed unnest until untyped update upper uri usage use_column use_variable user user_defined_type_catalog user_defined_type_code user_defined_type_name user_defined_type_schema using vacuum valid validate validator value value_of values var_pop var_samp varbinary varchar variable_conflict variadic varying verbose version versioning view views volatile warning when whenever where while whitespace width_bucket window with within without work wrapper write xml xmlagg xmlattributes xmlbinary xmlcast xmlcomment xmlconcat xmldeclaration xmldocument xmlelement xmlexists xmlforest xmliterate xmlnamespaces xmlparse xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltext xmlvalidate year yes zone"),
        builtin: set("bigint int8 bigserial serial8 bit varying varbit boolean bool box bytea character char varchar cidr circle date double precision float8 inet integer int int4 interval json jsonb line lseg macaddr macaddr8 money numeric decimal path pg_lsn point polygon real float4 smallint int2 smallserial serial2 serial serial4 text time without zone with timetz timestamp timestamptz tsquery tsvector txid_snapshot uuid xml"),
        atoms: set("false true null unknown"),
        operatorChars: /^[*\/+\-%<>!=&|^\/#@?~]/,
        backslashStringEscapes: false,
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber nCharCast charsetCast escapeConstant")
    });
    CodeMirror.defineMIME("text/x-gql", {
        name: "sql",
        keywords: set("ancestor and asc by contains desc descendant distinct from group has in is limit offset on order select superset where"),
        atoms: set("false true"),
        builtin: set("blob datetime first key __key__ string integer double boolean null"),
        operatorChars: /^[*+\-%<>!=]/
    });
    CodeMirror.defineMIME("text/x-gpsql", {
        name: "sql",
        client: set("source"),
        keywords: set("abort absolute access action active add admin after aggregate all also alter always analyse analyze and any array as asc assertion assignment asymmetric at authorization backward before begin between bigint binary bit boolean both by cache called cascade cascaded case cast chain char character characteristics check checkpoint class close cluster coalesce codegen collate column comment commit committed concurrency concurrently configuration connection constraint constraints contains content continue conversion copy cost cpu_rate_limit create createdb createexttable createrole createuser cross csv cube current current_catalog current_date current_role current_schema current_time current_timestamp current_user cursor cycle data database day deallocate dec decimal declare decode default defaults deferrable deferred definer delete delimiter delimiters deny desc dictionary disable discard distinct distributed do document domain double drop dxl each else enable encoding encrypted end enum errors escape every except exchange exclude excluding exclusive execute exists explain extension external extract false family fetch fields filespace fill filter first float following for force foreign format forward freeze from full function global grant granted greatest group group_id grouping handler hash having header hold host hour identity if ignore ilike immediate immutable implicit in including inclusive increment index indexes inherit inherits initially inline inner inout input insensitive insert instead int integer intersect interval into invoker is isnull isolation join key language large last leading least left level like limit list listen load local localtime localtimestamp location lock log login mapping master match maxvalue median merge minute minvalue missing mode modifies modify month move name names national natural nchar new newline next no nocreatedb nocreateexttable nocreaterole nocreateuser noinherit nologin none noovercommit nosuperuser not nothing notify notnull nowait null nullif nulls numeric object of off offset oids old on only operator option options or order ordered others out outer over overcommit overlaps overlay owned owner parser partial partition partitions passing password percent percentile_cont percentile_disc placing plans position preceding precision prepare prepared preserve primary prior privileges procedural procedure protocol queue quote randomly range read readable reads real reassign recheck recursive ref references reindex reject relative release rename repeatable replace replica reset resource restart restrict returning returns revoke right role rollback rollup rootpartition row rows rule savepoint scatter schema scroll search second security segment select sequence serializable session session_user set setof sets share show similar simple smallint some split sql stable standalone start statement statistics stdin stdout storage strict strip subpartition subpartitions substring superuser symmetric sysid system table tablespace temp template temporary text then threshold ties time timestamp to trailing transaction treat trigger trim true truncate trusted type unbounded uncommitted unencrypted union unique unknown unlisten until update user using vacuum valid validation validator value values varchar variadic varying verbose version view volatile web when where whitespace window with within without work writable write xml xmlattributes xmlconcat xmlelement xmlexists xmlforest xmlparse xmlpi xmlroot xmlserialize year yes zone"),
        builtin: set("bigint int8 bigserial serial8 bit varying varbit boolean bool box bytea character char varchar cidr circle date double precision float float8 inet integer int int4 interval json jsonb line lseg macaddr macaddr8 money numeric decimal path pg_lsn point polygon real float4 smallint int2 smallserial serial2 serial serial4 text time without zone with timetz timestamp timestamptz tsquery tsvector txid_snapshot uuid xml"),
        atoms: set("false true null unknown"),
        operatorChars: /^[*+\-%<>!=&|^\/#@?~]/,
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber nCharCast charsetCast")
    });
    CodeMirror.defineMIME("text/x-sparksql", {
        name: "sql",
        keywords: set("add after all alter analyze and anti archive array as asc at between bucket buckets by cache cascade case cast change clear cluster clustered codegen collection column columns comment commit compact compactions compute concatenate cost create cross cube current current_date current_timestamp database databases data dbproperties defined delete delimited deny desc describe dfs directories distinct distribute drop else end escaped except exchange exists explain export extended external false fields fileformat first following for format formatted from full function functions global grant group grouping having if ignore import in index indexes inner inpath inputformat insert intersect interval into is items join keys last lateral lazy left like limit lines list load local location lock locks logical macro map minus msck natural no not null nulls of on optimize option options or order out outer outputformat over overwrite partition partitioned partitions percent preceding principals purge range recordreader recordwriter recover reduce refresh regexp rename repair replace reset restrict revoke right rlike role roles rollback rollup row rows schema schemas select semi separated serde serdeproperties set sets show skewed sort sorted start statistics stored stratify struct table tables tablesample tblproperties temp temporary terminated then to touch transaction transactions transform true truncate unarchive unbounded uncache union unlock unset use using values view when where window with"),
        builtin: set("tinyint smallint int bigint boolean float double string binary timestamp decimal array map struct uniontype delimited serde sequencefile textfile rcfile inputformat outputformat"),
        atoms: set("false true null"),
        operatorChars: /^[*\/+\-%<>!=~&|^]/,
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable doubleQuote zerolessFloat")
    });
    CodeMirror.defineMIME("text/x-esper", {
        name: "sql",
        client: set("source"),
        keywords: set("alter and as asc between by count create delete desc distinct drop from group having in insert into is join like not on or order select set table union update values where limit after all and as at asc avedev avg between by case cast coalesce count create current_timestamp day days delete define desc distinct else end escape events every exists false first from full group having hour hours in inner insert instanceof into irstream is istream join last lastweekday left limit like max match_recognize matches median measures metadatasql min minute minutes msec millisecond milliseconds not null offset on or order outer output partition pattern prev prior regexp retain-union retain-intersection right rstream sec second seconds select set some snapshot sql stddev sum then true unidirectional until update variable weekday when where window"),
        builtin: {
        },
        atoms: set("false true null"),
        operatorChars: /^[*+\-%<>!=&|^\/#@?~]/,
        dateSQL: set("time"),
        support: set("decimallessFloat zerolessFloat binaryNumber hexNumber")
    });
});
const CodeEditor = {
    props: [
        "mode", 
    ],
    data () {
        return {
            instance: null
        };
    },
    template: `<textarea>{{$attrs.value}}</textarea>`,
    mounted () {
        this.instance = CodeMirror.fromTextArea(this.$el, {
            lineNumbers: true,
            mode: this.mode
        });
        this.instance.on("changes", ()=>{
            this.$emit("input", this.instance.getValue());
        });
    }
};
!function(t) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = t();
    else if ("function" == typeof define && define.amd) define([], t);
    else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).Chart = t();
    }
}(function() {
    return (function t(e, n, i) {
        function a(o, s) {
            if (!n[o]) {
                if (!e[o]) {
                    var l = "function" == typeof require && require;
                    if (!s && l) return l(o, !0);
                    if (r) return r(o, !0);
                    var u = new Error("Cannot find module '" + o + "'");
                    throw u.code = "MODULE_NOT_FOUND", u;
                }
                var d = n[o] = {
                    exports: {
                    }
                };
                e[o][0].call(d.exports, function(t) {
                    var n = e[o][1][t];
                    return a(n || t);
                }, d, d.exports, t, e, n, i);
            }
            return n[o].exports;
        }
        for(var r = "function" == typeof require && require, o = 0; o < i.length; o++)a(i[o]);
        return a;
    })({
        1: [
            function(t, e, n) {
                function i(t) {
                    if (t) {
                        var e = [
                            0,
                            0,
                            0
                        ], n = 1, i = t.match(/^#([a-fA-F0-9]{3})$/i);
                        if (i) {
                            i = i[1];
                            for(a = 0; a < e.length; a++)e[a] = parseInt(i[a] + i[a], 16);
                        } else if (i = t.match(/^#([a-fA-F0-9]{6})$/i)) {
                            i = i[1];
                            for(a = 0; a < e.length; a++)e[a] = parseInt(i.slice(2 * a, 2 * a + 2), 16);
                        } else if (i = t.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) {
                            for(a = 0; a < e.length; a++)e[a] = parseInt(i[a + 1]);
                            n = parseFloat(i[4]);
                        } else if (i = t.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) {
                            for(a = 0; a < e.length; a++)e[a] = Math.round(2.55 * parseFloat(i[a + 1]));
                            n = parseFloat(i[4]);
                        } else if (i = t.match(/(\w+)/)) {
                            if ("transparent" == i[1]) return [
                                0,
                                0,
                                0,
                                0
                            ];
                            if (!(e = c[i[1]])) return;
                        }
                        for(var a = 0; a < e.length; a++)e[a] = u(e[a], 0, 255);
                        return n = n || 0 == n ? u(n, 0, 1) : 1, e[3] = n, e;
                    }
                }
                function a(t) {
                    if (t) {
                        var e = t.match(/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);
                        if (e) {
                            var n = parseFloat(e[4]);
                            return [
                                u(parseInt(e[1]), 0, 360),
                                u(parseFloat(e[2]), 0, 100),
                                u(parseFloat(e[3]), 0, 100),
                                u(isNaN(n) ? 1 : n, 0, 1)
                            ];
                        }
                    }
                }
                function r(t) {
                    if (t) {
                        var e = t.match(/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);
                        if (e) {
                            var n = parseFloat(e[4]);
                            return [
                                u(parseInt(e[1]), 0, 360),
                                u(parseFloat(e[2]), 0, 100),
                                u(parseFloat(e[3]), 0, 100),
                                u(isNaN(n) ? 1 : n, 0, 1)
                            ];
                        }
                    }
                }
                function o(t, e) {
                    return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "rgba(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + e + ")";
                }
                function s(t, e) {
                    return "rgba(" + Math.round(t[0] / 255 * 100) + "%, " + Math.round(t[1] / 255 * 100) + "%, " + Math.round(t[2] / 255 * 100) + "%, " + (e || t[3] || 1) + ")";
                }
                function l(t, e) {
                    return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "hsla(" + t[0] + ", " + t[1] + "%, " + t[2] + "%, " + e + ")";
                }
                function u(t, e, n) {
                    return Math.min(Math.max(e, t), n);
                }
                function d(t) {
                    var e = t.toString(16).toUpperCase();
                    return e.length < 2 ? "0" + e : e;
                }
                var c = t(5);
                e.exports = {
                    getRgba: i,
                    getHsla: a,
                    getRgb: function(t) {
                        var e = i(t);
                        return e && e.slice(0, 3);
                    },
                    getHsl: function(t) {
                        var e = a(t);
                        return e && e.slice(0, 3);
                    },
                    getHwb: r,
                    getAlpha: function(t) {
                        var e = i(t);
                        return e ? e[3] : (e = a(t)) ? e[3] : (e = r(t)) ? e[3] : void 0;
                    },
                    hexString: function(t) {
                        return "#" + d(t[0]) + d(t[1]) + d(t[2]);
                    },
                    rgbString: function(t, e) {
                        return e < 1 || t[3] && t[3] < 1 ? o(t, e) : "rgb(" + t[0] + ", " + t[1] + ", " + t[2] + ")";
                    },
                    rgbaString: o,
                    percentString: function(t, e) {
                        return e < 1 || t[3] && t[3] < 1 ? s(t, e) : "rgb(" + Math.round(t[0] / 255 * 100) + "%, " + Math.round(t[1] / 255 * 100) + "%, " + Math.round(t[2] / 255 * 100) + "%)";
                    },
                    percentaString: s,
                    hslString: function(t, e) {
                        return e < 1 || t[3] && t[3] < 1 ? l(t, e) : "hsl(" + t[0] + ", " + t[1] + "%, " + t[2] + "%)";
                    },
                    hslaString: l,
                    hwbString: function(t, e) {
                        return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "hwb(" + t[0] + ", " + t[1] + "%, " + t[2] + "%" + (void 0 !== e && 1 !== e ? ", " + e : "") + ")";
                    },
                    keyword: function(t) {
                        return h[t.slice(0, 3)];
                    }
                };
                var h = {
                };
                for(var f in c)h[c[f]] = f;
            },
            {
                5: 5
            }
        ],
        2: [
            function(t, e, n) {
                var i = t(4), a = t(1), r = function(t) {
                    if (t instanceof r) return t;
                    if (!(this instanceof r)) return new r(t);
                    this.valid = !1, this.values = {
                        rgb: [
                            0,
                            0,
                            0
                        ],
                        hsl: [
                            0,
                            0,
                            0
                        ],
                        hsv: [
                            0,
                            0,
                            0
                        ],
                        hwb: [
                            0,
                            0,
                            0
                        ],
                        cmyk: [
                            0,
                            0,
                            0,
                            0
                        ],
                        alpha: 1
                    };
                    var e;
                    "string" == typeof t ? (e = a.getRgba(t)) ? this.setValues("rgb", e) : (e = a.getHsla(t)) ? this.setValues("hsl", e) : (e = a.getHwb(t)) && this.setValues("hwb", e) : "object" == typeof t && (void 0 !== (e = t).r || void 0 !== e.red ? this.setValues("rgb", e) : void 0 !== e.l || void 0 !== e.lightness ? this.setValues("hsl", e) : void 0 !== e.v || void 0 !== e.value ? this.setValues("hsv", e) : void 0 !== e.w || void 0 !== e.whiteness ? this.setValues("hwb", e) : void 0 === e.c && void 0 === e.cyan || this.setValues("cmyk", e));
                };
                r.prototype = {
                    isValid: function() {
                        return this.valid;
                    },
                    rgb: function() {
                        return this.setSpace("rgb", arguments);
                    },
                    hsl: function() {
                        return this.setSpace("hsl", arguments);
                    },
                    hsv: function() {
                        return this.setSpace("hsv", arguments);
                    },
                    hwb: function() {
                        return this.setSpace("hwb", arguments);
                    },
                    cmyk: function() {
                        return this.setSpace("cmyk", arguments);
                    },
                    rgbArray: function() {
                        return this.values.rgb;
                    },
                    hslArray: function() {
                        return this.values.hsl;
                    },
                    hsvArray: function() {
                        return this.values.hsv;
                    },
                    hwbArray: function() {
                        var t = this.values;
                        return 1 !== t.alpha ? t.hwb.concat([
                            t.alpha
                        ]) : t.hwb;
                    },
                    cmykArray: function() {
                        return this.values.cmyk;
                    },
                    rgbaArray: function() {
                        var t = this.values;
                        return t.rgb.concat([
                            t.alpha
                        ]);
                    },
                    hslaArray: function() {
                        var t = this.values;
                        return t.hsl.concat([
                            t.alpha
                        ]);
                    },
                    alpha: function(t) {
                        return void 0 === t ? this.values.alpha : (this.setValues("alpha", t), this);
                    },
                    red: function(t) {
                        return this.setChannel("rgb", 0, t);
                    },
                    green: function(t) {
                        return this.setChannel("rgb", 1, t);
                    },
                    blue: function(t) {
                        return this.setChannel("rgb", 2, t);
                    },
                    hue: function(t) {
                        return t && (t = (t %= 360) < 0 ? 360 + t : t), this.setChannel("hsl", 0, t);
                    },
                    saturation: function(t) {
                        return this.setChannel("hsl", 1, t);
                    },
                    lightness: function(t) {
                        return this.setChannel("hsl", 2, t);
                    },
                    saturationv: function(t) {
                        return this.setChannel("hsv", 1, t);
                    },
                    whiteness: function(t) {
                        return this.setChannel("hwb", 1, t);
                    },
                    blackness: function(t) {
                        return this.setChannel("hwb", 2, t);
                    },
                    value: function(t) {
                        return this.setChannel("hsv", 2, t);
                    },
                    cyan: function(t) {
                        return this.setChannel("cmyk", 0, t);
                    },
                    magenta: function(t) {
                        return this.setChannel("cmyk", 1, t);
                    },
                    yellow: function(t) {
                        return this.setChannel("cmyk", 2, t);
                    },
                    black: function(t) {
                        return this.setChannel("cmyk", 3, t);
                    },
                    hexString: function() {
                        return a.hexString(this.values.rgb);
                    },
                    rgbString: function() {
                        return a.rgbString(this.values.rgb, this.values.alpha);
                    },
                    rgbaString: function() {
                        return a.rgbaString(this.values.rgb, this.values.alpha);
                    },
                    percentString: function() {
                        return a.percentString(this.values.rgb, this.values.alpha);
                    },
                    hslString: function() {
                        return a.hslString(this.values.hsl, this.values.alpha);
                    },
                    hslaString: function() {
                        return a.hslaString(this.values.hsl, this.values.alpha);
                    },
                    hwbString: function() {
                        return a.hwbString(this.values.hwb, this.values.alpha);
                    },
                    keyword: function() {
                        return a.keyword(this.values.rgb, this.values.alpha);
                    },
                    rgbNumber: function() {
                        var t = this.values.rgb;
                        return t[0] << 16 | t[1] << 8 | t[2];
                    },
                    luminosity: function() {
                        for(var t = this.values.rgb, e = [], n = 0; n < t.length; n++){
                            var i = t[n] / 255;
                            e[n] = i <= 0.03928 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4);
                        }
                        return 0.2126 * e[0] + 0.7152 * e[1] + 0.0722 * e[2];
                    },
                    contrast: function(t) {
                        var e = this.luminosity(), n = t.luminosity();
                        return e > n ? (e + 0.05) / (n + 0.05) : (n + 0.05) / (e + 0.05);
                    },
                    level: function(t) {
                        var e = this.contrast(t);
                        return e >= 7.1 ? "AAA" : e >= 4.5 ? "AA" : "";
                    },
                    dark: function() {
                        var t = this.values.rgb;
                        return (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1000 < 128;
                    },
                    light: function() {
                        return !this.dark();
                    },
                    negate: function() {
                        for(var t = [], e = 0; e < 3; e++)t[e] = 255 - this.values.rgb[e];
                        return this.setValues("rgb", t), this;
                    },
                    lighten: function(t) {
                        var e = this.values.hsl;
                        return e[2] += e[2] * t, this.setValues("hsl", e), this;
                    },
                    darken: function(t) {
                        var e = this.values.hsl;
                        return e[2] -= e[2] * t, this.setValues("hsl", e), this;
                    },
                    saturate: function(t) {
                        var e = this.values.hsl;
                        return e[1] += e[1] * t, this.setValues("hsl", e), this;
                    },
                    desaturate: function(t) {
                        var e = this.values.hsl;
                        return e[1] -= e[1] * t, this.setValues("hsl", e), this;
                    },
                    whiten: function(t) {
                        var e = this.values.hwb;
                        return e[1] += e[1] * t, this.setValues("hwb", e), this;
                    },
                    blacken: function(t) {
                        var e = this.values.hwb;
                        return e[2] += e[2] * t, this.setValues("hwb", e), this;
                    },
                    greyscale: function() {
                        var t = this.values.rgb, e = 0.3 * t[0] + 0.59 * t[1] + 0.11 * t[2];
                        return this.setValues("rgb", [
                            e,
                            e,
                            e
                        ]), this;
                    },
                    clearer: function(t) {
                        var e = this.values.alpha;
                        return this.setValues("alpha", e - e * t), this;
                    },
                    opaquer: function(t) {
                        var e = this.values.alpha;
                        return this.setValues("alpha", e + e * t), this;
                    },
                    rotate: function(t) {
                        var e = this.values.hsl, n = (e[0] + t) % 360;
                        return e[0] = n < 0 ? 360 + n : n, this.setValues("hsl", e), this;
                    },
                    mix: function(t, e) {
                        var n = this, i = t, a = void 0 === e ? 0.5 : e, r = 2 * a - 1, o = n.alpha() - i.alpha(), s = ((r * o == -1 ? r : (r + o) / (1 + r * o)) + 1) / 2, l = 1 - s;
                        return this.rgb(s * n.red() + l * i.red(), s * n.green() + l * i.green(), s * n.blue() + l * i.blue()).alpha(n.alpha() * a + i.alpha() * (1 - a));
                    },
                    toJSON: function() {
                        return this.rgb();
                    },
                    clone: function() {
                        var t, e, n = new r, i = this.values, a = n.values;
                        for(var o in i)i.hasOwnProperty(o) && (t = i[o], "[object Array]" === (e = ({
                        }).toString.call(t)) ? a[o] = t.slice(0) : "[object Number]" === e ? a[o] = t : console.error("unexpected color value:", t));
                        return n;
                    }
                }, r.prototype.spaces = {
                    rgb: [
                        "red",
                        "green",
                        "blue"
                    ],
                    hsl: [
                        "hue",
                        "saturation",
                        "lightness"
                    ],
                    hsv: [
                        "hue",
                        "saturation",
                        "value"
                    ],
                    hwb: [
                        "hue",
                        "whiteness",
                        "blackness"
                    ],
                    cmyk: [
                        "cyan",
                        "magenta",
                        "yellow",
                        "black"
                    ]
                }, r.prototype.maxes = {
                    rgb: [
                        255,
                        255,
                        255
                    ],
                    hsl: [
                        360,
                        100,
                        100
                    ],
                    hsv: [
                        360,
                        100,
                        100
                    ],
                    hwb: [
                        360,
                        100,
                        100
                    ],
                    cmyk: [
                        100,
                        100,
                        100,
                        100
                    ]
                }, r.prototype.getValues = function(t) {
                    for(var e = this.values, n = {
                    }, i = 0; i < t.length; i++)n[t.charAt(i)] = e[t][i];
                    return 1 !== e.alpha && (n.a = e.alpha), n;
                }, r.prototype.setValues = function(t, e) {
                    var n, a = this.values, r = this.spaces, o = this.maxes, s = 1;
                    if (this.valid = !0, "alpha" === t) s = e;
                    else if (e.length) a[t] = e.slice(0, t.length), s = e[t.length];
                    else if (void 0 !== e[t.charAt(0)]) {
                        for(n = 0; n < t.length; n++)a[t][n] = e[t.charAt(n)];
                        s = e.a;
                    } else if (void 0 !== e[r[t][0]]) {
                        var l = r[t];
                        for(n = 0; n < t.length; n++)a[t][n] = e[l[n]];
                        s = e.alpha;
                    }
                    if (a.alpha = Math.max(0, Math.min(1, void 0 === s ? a.alpha : s)), "alpha" === t) return !1;
                    var u;
                    for(n = 0; n < t.length; n++)u = Math.max(0, Math.min(o[t][n], a[t][n])), a[t][n] = Math.round(u);
                    for(var d in r)d !== t && (a[d] = i[t][d](a[t]));
                    return !0;
                }, r.prototype.setSpace = function(t, e) {
                    var n = e[0];
                    return void 0 === n ? this.getValues(t) : ("number" == typeof n && (n = Array.prototype.slice.call(e)), this.setValues(t, n), this);
                }, r.prototype.setChannel = function(t, e, n) {
                    var i = this.values[t];
                    return void 0 === n ? i[e] : n === i[e] ? this : (i[e] = n, this.setValues(t, i), this);
                }, "undefined" != typeof window && (window.Color = r), e.exports = r;
            },
            {
                1: 1,
                4: 4
            }
        ],
        3: [
            function(t, e, n) {
                function i(t) {
                    var e, n, i, a = t[0] / 255, r = t[1] / 255, o = t[2] / 255, s = Math.min(a, r, o), l = Math.max(a, r, o), u = l - s;
                    return l == s ? e = 0 : a == l ? e = (r - o) / u : r == l ? e = 2 + (o - a) / u : o == l && (e = 4 + (a - r) / u), (e = Math.min(60 * e, 360)) < 0 && (e += 360), i = (s + l) / 2, n = l == s ? 0 : i <= 0.5 ? u / (l + s) : u / (2 - l - s), [
                        e,
                        100 * n,
                        100 * i
                    ];
                }
                function a(t) {
                    var e, n, i, a = t[0], r = t[1], o = t[2], s = Math.min(a, r, o), l = Math.max(a, r, o), u = l - s;
                    return n = 0 == l ? 0 : u / l * 1000 / 10, l == s ? e = 0 : a == l ? e = (r - o) / u : r == l ? e = 2 + (o - a) / u : o == l && (e = 4 + (a - r) / u), (e = Math.min(60 * e, 360)) < 0 && (e += 360), i = l / 255 * 1000 / 10, [
                        e,
                        n,
                        i
                    ];
                }
                function o(t) {
                    var e = t[0], n = t[1], a = t[2];
                    return [
                        i(t)[0],
                        100 * (1 / 255 * Math.min(e, Math.min(n, a))),
                        100 * (a = 1 - 1 / 255 * Math.max(e, Math.max(n, a)))
                    ];
                }
                function s(t) {
                    var e, n, i, a, r = t[0] / 255, o = t[1] / 255, s = t[2] / 255;
                    return a = Math.min(1 - r, 1 - o, 1 - s), e = (1 - r - a) / (1 - a) || 0, n = (1 - o - a) / (1 - a) || 0, i = (1 - s - a) / (1 - a) || 0, [
                        100 * e,
                        100 * n,
                        100 * i,
                        100 * a
                    ];
                }
                function l(t) {
                    return S[JSON.stringify(t)];
                }
                function u(t) {
                    var e = t[0] / 255, n = t[1] / 255, i = t[2] / 255;
                    return [
                        100 * (0.4124 * (e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92) + 0.3576 * (n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92) + 0.1805 * (i = i > 0.04045 ? Math.pow((i + 0.055) / 1.055, 2.4) : i / 12.92)),
                        100 * (0.2126 * e + 0.7152 * n + 0.0722 * i),
                        100 * (0.0193 * e + 0.1192 * n + 0.9505 * i)
                    ];
                }
                function d(t) {
                    var e, n, i, a = u(t), r = a[0], o = a[1], s = a[2];
                    return r /= 95.047, o /= 100, s /= 108.883, r = r > 0.008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, o = o > 0.008856 ? Math.pow(o, 1 / 3) : 7.787 * o + 16 / 116, s = s > 0.008856 ? Math.pow(s, 1 / 3) : 7.787 * s + 16 / 116, e = 116 * o - 16, n = 500 * (r - o), i = 200 * (o - s), [
                        e,
                        n,
                        i
                    ];
                }
                function c(t) {
                    var e, n, i, a, r, o = t[0] / 360, s = t[1] / 100, l = t[2] / 100;
                    if (0 == s) return r = 255 * l, [
                        r,
                        r,
                        r
                    ];
                    e = 2 * l - (n = l < 0.5 ? l * (1 + s) : l + s - l * s), a = [
                        0,
                        0,
                        0
                    ];
                    for(var u = 0; u < 3; u++)(i = o + 1 / 3 * -(u - 1)) < 0 && i++, i > 1 && i--, r = 6 * i < 1 ? e + 6 * (n - e) * i : 2 * i < 1 ? n : 3 * i < 2 ? e + (n - e) * (2 / 3 - i) * 6 : e, a[u] = 255 * r;
                    return a;
                }
                function h(t) {
                    var e = t[0] / 60, n = t[1] / 100, i = t[2] / 100, a = Math.floor(e) % 6, r = e - Math.floor(e), o = 255 * i * (1 - n), s = 255 * i * (1 - n * r), l = 255 * i * (1 - n * (1 - r)), i = 255 * i;
                    switch(a){
                        case 0:
                            return [
                                i,
                                l,
                                o
                            ];
                        case 1:
                            return [
                                s,
                                i,
                                o
                            ];
                        case 2:
                            return [
                                o,
                                i,
                                l
                            ];
                        case 3:
                            return [
                                o,
                                s,
                                i
                            ];
                        case 4:
                            return [
                                l,
                                o,
                                i
                            ];
                        case 5:
                            return [
                                i,
                                o,
                                s
                            ];
                    }
                }
                function f(t) {
                    var e, n, i, a, o = t[0] / 360, s = t[1] / 100, l = t[2] / 100, u = s + l;
                    switch(u > 1 && (s /= u, l /= u), e = Math.floor(6 * o), n = 1 - l, i = 6 * o - e, 0 != (1 & e) && (i = 1 - i), a = s + i * (n - s), e){
                        default:
                        case 6:
                        case 0:
                            r = n, g = a, b = s;
                            break;
                        case 1:
                            r = a, g = n, b = s;
                            break;
                        case 2:
                            r = s, g = n, b = a;
                            break;
                        case 3:
                            r = s, g = a, b = n;
                            break;
                        case 4:
                            r = a, g = s, b = n;
                            break;
                        case 5:
                            r = n, g = s, b = a;
                    }
                    return [
                        255 * r,
                        255 * g,
                        255 * b
                    ];
                }
                function m(t) {
                    var e, n, i, a = t[0] / 100, r = t[1] / 100, o = t[2] / 100, s = t[3] / 100;
                    return e = 1 - Math.min(1, a * (1 - s) + s), n = 1 - Math.min(1, r * (1 - s) + s), i = 1 - Math.min(1, o * (1 - s) + s), [
                        255 * e,
                        255 * n,
                        255 * i
                    ];
                }
                function p(t) {
                    var e, n, i, a = t[0] / 100, r = t[1] / 100, o = t[2] / 100;
                    return e = 3.2406 * a + -1.5372 * r + -0.4986 * o, n = -0.9689 * a + 1.8758 * r + 0.0415 * o, i = 0.0557 * a + -0.204 * r + 1.057 * o, e = e > 0.0031308 ? 1.055 * Math.pow(e, 1 / 2.4) - 0.055 : e *= 12.92, n = n > 0.0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : n *= 12.92, i = i > 0.0031308 ? 1.055 * Math.pow(i, 1 / 2.4) - 0.055 : i *= 12.92, e = Math.min(Math.max(0, e), 1), n = Math.min(Math.max(0, n), 1), i = Math.min(Math.max(0, i), 1), [
                        255 * e,
                        255 * n,
                        255 * i
                    ];
                }
                function v(t) {
                    var e, n, i, a = t[0], r = t[1], o = t[2];
                    return a /= 95.047, r /= 100, o /= 108.883, a = a > 0.008856 ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116, r = r > 0.008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, o = o > 0.008856 ? Math.pow(o, 1 / 3) : 7.787 * o + 16 / 116, e = 116 * r - 16, n = 500 * (a - r), i = 200 * (r - o), [
                        e,
                        n,
                        i
                    ];
                }
                function y(t) {
                    var e, n, i, a, r = t[0], o = t[1], s = t[2];
                    return r <= 8 ? a = (n = 100 * r / 903.3) / 100 * 7.787 + 16 / 116 : (n = 100 * Math.pow((r + 16) / 116, 3), a = Math.pow(n / 100, 1 / 3)), e = e / 95.047 <= 0.008856 ? e = 95.047 * (o / 500 + a - 16 / 116) / 7.787 : 95.047 * Math.pow(o / 500 + a, 3), i = i / 108.883 <= 0.008859 ? i = 108.883 * (a - s / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(a - s / 200, 3), [
                        e,
                        n,
                        i
                    ];
                }
                function x(t) {
                    var e, n, i, a = t[0], r = t[1], o = t[2];
                    return e = Math.atan2(o, r), (n = 360 * e / 2 / Math.PI) < 0 && (n += 360), i = Math.sqrt(r * r + o * o), [
                        a,
                        i,
                        n
                    ];
                }
                function _(t) {
                    return p(y(t));
                }
                function k(t) {
                    var e, n, i, a = t[0], r = t[1];
                    return i = t[2] / 360 * 2 * Math.PI, e = r * Math.cos(i), n = r * Math.sin(i), [
                        a,
                        e,
                        n
                    ];
                }
                function w(t) {
                    return M[t];
                }
                e.exports = {
                    rgb2hsl: i,
                    rgb2hsv: a,
                    rgb2hwb: o,
                    rgb2cmyk: s,
                    rgb2keyword: l,
                    rgb2xyz: u,
                    rgb2lab: d,
                    rgb2lch: function(t) {
                        return x(d(t));
                    },
                    hsl2rgb: c,
                    hsl2hsv: function(t) {
                        var e, n, i = t[0], a = t[1] / 100, r = t[2] / 100;
                        return 0 === r ? [
                            0,
                            0,
                            0
                        ] : (r *= 2, a *= r <= 1 ? r : 2 - r, n = (r + a) / 2, e = 2 * a / (r + a), [
                            i,
                            100 * e,
                            100 * n
                        ]);
                    },
                    hsl2hwb: function(t) {
                        return o(c(t));
                    },
                    hsl2cmyk: function(t) {
                        return s(c(t));
                    },
                    hsl2keyword: function(t) {
                        return l(c(t));
                    },
                    hsv2rgb: h,
                    hsv2hsl: function(t) {
                        var e, n, i = t[0], a = t[1] / 100, r = t[2] / 100;
                        return n = (2 - a) * r, e = a * r, e /= n <= 1 ? n : 2 - n, e = e || 0, n /= 2, [
                            i,
                            100 * e,
                            100 * n
                        ];
                    },
                    hsv2hwb: function(t) {
                        return o(h(t));
                    },
                    hsv2cmyk: function(t) {
                        return s(h(t));
                    },
                    hsv2keyword: function(t) {
                        return l(h(t));
                    },
                    hwb2rgb: f,
                    hwb2hsl: function(t) {
                        return i(f(t));
                    },
                    hwb2hsv: function(t) {
                        return a(f(t));
                    },
                    hwb2cmyk: function(t) {
                        return s(f(t));
                    },
                    hwb2keyword: function(t) {
                        return l(f(t));
                    },
                    cmyk2rgb: m,
                    cmyk2hsl: function(t) {
                        return i(m(t));
                    },
                    cmyk2hsv: function(t) {
                        return a(m(t));
                    },
                    cmyk2hwb: function(t) {
                        return o(m(t));
                    },
                    cmyk2keyword: function(t) {
                        return l(m(t));
                    },
                    keyword2rgb: w,
                    keyword2hsl: function(t) {
                        return i(w(t));
                    },
                    keyword2hsv: function(t) {
                        return a(w(t));
                    },
                    keyword2hwb: function(t) {
                        return o(w(t));
                    },
                    keyword2cmyk: function(t) {
                        return s(w(t));
                    },
                    keyword2lab: function(t) {
                        return d(w(t));
                    },
                    keyword2xyz: function(t) {
                        return u(w(t));
                    },
                    xyz2rgb: p,
                    xyz2lab: v,
                    xyz2lch: function(t) {
                        return x(v(t));
                    },
                    lab2xyz: y,
                    lab2rgb: _,
                    lab2lch: x,
                    lch2lab: k,
                    lch2xyz: function(t) {
                        return y(k(t));
                    },
                    lch2rgb: function(t) {
                        return _(k(t));
                    }
                };
                var M = {
                    aliceblue: [
                        240,
                        248,
                        255
                    ],
                    antiquewhite: [
                        250,
                        235,
                        215
                    ],
                    aqua: [
                        0,
                        255,
                        255
                    ],
                    aquamarine: [
                        127,
                        255,
                        212
                    ],
                    azure: [
                        240,
                        255,
                        255
                    ],
                    beige: [
                        245,
                        245,
                        220
                    ],
                    bisque: [
                        255,
                        228,
                        196
                    ],
                    black: [
                        0,
                        0,
                        0
                    ],
                    blanchedalmond: [
                        255,
                        235,
                        205
                    ],
                    blue: [
                        0,
                        0,
                        255
                    ],
                    blueviolet: [
                        138,
                        43,
                        226
                    ],
                    brown: [
                        165,
                        42,
                        42
                    ],
                    burlywood: [
                        222,
                        184,
                        135
                    ],
                    cadetblue: [
                        95,
                        158,
                        160
                    ],
                    chartreuse: [
                        127,
                        255,
                        0
                    ],
                    chocolate: [
                        210,
                        105,
                        30
                    ],
                    coral: [
                        255,
                        127,
                        80
                    ],
                    cornflowerblue: [
                        100,
                        149,
                        237
                    ],
                    cornsilk: [
                        255,
                        248,
                        220
                    ],
                    crimson: [
                        220,
                        20,
                        60
                    ],
                    cyan: [
                        0,
                        255,
                        255
                    ],
                    darkblue: [
                        0,
                        0,
                        139
                    ],
                    darkcyan: [
                        0,
                        139,
                        139
                    ],
                    darkgoldenrod: [
                        184,
                        134,
                        11
                    ],
                    darkgray: [
                        169,
                        169,
                        169
                    ],
                    darkgreen: [
                        0,
                        100,
                        0
                    ],
                    darkgrey: [
                        169,
                        169,
                        169
                    ],
                    darkkhaki: [
                        189,
                        183,
                        107
                    ],
                    darkmagenta: [
                        139,
                        0,
                        139
                    ],
                    darkolivegreen: [
                        85,
                        107,
                        47
                    ],
                    darkorange: [
                        255,
                        140,
                        0
                    ],
                    darkorchid: [
                        153,
                        50,
                        204
                    ],
                    darkred: [
                        139,
                        0,
                        0
                    ],
                    darksalmon: [
                        233,
                        150,
                        122
                    ],
                    darkseagreen: [
                        143,
                        188,
                        143
                    ],
                    darkslateblue: [
                        72,
                        61,
                        139
                    ],
                    darkslategray: [
                        47,
                        79,
                        79
                    ],
                    darkslategrey: [
                        47,
                        79,
                        79
                    ],
                    darkturquoise: [
                        0,
                        206,
                        209
                    ],
                    darkviolet: [
                        148,
                        0,
                        211
                    ],
                    deeppink: [
                        255,
                        20,
                        147
                    ],
                    deepskyblue: [
                        0,
                        191,
                        255
                    ],
                    dimgray: [
                        105,
                        105,
                        105
                    ],
                    dimgrey: [
                        105,
                        105,
                        105
                    ],
                    dodgerblue: [
                        30,
                        144,
                        255
                    ],
                    firebrick: [
                        178,
                        34,
                        34
                    ],
                    floralwhite: [
                        255,
                        250,
                        240
                    ],
                    forestgreen: [
                        34,
                        139,
                        34
                    ],
                    fuchsia: [
                        255,
                        0,
                        255
                    ],
                    gainsboro: [
                        220,
                        220,
                        220
                    ],
                    ghostwhite: [
                        248,
                        248,
                        255
                    ],
                    gold: [
                        255,
                        215,
                        0
                    ],
                    goldenrod: [
                        218,
                        165,
                        32
                    ],
                    gray: [
                        128,
                        128,
                        128
                    ],
                    green: [
                        0,
                        128,
                        0
                    ],
                    greenyellow: [
                        173,
                        255,
                        47
                    ],
                    grey: [
                        128,
                        128,
                        128
                    ],
                    honeydew: [
                        240,
                        255,
                        240
                    ],
                    hotpink: [
                        255,
                        105,
                        180
                    ],
                    indianred: [
                        205,
                        92,
                        92
                    ],
                    indigo: [
                        75,
                        0,
                        130
                    ],
                    ivory: [
                        255,
                        255,
                        240
                    ],
                    khaki: [
                        240,
                        230,
                        140
                    ],
                    lavender: [
                        230,
                        230,
                        250
                    ],
                    lavenderblush: [
                        255,
                        240,
                        245
                    ],
                    lawngreen: [
                        124,
                        252,
                        0
                    ],
                    lemonchiffon: [
                        255,
                        250,
                        205
                    ],
                    lightblue: [
                        173,
                        216,
                        230
                    ],
                    lightcoral: [
                        240,
                        128,
                        128
                    ],
                    lightcyan: [
                        224,
                        255,
                        255
                    ],
                    lightgoldenrodyellow: [
                        250,
                        250,
                        210
                    ],
                    lightgray: [
                        211,
                        211,
                        211
                    ],
                    lightgreen: [
                        144,
                        238,
                        144
                    ],
                    lightgrey: [
                        211,
                        211,
                        211
                    ],
                    lightpink: [
                        255,
                        182,
                        193
                    ],
                    lightsalmon: [
                        255,
                        160,
                        122
                    ],
                    lightseagreen: [
                        32,
                        178,
                        170
                    ],
                    lightskyblue: [
                        135,
                        206,
                        250
                    ],
                    lightslategray: [
                        119,
                        136,
                        153
                    ],
                    lightslategrey: [
                        119,
                        136,
                        153
                    ],
                    lightsteelblue: [
                        176,
                        196,
                        222
                    ],
                    lightyellow: [
                        255,
                        255,
                        224
                    ],
                    lime: [
                        0,
                        255,
                        0
                    ],
                    limegreen: [
                        50,
                        205,
                        50
                    ],
                    linen: [
                        250,
                        240,
                        230
                    ],
                    magenta: [
                        255,
                        0,
                        255
                    ],
                    maroon: [
                        128,
                        0,
                        0
                    ],
                    mediumaquamarine: [
                        102,
                        205,
                        170
                    ],
                    mediumblue: [
                        0,
                        0,
                        205
                    ],
                    mediumorchid: [
                        186,
                        85,
                        211
                    ],
                    mediumpurple: [
                        147,
                        112,
                        219
                    ],
                    mediumseagreen: [
                        60,
                        179,
                        113
                    ],
                    mediumslateblue: [
                        123,
                        104,
                        238
                    ],
                    mediumspringgreen: [
                        0,
                        250,
                        154
                    ],
                    mediumturquoise: [
                        72,
                        209,
                        204
                    ],
                    mediumvioletred: [
                        199,
                        21,
                        133
                    ],
                    midnightblue: [
                        25,
                        25,
                        112
                    ],
                    mintcream: [
                        245,
                        255,
                        250
                    ],
                    mistyrose: [
                        255,
                        228,
                        225
                    ],
                    moccasin: [
                        255,
                        228,
                        181
                    ],
                    navajowhite: [
                        255,
                        222,
                        173
                    ],
                    navy: [
                        0,
                        0,
                        128
                    ],
                    oldlace: [
                        253,
                        245,
                        230
                    ],
                    olive: [
                        128,
                        128,
                        0
                    ],
                    olivedrab: [
                        107,
                        142,
                        35
                    ],
                    orange: [
                        255,
                        165,
                        0
                    ],
                    orangered: [
                        255,
                        69,
                        0
                    ],
                    orchid: [
                        218,
                        112,
                        214
                    ],
                    palegoldenrod: [
                        238,
                        232,
                        170
                    ],
                    palegreen: [
                        152,
                        251,
                        152
                    ],
                    paleturquoise: [
                        175,
                        238,
                        238
                    ],
                    palevioletred: [
                        219,
                        112,
                        147
                    ],
                    papayawhip: [
                        255,
                        239,
                        213
                    ],
                    peachpuff: [
                        255,
                        218,
                        185
                    ],
                    peru: [
                        205,
                        133,
                        63
                    ],
                    pink: [
                        255,
                        192,
                        203
                    ],
                    plum: [
                        221,
                        160,
                        221
                    ],
                    powderblue: [
                        176,
                        224,
                        230
                    ],
                    purple: [
                        128,
                        0,
                        128
                    ],
                    rebeccapurple: [
                        102,
                        51,
                        153
                    ],
                    red: [
                        255,
                        0,
                        0
                    ],
                    rosybrown: [
                        188,
                        143,
                        143
                    ],
                    royalblue: [
                        65,
                        105,
                        225
                    ],
                    saddlebrown: [
                        139,
                        69,
                        19
                    ],
                    salmon: [
                        250,
                        128,
                        114
                    ],
                    sandybrown: [
                        244,
                        164,
                        96
                    ],
                    seagreen: [
                        46,
                        139,
                        87
                    ],
                    seashell: [
                        255,
                        245,
                        238
                    ],
                    sienna: [
                        160,
                        82,
                        45
                    ],
                    silver: [
                        192,
                        192,
                        192
                    ],
                    skyblue: [
                        135,
                        206,
                        235
                    ],
                    slateblue: [
                        106,
                        90,
                        205
                    ],
                    slategray: [
                        112,
                        128,
                        144
                    ],
                    slategrey: [
                        112,
                        128,
                        144
                    ],
                    snow: [
                        255,
                        250,
                        250
                    ],
                    springgreen: [
                        0,
                        255,
                        127
                    ],
                    steelblue: [
                        70,
                        130,
                        180
                    ],
                    tan: [
                        210,
                        180,
                        140
                    ],
                    teal: [
                        0,
                        128,
                        128
                    ],
                    thistle: [
                        216,
                        191,
                        216
                    ],
                    tomato: [
                        255,
                        99,
                        71
                    ],
                    turquoise: [
                        64,
                        224,
                        208
                    ],
                    violet: [
                        238,
                        130,
                        238
                    ],
                    wheat: [
                        245,
                        222,
                        179
                    ],
                    white: [
                        255,
                        255,
                        255
                    ],
                    whitesmoke: [
                        245,
                        245,
                        245
                    ],
                    yellow: [
                        255,
                        255,
                        0
                    ],
                    yellowgreen: [
                        154,
                        205,
                        50
                    ]
                }, S = {
                };
                for(var D in M)S[JSON.stringify(M[D])] = D;
            },
            {
            }
        ],
        4: [
            function(t, e, n) {
                var i = t(3), a = function() {
                    return new u;
                };
                for(var r in i){
                    a[r + "Raw"] = (function(t) {
                        return function(e) {
                            return "number" == typeof e && (e = Array.prototype.slice.call(arguments)), i[t](e);
                        };
                    })(r);
                    var o = /(\w+)2(\w+)/.exec(r), s = o[1], l = o[2];
                    (a[s] = a[s] || {
                    })[l] = a[r] = (function(t) {
                        return function(e) {
                            "number" == typeof e && (e = Array.prototype.slice.call(arguments));
                            var n = i[t](e);
                            if ("string" == typeof n || void 0 === n) return n;
                            for(var a = 0; a < n.length; a++)n[a] = Math.round(n[a]);
                            return n;
                        };
                    })(r);
                }
                var u = function() {
                    this.convs = {
                    };
                };
                u.prototype.routeSpace = function(t, e) {
                    var n = e[0];
                    return void 0 === n ? this.getValues(t) : ("number" == typeof n && (n = Array.prototype.slice.call(e)), this.setValues(t, n));
                }, u.prototype.setValues = function(t, e) {
                    return this.space = t, this.convs = {
                    }, this.convs[t] = e, this;
                }, u.prototype.getValues = function(t) {
                    var e = this.convs[t];
                    if (!e) {
                        var n = this.space, i = this.convs[n];
                        e = a[n][t](i), this.convs[t] = e;
                    }
                    return e;
                }, [
                    "rgb",
                    "hsl",
                    "hsv",
                    "cmyk",
                    "keyword"
                ].forEach(function(t) {
                    u.prototype[t] = function(e) {
                        return this.routeSpace(t, arguments);
                    };
                }), e.exports = a;
            },
            {
                3: 3
            }
        ],
        5: [
            function(t, e, n) {
                "use strict";
                e.exports = {
                    aliceblue: [
                        240,
                        248,
                        255
                    ],
                    antiquewhite: [
                        250,
                        235,
                        215
                    ],
                    aqua: [
                        0,
                        255,
                        255
                    ],
                    aquamarine: [
                        127,
                        255,
                        212
                    ],
                    azure: [
                        240,
                        255,
                        255
                    ],
                    beige: [
                        245,
                        245,
                        220
                    ],
                    bisque: [
                        255,
                        228,
                        196
                    ],
                    black: [
                        0,
                        0,
                        0
                    ],
                    blanchedalmond: [
                        255,
                        235,
                        205
                    ],
                    blue: [
                        0,
                        0,
                        255
                    ],
                    blueviolet: [
                        138,
                        43,
                        226
                    ],
                    brown: [
                        165,
                        42,
                        42
                    ],
                    burlywood: [
                        222,
                        184,
                        135
                    ],
                    cadetblue: [
                        95,
                        158,
                        160
                    ],
                    chartreuse: [
                        127,
                        255,
                        0
                    ],
                    chocolate: [
                        210,
                        105,
                        30
                    ],
                    coral: [
                        255,
                        127,
                        80
                    ],
                    cornflowerblue: [
                        100,
                        149,
                        237
                    ],
                    cornsilk: [
                        255,
                        248,
                        220
                    ],
                    crimson: [
                        220,
                        20,
                        60
                    ],
                    cyan: [
                        0,
                        255,
                        255
                    ],
                    darkblue: [
                        0,
                        0,
                        139
                    ],
                    darkcyan: [
                        0,
                        139,
                        139
                    ],
                    darkgoldenrod: [
                        184,
                        134,
                        11
                    ],
                    darkgray: [
                        169,
                        169,
                        169
                    ],
                    darkgreen: [
                        0,
                        100,
                        0
                    ],
                    darkgrey: [
                        169,
                        169,
                        169
                    ],
                    darkkhaki: [
                        189,
                        183,
                        107
                    ],
                    darkmagenta: [
                        139,
                        0,
                        139
                    ],
                    darkolivegreen: [
                        85,
                        107,
                        47
                    ],
                    darkorange: [
                        255,
                        140,
                        0
                    ],
                    darkorchid: [
                        153,
                        50,
                        204
                    ],
                    darkred: [
                        139,
                        0,
                        0
                    ],
                    darksalmon: [
                        233,
                        150,
                        122
                    ],
                    darkseagreen: [
                        143,
                        188,
                        143
                    ],
                    darkslateblue: [
                        72,
                        61,
                        139
                    ],
                    darkslategray: [
                        47,
                        79,
                        79
                    ],
                    darkslategrey: [
                        47,
                        79,
                        79
                    ],
                    darkturquoise: [
                        0,
                        206,
                        209
                    ],
                    darkviolet: [
                        148,
                        0,
                        211
                    ],
                    deeppink: [
                        255,
                        20,
                        147
                    ],
                    deepskyblue: [
                        0,
                        191,
                        255
                    ],
                    dimgray: [
                        105,
                        105,
                        105
                    ],
                    dimgrey: [
                        105,
                        105,
                        105
                    ],
                    dodgerblue: [
                        30,
                        144,
                        255
                    ],
                    firebrick: [
                        178,
                        34,
                        34
                    ],
                    floralwhite: [
                        255,
                        250,
                        240
                    ],
                    forestgreen: [
                        34,
                        139,
                        34
                    ],
                    fuchsia: [
                        255,
                        0,
                        255
                    ],
                    gainsboro: [
                        220,
                        220,
                        220
                    ],
                    ghostwhite: [
                        248,
                        248,
                        255
                    ],
                    gold: [
                        255,
                        215,
                        0
                    ],
                    goldenrod: [
                        218,
                        165,
                        32
                    ],
                    gray: [
                        128,
                        128,
                        128
                    ],
                    green: [
                        0,
                        128,
                        0
                    ],
                    greenyellow: [
                        173,
                        255,
                        47
                    ],
                    grey: [
                        128,
                        128,
                        128
                    ],
                    honeydew: [
                        240,
                        255,
                        240
                    ],
                    hotpink: [
                        255,
                        105,
                        180
                    ],
                    indianred: [
                        205,
                        92,
                        92
                    ],
                    indigo: [
                        75,
                        0,
                        130
                    ],
                    ivory: [
                        255,
                        255,
                        240
                    ],
                    khaki: [
                        240,
                        230,
                        140
                    ],
                    lavender: [
                        230,
                        230,
                        250
                    ],
                    lavenderblush: [
                        255,
                        240,
                        245
                    ],
                    lawngreen: [
                        124,
                        252,
                        0
                    ],
                    lemonchiffon: [
                        255,
                        250,
                        205
                    ],
                    lightblue: [
                        173,
                        216,
                        230
                    ],
                    lightcoral: [
                        240,
                        128,
                        128
                    ],
                    lightcyan: [
                        224,
                        255,
                        255
                    ],
                    lightgoldenrodyellow: [
                        250,
                        250,
                        210
                    ],
                    lightgray: [
                        211,
                        211,
                        211
                    ],
                    lightgreen: [
                        144,
                        238,
                        144
                    ],
                    lightgrey: [
                        211,
                        211,
                        211
                    ],
                    lightpink: [
                        255,
                        182,
                        193
                    ],
                    lightsalmon: [
                        255,
                        160,
                        122
                    ],
                    lightseagreen: [
                        32,
                        178,
                        170
                    ],
                    lightskyblue: [
                        135,
                        206,
                        250
                    ],
                    lightslategray: [
                        119,
                        136,
                        153
                    ],
                    lightslategrey: [
                        119,
                        136,
                        153
                    ],
                    lightsteelblue: [
                        176,
                        196,
                        222
                    ],
                    lightyellow: [
                        255,
                        255,
                        224
                    ],
                    lime: [
                        0,
                        255,
                        0
                    ],
                    limegreen: [
                        50,
                        205,
                        50
                    ],
                    linen: [
                        250,
                        240,
                        230
                    ],
                    magenta: [
                        255,
                        0,
                        255
                    ],
                    maroon: [
                        128,
                        0,
                        0
                    ],
                    mediumaquamarine: [
                        102,
                        205,
                        170
                    ],
                    mediumblue: [
                        0,
                        0,
                        205
                    ],
                    mediumorchid: [
                        186,
                        85,
                        211
                    ],
                    mediumpurple: [
                        147,
                        112,
                        219
                    ],
                    mediumseagreen: [
                        60,
                        179,
                        113
                    ],
                    mediumslateblue: [
                        123,
                        104,
                        238
                    ],
                    mediumspringgreen: [
                        0,
                        250,
                        154
                    ],
                    mediumturquoise: [
                        72,
                        209,
                        204
                    ],
                    mediumvioletred: [
                        199,
                        21,
                        133
                    ],
                    midnightblue: [
                        25,
                        25,
                        112
                    ],
                    mintcream: [
                        245,
                        255,
                        250
                    ],
                    mistyrose: [
                        255,
                        228,
                        225
                    ],
                    moccasin: [
                        255,
                        228,
                        181
                    ],
                    navajowhite: [
                        255,
                        222,
                        173
                    ],
                    navy: [
                        0,
                        0,
                        128
                    ],
                    oldlace: [
                        253,
                        245,
                        230
                    ],
                    olive: [
                        128,
                        128,
                        0
                    ],
                    olivedrab: [
                        107,
                        142,
                        35
                    ],
                    orange: [
                        255,
                        165,
                        0
                    ],
                    orangered: [
                        255,
                        69,
                        0
                    ],
                    orchid: [
                        218,
                        112,
                        214
                    ],
                    palegoldenrod: [
                        238,
                        232,
                        170
                    ],
                    palegreen: [
                        152,
                        251,
                        152
                    ],
                    paleturquoise: [
                        175,
                        238,
                        238
                    ],
                    palevioletred: [
                        219,
                        112,
                        147
                    ],
                    papayawhip: [
                        255,
                        239,
                        213
                    ],
                    peachpuff: [
                        255,
                        218,
                        185
                    ],
                    peru: [
                        205,
                        133,
                        63
                    ],
                    pink: [
                        255,
                        192,
                        203
                    ],
                    plum: [
                        221,
                        160,
                        221
                    ],
                    powderblue: [
                        176,
                        224,
                        230
                    ],
                    purple: [
                        128,
                        0,
                        128
                    ],
                    rebeccapurple: [
                        102,
                        51,
                        153
                    ],
                    red: [
                        255,
                        0,
                        0
                    ],
                    rosybrown: [
                        188,
                        143,
                        143
                    ],
                    royalblue: [
                        65,
                        105,
                        225
                    ],
                    saddlebrown: [
                        139,
                        69,
                        19
                    ],
                    salmon: [
                        250,
                        128,
                        114
                    ],
                    sandybrown: [
                        244,
                        164,
                        96
                    ],
                    seagreen: [
                        46,
                        139,
                        87
                    ],
                    seashell: [
                        255,
                        245,
                        238
                    ],
                    sienna: [
                        160,
                        82,
                        45
                    ],
                    silver: [
                        192,
                        192,
                        192
                    ],
                    skyblue: [
                        135,
                        206,
                        235
                    ],
                    slateblue: [
                        106,
                        90,
                        205
                    ],
                    slategray: [
                        112,
                        128,
                        144
                    ],
                    slategrey: [
                        112,
                        128,
                        144
                    ],
                    snow: [
                        255,
                        250,
                        250
                    ],
                    springgreen: [
                        0,
                        255,
                        127
                    ],
                    steelblue: [
                        70,
                        130,
                        180
                    ],
                    tan: [
                        210,
                        180,
                        140
                    ],
                    teal: [
                        0,
                        128,
                        128
                    ],
                    thistle: [
                        216,
                        191,
                        216
                    ],
                    tomato: [
                        255,
                        99,
                        71
                    ],
                    turquoise: [
                        64,
                        224,
                        208
                    ],
                    violet: [
                        238,
                        130,
                        238
                    ],
                    wheat: [
                        245,
                        222,
                        179
                    ],
                    white: [
                        255,
                        255,
                        255
                    ],
                    whitesmoke: [
                        245,
                        245,
                        245
                    ],
                    yellow: [
                        255,
                        255,
                        0
                    ],
                    yellowgreen: [
                        154,
                        205,
                        50
                    ]
                };
            },
            {
            }
        ],
        6: [
            function(t, e, n) {
                !function(t, i) {
                    "object" == typeof n && void 0 !== e ? e.exports = i() : t.moment = i();
                }(this, function() {
                    "use strict";
                    function n() {
                        return xe.apply(null, arguments);
                    }
                    function i(t) {
                        return t instanceof Array || "[object Array]" === Object.prototype.toString.call(t);
                    }
                    function a(t) {
                        return null != t && "[object Object]" === Object.prototype.toString.call(t);
                    }
                    function r(t) {
                        var e;
                        for(e in t)return !1;
                        return !0;
                    }
                    function o(t) {
                        return void 0 === t;
                    }
                    function s(t) {
                        return "number" == typeof t || "[object Number]" === Object.prototype.toString.call(t);
                    }
                    function l(t) {
                        return t instanceof Date || "[object Date]" === Object.prototype.toString.call(t);
                    }
                    function u(t, e) {
                        var n, i = [];
                        for(n = 0; n < t.length; ++n)i.push(e(t[n], n));
                        return i;
                    }
                    function d(t, e) {
                        return Object.prototype.hasOwnProperty.call(t, e);
                    }
                    function c(t, e) {
                        for(var n in e)d(e, n) && (t[n] = e[n]);
                        return d(e, "toString") && (t.toString = e.toString), d(e, "valueOf") && (t.valueOf = e.valueOf), t;
                    }
                    function h(t, e, n, i) {
                        return Yt(t, e, n, i, !0).utc();
                    }
                    function f() {
                        return {
                            empty: !1,
                            unusedTokens: [],
                            unusedInput: [],
                            overflow: -2,
                            charsLeftOver: 0,
                            nullInput: !1,
                            invalidMonth: null,
                            invalidFormat: !1,
                            userInvalidated: !1,
                            iso: !1,
                            parsedDateParts: [],
                            meridiem: null,
                            rfc2822: !1,
                            weekdayMismatch: !1
                        };
                    }
                    function g(t) {
                        return null == t._pf && (t._pf = f()), t._pf;
                    }
                    function m(t) {
                        if (null == t._isValid) {
                            var e = g(t), n = ke.call(e.parsedDateParts, function(t) {
                                return null != t;
                            }), i = !isNaN(t._d.getTime()) && e.overflow < 0 && !e.empty && !e.invalidMonth && !e.invalidWeekday && !e.nullInput && !e.invalidFormat && !e.userInvalidated && (!e.meridiem || e.meridiem && n);
                            if (t._strict && (i = i && 0 === e.charsLeftOver && 0 === e.unusedTokens.length && void 0 === e.bigHour), null != Object.isFrozen && Object.isFrozen(t)) return i;
                            t._isValid = i;
                        }
                        return t._isValid;
                    }
                    function p(t) {
                        var e = h(NaN);
                        return null != t ? c(g(e), t) : g(e).userInvalidated = !0, e;
                    }
                    function v(t, e) {
                        var n, i, a;
                        if (o(e._isAMomentObject) || (t._isAMomentObject = e._isAMomentObject), o(e._i) || (t._i = e._i), o(e._f) || (t._f = e._f), o(e._l) || (t._l = e._l), o(e._strict) || (t._strict = e._strict), o(e._tzm) || (t._tzm = e._tzm), o(e._isUTC) || (t._isUTC = e._isUTC), o(e._offset) || (t._offset = e._offset), o(e._pf) || (t._pf = g(e)), o(e._locale) || (t._locale = e._locale), we.length > 0) for(n = 0; n < we.length; n++)o(a = e[i = we[n]]) || (t[i] = a);
                        return t;
                    }
                    function y(t) {
                        v(this, t), this._d = new Date(null != t._d ? t._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), !1 === Me && (Me = !0, n.updateOffset(this), Me = !1);
                    }
                    function b(t) {
                        return t instanceof y || null != t && null != t._isAMomentObject;
                    }
                    function x(t) {
                        return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
                    }
                    function _(t) {
                        var e = +t, n = 0;
                        return 0 !== e && isFinite(e) && (n = x(e)), n;
                    }
                    function k(t, e, n) {
                        var i, a = Math.min(t.length, e.length), r = Math.abs(t.length - e.length), o = 0;
                        for(i = 0; i < a; i++)(n && t[i] !== e[i] || !n && _(t[i]) !== _(e[i])) && o++;
                        return o + r;
                    }
                    function w(t) {
                        !1 === n.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + t);
                    }
                    function M(t, e) {
                        var i = !0;
                        return c(function() {
                            if (null != n.deprecationHandler && n.deprecationHandler(null, t), i) {
                                for(var a, r = [], o = 0; o < arguments.length; o++){
                                    if (a = "", "object" == typeof arguments[o]) {
                                        a += "\n[" + o + "] ";
                                        for(var s in arguments[0])a += s + ": " + arguments[0][s] + ", ";
                                        a = a.slice(0, -2);
                                    } else a = arguments[o];
                                    r.push(a);
                                }
                                w(t + "\nArguments: " + Array.prototype.slice.call(r).join("") + "\n" + (new Error).stack), i = !1;
                            }
                            return e.apply(this, arguments);
                        }, e);
                    }
                    function S(t, e) {
                        null != n.deprecationHandler && n.deprecationHandler(t, e), Se[t] || (w(e), Se[t] = !0);
                    }
                    function D(t) {
                        return t instanceof Function || "[object Function]" === Object.prototype.toString.call(t);
                    }
                    function C(t, e) {
                        var n, i = c({
                        }, t);
                        for(n in e)d(e, n) && (a(t[n]) && a(e[n]) ? (i[n] = {
                        }, c(i[n], t[n]), c(i[n], e[n])) : null != e[n] ? i[n] = e[n] : delete i[n]);
                        for(n in t)d(t, n) && !d(e, n) && a(t[n]) && (i[n] = c({
                        }, i[n]));
                        return i;
                    }
                    function P(t) {
                        null != t && this.set(t);
                    }
                    function T(t, e) {
                        var n = t.toLowerCase();
                        Te[n] = Te[n + "s"] = Te[e] = t;
                    }
                    function A(t) {
                        return "string" == typeof t ? Te[t] || Te[t.toLowerCase()] : void 0;
                    }
                    function I(t) {
                        var e, n, i = {
                        };
                        for(n in t)d(t, n) && (e = A(n)) && (i[e] = t[n]);
                        return i;
                    }
                    function O(t, e) {
                        Ae[t] = e;
                    }
                    function F(t) {
                        var e = [];
                        for(var n in t)e.push({
                            unit: n,
                            priority: Ae[n]
                        });
                        return e.sort(function(t, e) {
                            return t.priority - e.priority;
                        }), e;
                    }
                    function R(t, e) {
                        return function(i) {
                            return null != i ? (W(this, t, i), n.updateOffset(this, e), this) : L(this, t);
                        };
                    }
                    function L(t, e) {
                        return t.isValid() ? t._d["get" + (t._isUTC ? "UTC" : "") + e]() : NaN;
                    }
                    function W(t, e, n) {
                        t.isValid() && t._d["set" + (t._isUTC ? "UTC" : "") + e](n);
                    }
                    function Y(t, e, n) {
                        var i = "" + Math.abs(t), a = e - i.length;
                        return (t >= 0 ? n ? "+" : "" : "-") + Math.pow(10, Math.max(0, a)).toString().substr(1) + i;
                    }
                    function N(t, e, n, i) {
                        var a = i;
                        "string" == typeof i && (a = function() {
                            return this[i]();
                        }), t && (Re[t] = a), e && (Re[e[0]] = function() {
                            return Y(a.apply(this, arguments), e[1], e[2]);
                        }), n && (Re[n] = function() {
                            return this.localeData().ordinal(a.apply(this, arguments), t);
                        });
                    }
                    function z(t) {
                        return t.match(/\[[\s\S]/) ? t.replace(/^\[|\]$/g, "") : t.replace(/\\/g, "");
                    }
                    function B(t) {
                        var e, n, i = t.match(Ie);
                        for(e = 0, n = i.length; e < n; e++)Re[i[e]] ? i[e] = Re[i[e]] : i[e] = z(i[e]);
                        return function(e) {
                            var a, r = "";
                            for(a = 0; a < n; a++)r += D(i[a]) ? i[a].call(e, t) : i[a];
                            return r;
                        };
                    }
                    function V(t, e) {
                        return t.isValid() ? (e = H(e, t.localeData()), Fe[e] = Fe[e] || B(e), Fe[e](t)) : t.localeData().invalidDate();
                    }
                    function H(t, e) {
                        var n = 5;
                        for(Oe.lastIndex = 0; n >= 0 && Oe.test(t);)t = t.replace(Oe, function(t) {
                            return e.longDateFormat(t) || t;
                        }), Oe.lastIndex = 0, n -= 1;
                        return t;
                    }
                    function E(t, e, n) {
                        Ke[t] = D(e) ? e : function(t, i) {
                            return t && n ? n : e;
                        };
                    }
                    function j(t, e) {
                        return d(Ke, t) ? Ke[t](e._strict, e._locale) : new RegExp(U(t));
                    }
                    function U(t) {
                        return q(t.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(t, e, n, i, a) {
                            return e || n || i || a;
                        }));
                    }
                    function q(t) {
                        return t.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
                    }
                    function G(t, e) {
                        var n, i = e;
                        for("string" == typeof t && (t = [
                            t
                        ]), s(e) && (i = function(t, n) {
                            n[e] = _(t);
                        }), n = 0; n < t.length; n++)Qe[t[n]] = i;
                    }
                    function Z(t, e) {
                        G(t, function(t, n, i, a) {
                            i._w = i._w || {
                            }, e(t, i._w, i, a);
                        });
                    }
                    function X(t, e, n) {
                        null != e && d(Qe, t) && Qe[t](e, n._a, n, t);
                    }
                    function J(t, e) {
                        return new Date(Date.UTC(t, e + 1, 0)).getUTCDate();
                    }
                    function K(t, e, n) {
                        var i, a, r, o = t.toLocaleLowerCase();
                        if (!this._monthsParse) for(this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], i = 0; i < 12; ++i)r = h([
                            2000,
                            i
                        ]), this._shortMonthsParse[i] = this.monthsShort(r, "").toLocaleLowerCase(), this._longMonthsParse[i] = this.months(r, "").toLocaleLowerCase();
                        return n ? "MMM" === e ? -1 !== (a = un.call(this._shortMonthsParse, o)) ? a : null : -1 !== (a = un.call(this._longMonthsParse, o)) ? a : null : "MMM" === e ? -1 !== (a = un.call(this._shortMonthsParse, o)) ? a : -1 !== (a = un.call(this._longMonthsParse, o)) ? a : null : -1 !== (a = un.call(this._longMonthsParse, o)) ? a : -1 !== (a = un.call(this._shortMonthsParse, o)) ? a : null;
                    }
                    function Q(t, e) {
                        var n;
                        if (!t.isValid()) return t;
                        if ("string" == typeof e) {
                            if (/^\d+$/.test(e)) e = _(e);
                            else if (e = t.localeData().monthsParse(e), !s(e)) return t;
                        }
                        return n = Math.min(t.date(), J(t.year(), e)), t._d["set" + (t._isUTC ? "UTC" : "") + "Month"](e, n), t;
                    }
                    function $(t) {
                        return null != t ? (Q(this, t), n.updateOffset(this, !0), this) : L(this, "Month");
                    }
                    function tt() {
                        function t(t, e) {
                            return e.length - t.length;
                        }
                        var e, n, i = [], a = [], r = [];
                        for(e = 0; e < 12; e++)n = h([
                            2000,
                            e
                        ]), i.push(this.monthsShort(n, "")), a.push(this.months(n, "")), r.push(this.months(n, "")), r.push(this.monthsShort(n, ""));
                        for(i.sort(t), a.sort(t), r.sort(t), e = 0; e < 12; e++)i[e] = q(i[e]), a[e] = q(a[e]);
                        for(e = 0; e < 24; e++)r[e] = q(r[e]);
                        this._monthsRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + a.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + i.join("|") + ")", "i");
                    }
                    function et(t) {
                        return nt(t) ? 366 : 365;
                    }
                    function nt(t) {
                        return t % 4 == 0 && t % 100 != 0 || t % 400 == 0;
                    }
                    function it(t, e, n, i, a, r, o) {
                        var s = new Date(t, e, n, i, a, r, o);
                        return t < 100 && t >= 0 && isFinite(s.getFullYear()) && s.setFullYear(t), s;
                    }
                    function at(t) {
                        var e = new Date(Date.UTC.apply(null, arguments));
                        return t < 100 && t >= 0 && isFinite(e.getUTCFullYear()) && e.setUTCFullYear(t), e;
                    }
                    function rt(t, e, n) {
                        var i = 7 + e - n;
                        return -((7 + at(t, 0, i).getUTCDay() - e) % 7) + i - 1;
                    }
                    function ot(t, e, n, i, a) {
                        var r, o, s = 1 + 7 * (e - 1) + (7 + n - i) % 7 + rt(t, i, a);
                        return s <= 0 ? o = et(r = t - 1) + s : s > et(t) ? (r = t + 1, o = s - et(t)) : (r = t, o = s), {
                            year: r,
                            dayOfYear: o
                        };
                    }
                    function st(t, e, n) {
                        var i, a, r = rt(t.year(), e, n), o = Math.floor((t.dayOfYear() - r - 1) / 7) + 1;
                        return o < 1 ? i = o + lt(a = t.year() - 1, e, n) : o > lt(t.year(), e, n) ? (i = o - lt(t.year(), e, n), a = t.year() + 1) : (a = t.year(), i = o), {
                            week: i,
                            year: a
                        };
                    }
                    function lt(t, e, n) {
                        var i = rt(t, e, n), a = rt(t + 1, e, n);
                        return (et(t) - i + a) / 7;
                    }
                    function ut(t, e) {
                        return "string" != typeof t ? t : isNaN(t) ? "number" == typeof (t = e.weekdaysParse(t)) ? t : null : parseInt(t, 10);
                    }
                    function dt(t, e) {
                        return "string" == typeof t ? e.weekdaysParse(t) % 7 || 7 : isNaN(t) ? null : t;
                    }
                    function ct(t, e, n) {
                        var i, a, r, o = t.toLocaleLowerCase();
                        if (!this._weekdaysParse) for(this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], i = 0; i < 7; ++i)r = h([
                            2000,
                            1
                        ]).day(i), this._minWeekdaysParse[i] = this.weekdaysMin(r, "").toLocaleLowerCase(), this._shortWeekdaysParse[i] = this.weekdaysShort(r, "").toLocaleLowerCase(), this._weekdaysParse[i] = this.weekdays(r, "").toLocaleLowerCase();
                        return n ? "dddd" === e ? -1 !== (a = un.call(this._weekdaysParse, o)) ? a : null : "ddd" === e ? -1 !== (a = un.call(this._shortWeekdaysParse, o)) ? a : null : -1 !== (a = un.call(this._minWeekdaysParse, o)) ? a : null : "dddd" === e ? -1 !== (a = un.call(this._weekdaysParse, o)) ? a : -1 !== (a = un.call(this._shortWeekdaysParse, o)) ? a : -1 !== (a = un.call(this._minWeekdaysParse, o)) ? a : null : "ddd" === e ? -1 !== (a = un.call(this._shortWeekdaysParse, o)) ? a : -1 !== (a = un.call(this._weekdaysParse, o)) ? a : -1 !== (a = un.call(this._minWeekdaysParse, o)) ? a : null : -1 !== (a = un.call(this._minWeekdaysParse, o)) ? a : -1 !== (a = un.call(this._weekdaysParse, o)) ? a : -1 !== (a = un.call(this._shortWeekdaysParse, o)) ? a : null;
                    }
                    function ht() {
                        function t(t, e) {
                            return e.length - t.length;
                        }
                        var e, n, i, a, r, o = [], s = [], l = [], u = [];
                        for(e = 0; e < 7; e++)n = h([
                            2000,
                            1
                        ]).day(e), i = this.weekdaysMin(n, ""), a = this.weekdaysShort(n, ""), r = this.weekdays(n, ""), o.push(i), s.push(a), l.push(r), u.push(i), u.push(a), u.push(r);
                        for(o.sort(t), s.sort(t), l.sort(t), u.sort(t), e = 0; e < 7; e++)s[e] = q(s[e]), l[e] = q(l[e]), u[e] = q(u[e]);
                        this._weekdaysRegex = new RegExp("^(" + u.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + l.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + s.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + o.join("|") + ")", "i");
                    }
                    function ft() {
                        return this.hours() % 12 || 12;
                    }
                    function gt(t, e) {
                        N(t, 0, 0, function() {
                            return this.localeData().meridiem(this.hours(), this.minutes(), e);
                        });
                    }
                    function mt(t, e) {
                        return e._meridiemParse;
                    }
                    function pt(t) {
                        return t ? t.toLowerCase().replace("_", "-") : t;
                    }
                    function vt(t) {
                        for(var e, n, i, a, r = 0; r < t.length;){
                            for(e = (a = pt(t[r]).split("-")).length, n = (n = pt(t[r + 1])) ? n.split("-") : null; e > 0;){
                                if (i = yt(a.slice(0, e).join("-"))) return i;
                                if (n && n.length >= e && k(a, n, !0) >= e - 1) break;
                                e--;
                            }
                            r++;
                        }
                        return null;
                    }
                    function yt(n) {
                        var i = null;
                        if (!Sn[n] && void 0 !== e && e && e.exports) try {
                            i = kn._abbr, t("./locale/" + n), bt(i);
                        } catch (t14) {
                        }
                        return Sn[n];
                    }
                    function bt(t, e) {
                        var n;
                        return t && (n = o(e) ? _t(t) : xt(t, e)) && (kn = n), kn._abbr;
                    }
                    function xt(t, e) {
                        if (null !== e) {
                            var n = Mn;
                            if (e.abbr = t, null != Sn[t]) S("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), n = Sn[t]._config;
                            else if (null != e.parentLocale) {
                                if (null == Sn[e.parentLocale]) return Dn[e.parentLocale] || (Dn[e.parentLocale] = []), Dn[e.parentLocale].push({
                                    name: t,
                                    config: e
                                }), null;
                                n = Sn[e.parentLocale]._config;
                            }
                            return Sn[t] = new P(C(n, e)), Dn[t] && Dn[t].forEach(function(t) {
                                xt(t.name, t.config);
                            }), bt(t), Sn[t];
                        }
                        return delete Sn[t], null;
                    }
                    function _t(t) {
                        var e;
                        if (t && t._locale && t._locale._abbr && (t = t._locale._abbr), !t) return kn;
                        if (!i(t)) {
                            if (e = yt(t)) return e;
                            t = [
                                t
                            ];
                        }
                        return vt(t);
                    }
                    function kt(t) {
                        var e, n = t._a;
                        return n && -2 === g(t).overflow && (e = n[tn] < 0 || n[tn] > 11 ? tn : n[en] < 1 || n[en] > J(n[$e], n[tn]) ? en : n[nn] < 0 || n[nn] > 24 || 24 === n[nn] && (0 !== n[an] || 0 !== n[rn] || 0 !== n[on]) ? nn : n[an] < 0 || n[an] > 59 ? an : n[rn] < 0 || n[rn] > 59 ? rn : n[on] < 0 || n[on] > 999 ? on : -1, g(t)._overflowDayOfYear && (e < $e || e > en) && (e = en), g(t)._overflowWeeks && -1 === e && (e = sn), g(t)._overflowWeekday && -1 === e && (e = ln), g(t).overflow = e), t;
                    }
                    function wt(t) {
                        var e, n, i, a, r, o, s = t._i, l = Cn.exec(s) || Pn.exec(s);
                        if (l) {
                            for(g(t).iso = !0, e = 0, n = An.length; e < n; e++)if (An[e][1].exec(l[1])) {
                                a = An[e][0], i = !1 !== An[e][2];
                                break;
                            }
                            if (null == a) return void (t._isValid = !1);
                            if (l[3]) {
                                for(e = 0, n = In.length; e < n; e++)if (In[e][1].exec(l[3])) {
                                    r = (l[2] || " ") + In[e][0];
                                    break;
                                }
                                if (null == r) return void (t._isValid = !1);
                            }
                            if (!i && null != r) return void (t._isValid = !1);
                            if (l[4]) {
                                if (!Tn.exec(l[4])) return void (t._isValid = !1);
                                o = "Z";
                            }
                            t._f = a + (r || "") + (o || ""), At(t);
                        } else t._isValid = !1;
                    }
                    function Mt(t) {
                        var e, n, i, a, r, o, s, l, u = {
                            " GMT": " +0000",
                            " EDT": " -0400",
                            " EST": " -0500",
                            " CDT": " -0500",
                            " CST": " -0600",
                            " MDT": " -0600",
                            " MST": " -0700",
                            " PDT": " -0700",
                            " PST": " -0800"
                        };
                        if (e = t._i.replace(/\([^\)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s|\s$/g, ""), n = Fn.exec(e)) {
                            if (i = n[1] ? "ddd" + (5 === n[1].length ? ", " : " ") : "", a = "D MMM " + (n[2].length > 10 ? "YYYY " : "YY "), r = "HH:mm" + (n[4] ? ":ss" : ""), n[1]) {
                                var d = [
                                    "Sun",
                                    "Mon",
                                    "Tue",
                                    "Wed",
                                    "Thu",
                                    "Fri",
                                    "Sat"
                                ][new Date(n[2]).getDay()];
                                if (n[1].substr(0, 3) !== d) return g(t).weekdayMismatch = !0, void (t._isValid = !1);
                            }
                            switch(n[5].length){
                                case 2:
                                    s = 0 === l ? " +0000" : ((l = "YXWVUTSRQPONZABCDEFGHIKLM".indexOf(n[5][1].toUpperCase()) - 12) < 0 ? " -" : " +") + ("" + l).replace(/^-?/, "0").match(/..$/)[0] + "00";
                                    break;
                                case 4:
                                    s = u[n[5]];
                                    break;
                                default:
                                    s = u[" GMT"];
                            }
                            n[5] = s, t._i = n.splice(1).join(""), o = " ZZ", t._f = i + a + r + o, At(t), g(t).rfc2822 = !0;
                        } else t._isValid = !1;
                    }
                    function St(t) {
                        var e = On.exec(t._i);
                        null === e ? (wt(t), !1 === t._isValid && (delete t._isValid, Mt(t), !1 === t._isValid && (delete t._isValid, n.createFromInputFallback(t)))) : t._d = new Date(+e[1]);
                    }
                    function Dt(t, e, n) {
                        return null != t ? t : null != e ? e : n;
                    }
                    function Ct(t) {
                        var e = new Date(n.now());
                        return t._useUTC ? [
                            e.getUTCFullYear(),
                            e.getUTCMonth(),
                            e.getUTCDate()
                        ] : [
                            e.getFullYear(),
                            e.getMonth(),
                            e.getDate()
                        ];
                    }
                    function Pt(t) {
                        var e, n, i, a, r = [];
                        if (!t._d) {
                            for(i = Ct(t), t._w && null == t._a[en] && null == t._a[tn] && Tt(t), null != t._dayOfYear && (a = Dt(t._a[$e], i[$e]), (t._dayOfYear > et(a) || 0 === t._dayOfYear) && (g(t)._overflowDayOfYear = !0), n = at(a, 0, t._dayOfYear), t._a[tn] = n.getUTCMonth(), t._a[en] = n.getUTCDate()), e = 0; e < 3 && null == t._a[e]; ++e)t._a[e] = r[e] = i[e];
                            for(; e < 7; e++)t._a[e] = r[e] = null == t._a[e] ? 2 === e ? 1 : 0 : t._a[e];
                            24 === t._a[nn] && 0 === t._a[an] && 0 === t._a[rn] && 0 === t._a[on] && (t._nextDay = !0, t._a[nn] = 0), t._d = (t._useUTC ? at : it).apply(null, r), null != t._tzm && t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), t._nextDay && (t._a[nn] = 24);
                        }
                    }
                    function Tt(t) {
                        var e, n, i, a, r, o, s, l;
                        if (null != (e = t._w).GG || null != e.W || null != e.E) r = 1, o = 4, n = Dt(e.GG, t._a[$e], st(Nt(), 1, 4).year), i = Dt(e.W, 1), ((a = Dt(e.E, 1)) < 1 || a > 7) && (l = !0);
                        else {
                            r = t._locale._week.dow, o = t._locale._week.doy;
                            var u = st(Nt(), r, o);
                            n = Dt(e.gg, t._a[$e], u.year), i = Dt(e.w, u.week), null != e.d ? ((a = e.d) < 0 || a > 6) && (l = !0) : null != e.e ? (a = e.e + r, (e.e < 0 || e.e > 6) && (l = !0)) : a = r;
                        }
                        i < 1 || i > lt(n, r, o) ? g(t)._overflowWeeks = !0 : null != l ? g(t)._overflowWeekday = !0 : (s = ot(n, i, a, r, o), t._a[$e] = s.year, t._dayOfYear = s.dayOfYear);
                    }
                    function At(t) {
                        if (t._f !== n.ISO_8601) if (t._f !== n.RFC_2822) {
                            t._a = [], g(t).empty = !0;
                            var e, i, a, r, o, s = "" + t._i, l = s.length, u = 0;
                            for(a = H(t._f, t._locale).match(Ie) || [], e = 0; e < a.length; e++)r = a[e], (i = (s.match(j(r, t)) || [])[0]) && ((o = s.substr(0, s.indexOf(i))).length > 0 && g(t).unusedInput.push(o), s = s.slice(s.indexOf(i) + i.length), u += i.length), Re[r] ? (i ? g(t).empty = !1 : g(t).unusedTokens.push(r), X(r, i, t)) : t._strict && !i && g(t).unusedTokens.push(r);
                            g(t).charsLeftOver = l - u, s.length > 0 && g(t).unusedInput.push(s), t._a[nn] <= 12 && !0 === g(t).bigHour && t._a[nn] > 0 && (g(t).bigHour = void 0), g(t).parsedDateParts = t._a.slice(0), g(t).meridiem = t._meridiem, t._a[nn] = It(t._locale, t._a[nn], t._meridiem), Pt(t), kt(t);
                        } else Mt(t);
                        else wt(t);
                    }
                    function It(t, e, n) {
                        var i;
                        return null == n ? e : null != t.meridiemHour ? t.meridiemHour(e, n) : null != t.isPM ? ((i = t.isPM(n)) && e < 12 && (e += 12), i || 12 !== e || (e = 0), e) : e;
                    }
                    function Ot(t) {
                        var e, n, i, a, r;
                        if (0 === t._f.length) return g(t).invalidFormat = !0, void (t._d = new Date(NaN));
                        for(a = 0; a < t._f.length; a++)r = 0, e = v({
                        }, t), null != t._useUTC && (e._useUTC = t._useUTC), e._f = t._f[a], At(e), m(e) && (r += g(e).charsLeftOver, r += 10 * g(e).unusedTokens.length, g(e).score = r, (null == i || r < i) && (i = r, n = e));
                        c(t, n || e);
                    }
                    function Ft(t) {
                        if (!t._d) {
                            var e = I(t._i);
                            t._a = u([
                                e.year,
                                e.month,
                                e.day || e.date,
                                e.hour,
                                e.minute,
                                e.second,
                                e.millisecond
                            ], function(t) {
                                return t && parseInt(t, 10);
                            }), Pt(t);
                        }
                    }
                    function Rt(t) {
                        var e = new y(kt(Lt(t)));
                        return e._nextDay && (e.add(1, "d"), e._nextDay = void 0), e;
                    }
                    function Lt(t) {
                        var e = t._i, n = t._f;
                        return t._locale = t._locale || _t(t._l), null === e || void 0 === n && "" === e ? p({
                            nullInput: !0
                        }) : ("string" == typeof e && (t._i = e = t._locale.preparse(e)), b(e) ? new y(kt(e)) : (l(e) ? t._d = e : i(n) ? Ot(t) : n ? At(t) : Wt(t), m(t) || (t._d = null), t));
                    }
                    function Wt(t) {
                        var e = t._i;
                        o(e) ? t._d = new Date(n.now()) : l(e) ? t._d = new Date(e.valueOf()) : "string" == typeof e ? St(t) : i(e) ? (t._a = u(e.slice(0), function(t) {
                            return parseInt(t, 10);
                        }), Pt(t)) : a(e) ? Ft(t) : s(e) ? t._d = new Date(e) : n.createFromInputFallback(t);
                    }
                    function Yt(t, e, n, o, s) {
                        var l = {
                        };
                        return !0 !== n && !1 !== n || (o = n, n = void 0), (a(t) && r(t) || i(t) && 0 === t.length) && (t = void 0), l._isAMomentObject = !0, l._useUTC = l._isUTC = s, l._l = n, l._i = t, l._f = e, l._strict = o, Rt(l);
                    }
                    function Nt(t, e, n, i) {
                        return Yt(t, e, n, i, !1);
                    }
                    function zt(t, e) {
                        var n, a;
                        if (1 === e.length && i(e[0]) && (e = e[0]), !e.length) return Nt();
                        for(n = e[0], a = 1; a < e.length; ++a)e[a].isValid() && !e[a][t](n) || (n = e[a]);
                        return n;
                    }
                    function Bt(t) {
                        for(var e in t)if (-1 === Wn.indexOf(e) || null != t[e] && isNaN(t[e])) return !1;
                        for(var n = !1, i = 0; i < Wn.length; ++i)if (t[Wn[i]]) {
                            if (n) return !1;
                            parseFloat(t[Wn[i]]) !== _(t[Wn[i]]) && (n = !0);
                        }
                        return !0;
                    }
                    function Vt(t) {
                        var e = I(t), n = e.year || 0, i = e.quarter || 0, a = e.month || 0, r = e.week || 0, o = e.day || 0, s = e.hour || 0, l = e.minute || 0, u = e.second || 0, d = e.millisecond || 0;
                        this._isValid = Bt(e), this._milliseconds = +d + 1000 * u + 60000 * l + 1000 * s * 60 * 60, this._days = +o + 7 * r, this._months = +a + 3 * i + 12 * n, this._data = {
                        }, this._locale = _t(), this._bubble();
                    }
                    function Ht(t) {
                        return t instanceof Vt;
                    }
                    function Et(t) {
                        return t < 0 ? -1 * Math.round(-1 * t) : Math.round(t);
                    }
                    function jt(t, e) {
                        N(t, 0, 0, function() {
                            var t = this.utcOffset(), n = "+";
                            return t < 0 && (t = -t, n = "-"), n + Y(~~(t / 60), 2) + e + Y(~~t % 60, 2);
                        });
                    }
                    function Ut(t, e) {
                        var n = (e || "").match(t);
                        if (null === n) return null;
                        var i = ((n[n.length - 1] || []) + "").match(Yn) || [
                            "-",
                            0,
                            0
                        ], a = 60 * i[1] + _(i[2]);
                        return 0 === a ? 0 : "+" === i[0] ? a : -a;
                    }
                    function qt(t, e) {
                        var i, a;
                        return e._isUTC ? (i = e.clone(), a = (b(t) || l(t) ? t.valueOf() : Nt(t).valueOf()) - i.valueOf(), i._d.setTime(i._d.valueOf() + a), n.updateOffset(i, !1), i) : Nt(t).local();
                    }
                    function Gt(t) {
                        return 15 * -Math.round(t._d.getTimezoneOffset() / 15);
                    }
                    function Zt() {
                        return !!this.isValid() && this._isUTC && 0 === this._offset;
                    }
                    function Xt(t, e) {
                        var n, i, a, r = t, o = null;
                        return Ht(t) ? r = {
                            ms: t._milliseconds,
                            d: t._days,
                            M: t._months
                        } : s(t) ? (r = {
                        }, e ? r[e] = t : r.milliseconds = t) : (o = Nn.exec(t)) ? (n = "-" === o[1] ? -1 : 1, r = {
                            y: 0,
                            d: _(o[en]) * n,
                            h: _(o[nn]) * n,
                            m: _(o[an]) * n,
                            s: _(o[rn]) * n,
                            ms: _(Et(1000 * o[on])) * n
                        }) : (o = zn.exec(t)) ? (n = "-" === o[1] ? -1 : 1, r = {
                            y: Jt(o[2], n),
                            M: Jt(o[3], n),
                            w: Jt(o[4], n),
                            d: Jt(o[5], n),
                            h: Jt(o[6], n),
                            m: Jt(o[7], n),
                            s: Jt(o[8], n)
                        }) : null == r ? r = {
                        } : "object" == typeof r && ("from" in r || "to" in r) && (a = Qt(Nt(r.from), Nt(r.to)), (r = {
                        }).ms = a.milliseconds, r.M = a.months), i = new Vt(r), Ht(t) && d(t, "_locale") && (i._locale = t._locale), i;
                    }
                    function Jt(t, e) {
                        var n = t && parseFloat(t.replace(",", "."));
                        return (isNaN(n) ? 0 : n) * e;
                    }
                    function Kt(t, e) {
                        var n = {
                            milliseconds: 0,
                            months: 0
                        };
                        return n.months = e.month() - t.month() + 12 * (e.year() - t.year()), t.clone().add(n.months, "M").isAfter(e) && --n.months, n.milliseconds = +e - +t.clone().add(n.months, "M"), n;
                    }
                    function Qt(t, e) {
                        var n;
                        return t.isValid() && e.isValid() ? (e = qt(e, t), t.isBefore(e) ? n = Kt(t, e) : ((n = Kt(e, t)).milliseconds = -n.milliseconds, n.months = -n.months), n) : {
                            milliseconds: 0,
                            months: 0
                        };
                    }
                    function $t(t, e) {
                        return function(n, i) {
                            var a, r;
                            return null === i || isNaN(+i) || (S(e, "moment()." + e + "(period, number) is deprecated. Please use moment()." + e + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), r = n, n = i, i = r), n = "string" == typeof n ? +n : n, a = Xt(n, i), te(this, a, t), this;
                        };
                    }
                    function te(t, e, i, a) {
                        var r = e._milliseconds, o = Et(e._days), s = Et(e._months);
                        t.isValid() && (a = null == a || a, r && t._d.setTime(t._d.valueOf() + r * i), o && W(t, "Date", L(t, "Date") + o * i), s && Q(t, L(t, "Month") + s * i), a && n.updateOffset(t, o || s));
                    }
                    function ee(t, e) {
                        var n, i = 12 * (e.year() - t.year()) + (e.month() - t.month()), a = t.clone().add(i, "months");
                        return n = e - a < 0 ? (e - a) / (a - t.clone().add(i - 1, "months")) : (e - a) / (t.clone().add(i + 1, "months") - a), -(i + n) || 0;
                    }
                    function ne(t) {
                        var e;
                        return void 0 === t ? this._locale._abbr : (null != (e = _t(t)) && (this._locale = e), this);
                    }
                    function ie() {
                        return this._locale;
                    }
                    function ae(t, e) {
                        N(0, [
                            t,
                            t.length
                        ], 0, e);
                    }
                    function re(t, e, n, i, a) {
                        var r;
                        return null == t ? st(this, i, a).year : (r = lt(t, i, a), e > r && (e = r), oe.call(this, t, e, n, i, a));
                    }
                    function oe(t, e, n, i, a) {
                        var r = ot(t, e, n, i, a), o = at(r.year, 0, r.dayOfYear);
                        return this.year(o.getUTCFullYear()), this.month(o.getUTCMonth()), this.date(o.getUTCDate()), this;
                    }
                    function se(t) {
                        return t;
                    }
                    function le(t, e, n, i) {
                        var a = _t(), r = h().set(i, e);
                        return a[n](r, t);
                    }
                    function ue(t, e, n) {
                        if (s(t) && (e = t, t = void 0), t = t || "", null != e) return le(t, e, n, "month");
                        var i, a = [];
                        for(i = 0; i < 12; i++)a[i] = le(t, i, n, "month");
                        return a;
                    }
                    function de(t, e, n, i) {
                        "boolean" == typeof t ? (s(e) && (n = e, e = void 0), e = e || "") : (n = e = t, t = !1, s(e) && (n = e, e = void 0), e = e || "");
                        var a = _t(), r = t ? a._week.dow : 0;
                        if (null != n) return le(e, (n + r) % 7, i, "day");
                        var o, l = [];
                        for(o = 0; o < 7; o++)l[o] = le(e, (o + r) % 7, i, "day");
                        return l;
                    }
                    function ce(t, e, n, i) {
                        var a = Xt(e, n);
                        return t._milliseconds += i * a._milliseconds, t._days += i * a._days, t._months += i * a._months, t._bubble();
                    }
                    function he(t) {
                        return t < 0 ? Math.floor(t) : Math.ceil(t);
                    }
                    function fe(t) {
                        return 4800 * t / 146097;
                    }
                    function ge(t) {
                        return 146097 * t / 4800;
                    }
                    function me(t) {
                        return function() {
                            return this.as(t);
                        };
                    }
                    function pe(t) {
                        return function() {
                            return this.isValid() ? this._data[t] : NaN;
                        };
                    }
                    function ve(t, e, n, i, a) {
                        return a.relativeTime(e || 1, !!n, t, i);
                    }
                    function ye(t, e, n) {
                        var i = Xt(t).abs(), a = hi(i.as("s")), r = hi(i.as("m")), o = hi(i.as("h")), s = hi(i.as("d")), l = hi(i.as("M")), u = hi(i.as("y")), d = a <= fi.ss && [
                            "s",
                            a
                        ] || a < fi.s && [
                            "ss",
                            a
                        ] || r <= 1 && [
                            "m"
                        ] || r < fi.m && [
                            "mm",
                            r
                        ] || o <= 1 && [
                            "h"
                        ] || o < fi.h && [
                            "hh",
                            o
                        ] || s <= 1 && [
                            "d"
                        ] || s < fi.d && [
                            "dd",
                            s
                        ] || l <= 1 && [
                            "M"
                        ] || l < fi.M && [
                            "MM",
                            l
                        ] || u <= 1 && [
                            "y"
                        ] || [
                            "yy",
                            u
                        ];
                        return d[2] = e, d[3] = +t > 0, d[4] = n, ve.apply(null, d);
                    }
                    function be() {
                        if (!this.isValid()) return this.localeData().invalidDate();
                        var t, e, n, i = gi(this._milliseconds) / 1000, a = gi(this._days), r = gi(this._months);
                        e = x((t = x(i / 60)) / 60), i %= 60, t %= 60;
                        var o = n = x(r / 12), s = r %= 12, l = a, u = e, d = t, c = i, h = this.asSeconds();
                        return h ? (h < 0 ? "-" : "") + "P" + (o ? o + "Y" : "") + (s ? s + "M" : "") + (l ? l + "D" : "") + (u || d || c ? "T" : "") + (u ? u + "H" : "") + (d ? d + "M" : "") + (c ? c + "S" : "") : "P0D";
                    }
                    var xe, _e, ke = _e = Array.prototype.some ? Array.prototype.some : function(t) {
                        for(var e = Object(this), n = e.length >>> 0, i = 0; i < n; i++)if (i in e && t.call(this, e[i], i, e)) return !0;
                        return !1;
                    }, we = n.momentProperties = [], Me = !1, Se = {
                    };
                    n.suppressDeprecationWarnings = !1, n.deprecationHandler = null;
                    var De, Ce, Pe = De = Object.keys ? Object.keys : function(t) {
                        var e, n = [];
                        for(e in t)d(t, e) && n.push(e);
                        return n;
                    }, Te = {
                    }, Ae = {
                    }, Ie = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, Oe = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, Fe = {
                    }, Re = {
                    }, Le = /\d/, We = /\d\d/, Ye = /\d{3}/, Ne = /\d{4}/, ze = /[+-]?\d{6}/, Be = /\d\d?/, Ve = /\d\d\d\d?/, He = /\d\d\d\d\d\d?/, Ee = /\d{1,3}/, je = /\d{1,4}/, Ue = /[+-]?\d{1,6}/, qe = /\d+/, Ge = /[+-]?\d+/, Ze = /Z|[+-]\d\d:?\d\d/gi, Xe = /Z|[+-]\d\d(?::?\d\d)?/gi, Je = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, Ke = {
                    }, Qe = {
                    }, $e = 0, tn = 1, en = 2, nn = 3, an = 4, rn = 5, on = 6, sn = 7, ln = 8, un = Ce = Array.prototype.indexOf ? Array.prototype.indexOf : function(t) {
                        var e;
                        for(e = 0; e < this.length; ++e)if (this[e] === t) return e;
                        return -1;
                    };
                    N("M", [
                        "MM",
                        2
                    ], "Mo", function() {
                        return this.month() + 1;
                    }), N("MMM", 0, 0, function(t) {
                        return this.localeData().monthsShort(this, t);
                    }), N("MMMM", 0, 0, function(t) {
                        return this.localeData().months(this, t);
                    }), T("month", "M"), O("month", 8), E("M", Be), E("MM", Be, We), E("MMM", function(t, e) {
                        return e.monthsShortRegex(t);
                    }), E("MMMM", function(t, e) {
                        return e.monthsRegex(t);
                    }), G([
                        "M",
                        "MM"
                    ], function(t, e) {
                        e[tn] = _(t) - 1;
                    }), G([
                        "MMM",
                        "MMMM"
                    ], function(t, e, n, i) {
                        var a = n._locale.monthsParse(t, i, n._strict);
                        null != a ? e[tn] = a : g(n).invalidMonth = t;
                    });
                    var dn = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, cn = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), hn = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), fn = Je, gn = Je;
                    N("Y", 0, 0, function() {
                        var t = this.year();
                        return t <= 9999 ? "" + t : "+" + t;
                    }), N(0, [
                        "YY",
                        2
                    ], 0, function() {
                        return this.year() % 100;
                    }), N(0, [
                        "YYYY",
                        4
                    ], 0, "year"), N(0, [
                        "YYYYY",
                        5
                    ], 0, "year"), N(0, [
                        "YYYYYY",
                        6,
                        !0
                    ], 0, "year"), T("year", "y"), O("year", 1), E("Y", Ge), E("YY", Be, We), E("YYYY", je, Ne), E("YYYYY", Ue, ze), E("YYYYYY", Ue, ze), G([
                        "YYYYY",
                        "YYYYYY"
                    ], $e), G("YYYY", function(t, e) {
                        e[$e] = 2 === t.length ? n.parseTwoDigitYear(t) : _(t);
                    }), G("YY", function(t, e) {
                        e[$e] = n.parseTwoDigitYear(t);
                    }), G("Y", function(t, e) {
                        e[$e] = parseInt(t, 10);
                    }), n.parseTwoDigitYear = function(t) {
                        return _(t) + (_(t) > 68 ? 1900 : 2000);
                    };
                    var mn = R("FullYear", !0);
                    N("w", [
                        "ww",
                        2
                    ], "wo", "week"), N("W", [
                        "WW",
                        2
                    ], "Wo", "isoWeek"), T("week", "w"), T("isoWeek", "W"), O("week", 5), O("isoWeek", 5), E("w", Be), E("ww", Be, We), E("W", Be), E("WW", Be, We), Z([
                        "w",
                        "ww",
                        "W",
                        "WW"
                    ], function(t, e, n, i) {
                        e[i.substr(0, 1)] = _(t);
                    });
                    N("d", 0, "do", "day"), N("dd", 0, 0, function(t) {
                        return this.localeData().weekdaysMin(this, t);
                    }), N("ddd", 0, 0, function(t) {
                        return this.localeData().weekdaysShort(this, t);
                    }), N("dddd", 0, 0, function(t) {
                        return this.localeData().weekdays(this, t);
                    }), N("e", 0, 0, "weekday"), N("E", 0, 0, "isoWeekday"), T("day", "d"), T("weekday", "e"), T("isoWeekday", "E"), O("day", 11), O("weekday", 11), O("isoWeekday", 11), E("d", Be), E("e", Be), E("E", Be), E("dd", function(t, e) {
                        return e.weekdaysMinRegex(t);
                    }), E("ddd", function(t, e) {
                        return e.weekdaysShortRegex(t);
                    }), E("dddd", function(t, e) {
                        return e.weekdaysRegex(t);
                    }), Z([
                        "dd",
                        "ddd",
                        "dddd"
                    ], function(t, e, n, i) {
                        var a = n._locale.weekdaysParse(t, i, n._strict);
                        null != a ? e.d = a : g(n).invalidWeekday = t;
                    }), Z([
                        "d",
                        "e",
                        "E"
                    ], function(t, e, n, i) {
                        e[i] = _(t);
                    });
                    var pn = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), vn = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), yn = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), bn = Je, xn = Je, _n = Je;
                    N("H", [
                        "HH",
                        2
                    ], 0, "hour"), N("h", [
                        "hh",
                        2
                    ], 0, ft), N("k", [
                        "kk",
                        2
                    ], 0, function() {
                        return this.hours() || 24;
                    }), N("hmm", 0, 0, function() {
                        return "" + ft.apply(this) + Y(this.minutes(), 2);
                    }), N("hmmss", 0, 0, function() {
                        return "" + ft.apply(this) + Y(this.minutes(), 2) + Y(this.seconds(), 2);
                    }), N("Hmm", 0, 0, function() {
                        return "" + this.hours() + Y(this.minutes(), 2);
                    }), N("Hmmss", 0, 0, function() {
                        return "" + this.hours() + Y(this.minutes(), 2) + Y(this.seconds(), 2);
                    }), gt("a", !0), gt("A", !1), T("hour", "h"), O("hour", 13), E("a", mt), E("A", mt), E("H", Be), E("h", Be), E("k", Be), E("HH", Be, We), E("hh", Be, We), E("kk", Be, We), E("hmm", Ve), E("hmmss", He), E("Hmm", Ve), E("Hmmss", He), G([
                        "H",
                        "HH"
                    ], nn), G([
                        "k",
                        "kk"
                    ], function(t, e, n) {
                        var i = _(t);
                        e[nn] = 24 === i ? 0 : i;
                    }), G([
                        "a",
                        "A"
                    ], function(t, e, n) {
                        n._isPm = n._locale.isPM(t), n._meridiem = t;
                    }), G([
                        "h",
                        "hh"
                    ], function(t, e, n) {
                        e[nn] = _(t), g(n).bigHour = !0;
                    }), G("hmm", function(t, e, n) {
                        var i = t.length - 2;
                        e[nn] = _(t.substr(0, i)), e[an] = _(t.substr(i)), g(n).bigHour = !0;
                    }), G("hmmss", function(t, e, n) {
                        var i = t.length - 4, a = t.length - 2;
                        e[nn] = _(t.substr(0, i)), e[an] = _(t.substr(i, 2)), e[rn] = _(t.substr(a)), g(n).bigHour = !0;
                    }), G("Hmm", function(t, e, n) {
                        var i = t.length - 2;
                        e[nn] = _(t.substr(0, i)), e[an] = _(t.substr(i));
                    }), G("Hmmss", function(t, e, n) {
                        var i = t.length - 4, a = t.length - 2;
                        e[nn] = _(t.substr(0, i)), e[an] = _(t.substr(i, 2)), e[rn] = _(t.substr(a));
                    });
                    var kn, wn = R("Hours", !0), Mn = {
                        calendar: {
                            sameDay: "[Today at] LT",
                            nextDay: "[Tomorrow at] LT",
                            nextWeek: "dddd [at] LT",
                            lastDay: "[Yesterday at] LT",
                            lastWeek: "[Last] dddd [at] LT",
                            sameElse: "L"
                        },
                        longDateFormat: {
                            LTS: "h:mm:ss A",
                            LT: "h:mm A",
                            L: "MM/DD/YYYY",
                            LL: "MMMM D, YYYY",
                            LLL: "MMMM D, YYYY h:mm A",
                            LLLL: "dddd, MMMM D, YYYY h:mm A"
                        },
                        invalidDate: "Invalid date",
                        ordinal: "%d",
                        dayOfMonthOrdinalParse: /\d{1,2}/,
                        relativeTime: {
                            future: "in %s",
                            past: "%s ago",
                            s: "a few seconds",
                            ss: "%d seconds",
                            m: "a minute",
                            mm: "%d minutes",
                            h: "an hour",
                            hh: "%d hours",
                            d: "a day",
                            dd: "%d days",
                            M: "a month",
                            MM: "%d months",
                            y: "a year",
                            yy: "%d years"
                        },
                        months: cn,
                        monthsShort: hn,
                        week: {
                            dow: 0,
                            doy: 6
                        },
                        weekdays: pn,
                        weekdaysMin: yn,
                        weekdaysShort: vn,
                        meridiemParse: /[ap]\.?m?\.?/i
                    }, Sn = {
                    }, Dn = {
                    }, Cn = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, Pn = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, Tn = /Z|[+-]\d\d(?::?\d\d)?/, An = [
                        [
                            "YYYYYY-MM-DD",
                            /[+-]\d{6}-\d\d-\d\d/
                        ],
                        [
                            "YYYY-MM-DD",
                            /\d{4}-\d\d-\d\d/
                        ],
                        [
                            "GGGG-[W]WW-E",
                            /\d{4}-W\d\d-\d/
                        ],
                        [
                            "GGGG-[W]WW",
                            /\d{4}-W\d\d/,
                            !1
                        ],
                        [
                            "YYYY-DDD",
                            /\d{4}-\d{3}/
                        ],
                        [
                            "YYYY-MM",
                            /\d{4}-\d\d/,
                            !1
                        ],
                        [
                            "YYYYYYMMDD",
                            /[+-]\d{10}/
                        ],
                        [
                            "YYYYMMDD",
                            /\d{8}/
                        ],
                        [
                            "GGGG[W]WWE",
                            /\d{4}W\d{3}/
                        ],
                        [
                            "GGGG[W]WW",
                            /\d{4}W\d{2}/,
                            !1
                        ],
                        [
                            "YYYYDDD",
                            /\d{7}/
                        ]
                    ], In = [
                        [
                            "HH:mm:ss.SSSS",
                            /\d\d:\d\d:\d\d\.\d+/
                        ],
                        [
                            "HH:mm:ss,SSSS",
                            /\d\d:\d\d:\d\d,\d+/
                        ],
                        [
                            "HH:mm:ss",
                            /\d\d:\d\d:\d\d/
                        ],
                        [
                            "HH:mm",
                            /\d\d:\d\d/
                        ],
                        [
                            "HHmmss.SSSS",
                            /\d\d\d\d\d\d\.\d+/
                        ],
                        [
                            "HHmmss,SSSS",
                            /\d\d\d\d\d\d,\d+/
                        ],
                        [
                            "HHmmss",
                            /\d\d\d\d\d\d/
                        ],
                        [
                            "HHmm",
                            /\d\d\d\d/
                        ],
                        [
                            "HH",
                            /\d\d/
                        ]
                    ], On = /^\/?Date\((\-?\d+)/i, Fn = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/;
                    n.createFromInputFallback = M("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(t) {
                        t._d = new Date(t._i + (t._useUTC ? " UTC" : ""));
                    }), n.ISO_8601 = function() {
                    }, n.RFC_2822 = function() {
                    };
                    var Rn = M("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
                        var t = Nt.apply(null, arguments);
                        return this.isValid() && t.isValid() ? t < this ? this : t : p();
                    }), Ln = M("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
                        var t = Nt.apply(null, arguments);
                        return this.isValid() && t.isValid() ? t > this ? this : t : p();
                    }), Wn = [
                        "year",
                        "quarter",
                        "month",
                        "week",
                        "day",
                        "hour",
                        "minute",
                        "second",
                        "millisecond"
                    ];
                    jt("Z", ":"), jt("ZZ", ""), E("Z", Xe), E("ZZ", Xe), G([
                        "Z",
                        "ZZ"
                    ], function(t, e, n) {
                        n._useUTC = !0, n._tzm = Ut(Xe, t);
                    });
                    var Yn = /([\+\-]|\d\d)/gi;
                    n.updateOffset = function() {
                    };
                    var Nn = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/, zn = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;
                    Xt.fn = Vt.prototype, Xt.invalid = function() {
                        return Xt(NaN);
                    };
                    var Bn = $t(1, "add"), Vn = $t(-1, "subtract");
                    n.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", n.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
                    var Hn = M("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(t) {
                        return void 0 === t ? this.localeData() : this.locale(t);
                    });
                    N(0, [
                        "gg",
                        2
                    ], 0, function() {
                        return this.weekYear() % 100;
                    }), N(0, [
                        "GG",
                        2
                    ], 0, function() {
                        return this.isoWeekYear() % 100;
                    }), ae("gggg", "weekYear"), ae("ggggg", "weekYear"), ae("GGGG", "isoWeekYear"), ae("GGGGG", "isoWeekYear"), T("weekYear", "gg"), T("isoWeekYear", "GG"), O("weekYear", 1), O("isoWeekYear", 1), E("G", Ge), E("g", Ge), E("GG", Be, We), E("gg", Be, We), E("GGGG", je, Ne), E("gggg", je, Ne), E("GGGGG", Ue, ze), E("ggggg", Ue, ze), Z([
                        "gggg",
                        "ggggg",
                        "GGGG",
                        "GGGGG"
                    ], function(t, e, n, i) {
                        e[i.substr(0, 2)] = _(t);
                    }), Z([
                        "gg",
                        "GG"
                    ], function(t, e, i, a) {
                        e[a] = n.parseTwoDigitYear(t);
                    }), N("Q", 0, "Qo", "quarter"), T("quarter", "Q"), O("quarter", 7), E("Q", Le), G("Q", function(t, e) {
                        e[tn] = 3 * (_(t) - 1);
                    }), N("D", [
                        "DD",
                        2
                    ], "Do", "date"), T("date", "D"), O("date", 9), E("D", Be), E("DD", Be, We), E("Do", function(t, e) {
                        return t ? e._dayOfMonthOrdinalParse || e._ordinalParse : e._dayOfMonthOrdinalParseLenient;
                    }), G([
                        "D",
                        "DD"
                    ], en), G("Do", function(t, e) {
                        e[en] = _(t.match(Be)[0], 10);
                    });
                    var En = R("Date", !0);
                    N("DDD", [
                        "DDDD",
                        3
                    ], "DDDo", "dayOfYear"), T("dayOfYear", "DDD"), O("dayOfYear", 4), E("DDD", Ee), E("DDDD", Ye), G([
                        "DDD",
                        "DDDD"
                    ], function(t, e, n) {
                        n._dayOfYear = _(t);
                    }), N("m", [
                        "mm",
                        2
                    ], 0, "minute"), T("minute", "m"), O("minute", 14), E("m", Be), E("mm", Be, We), G([
                        "m",
                        "mm"
                    ], an);
                    var jn = R("Minutes", !1);
                    N("s", [
                        "ss",
                        2
                    ], 0, "second"), T("second", "s"), O("second", 15), E("s", Be), E("ss", Be, We), G([
                        "s",
                        "ss"
                    ], rn);
                    var Un = R("Seconds", !1);
                    N("S", 0, 0, function() {
                        return ~~(this.millisecond() / 100);
                    }), N(0, [
                        "SS",
                        2
                    ], 0, function() {
                        return ~~(this.millisecond() / 10);
                    }), N(0, [
                        "SSS",
                        3
                    ], 0, "millisecond"), N(0, [
                        "SSSS",
                        4
                    ], 0, function() {
                        return 10 * this.millisecond();
                    }), N(0, [
                        "SSSSS",
                        5
                    ], 0, function() {
                        return 100 * this.millisecond();
                    }), N(0, [
                        "SSSSSS",
                        6
                    ], 0, function() {
                        return 1000 * this.millisecond();
                    }), N(0, [
                        "SSSSSSS",
                        7
                    ], 0, function() {
                        return 10000 * this.millisecond();
                    }), N(0, [
                        "SSSSSSSS",
                        8
                    ], 0, function() {
                        return 100000 * this.millisecond();
                    }), N(0, [
                        "SSSSSSSSS",
                        9
                    ], 0, function() {
                        return 1000000 * this.millisecond();
                    }), T("millisecond", "ms"), O("millisecond", 16), E("S", Ee, Le), E("SS", Ee, We), E("SSS", Ee, Ye);
                    var qn;
                    for(qn = "SSSS"; qn.length <= 9; qn += "S")E(qn, qe);
                    for(qn = "S"; qn.length <= 9; qn += "S")G(qn, function(t, e) {
                        e[on] = _(1000 * ("0." + t));
                    });
                    var Gn = R("Milliseconds", !1);
                    N("z", 0, 0, "zoneAbbr"), N("zz", 0, 0, "zoneName");
                    var Zn = y.prototype;
                    Zn.add = Bn, Zn.calendar = function(t, e) {
                        var i = t || Nt(), a = qt(i, this).startOf("day"), r = n.calendarFormat(this, a) || "sameElse", o = e && (D(e[r]) ? e[r].call(this, i) : e[r]);
                        return this.format(o || this.localeData().calendar(r, this, Nt(i)));
                    }, Zn.clone = function() {
                        return new y(this);
                    }, Zn.diff = function(t, e, n) {
                        var i, a, r, o;
                        return this.isValid() && (i = qt(t, this)).isValid() ? (a = 60000 * (i.utcOffset() - this.utcOffset()), "year" === (e = A(e)) || "month" === e || "quarter" === e ? (o = ee(this, i), "quarter" === e ? o /= 3 : "year" === e && (o /= 12)) : (r = this - i, o = "second" === e ? r / 1000 : "minute" === e ? r / 60000 : "hour" === e ? r / 3600000 : "day" === e ? (r - a) / 86400000 : "week" === e ? (r - a) / 604800000 : r), n ? o : x(o)) : NaN;
                    }, Zn.endOf = function(t) {
                        return void 0 === (t = A(t)) || "millisecond" === t ? this : ("date" === t && (t = "day"), this.startOf(t).add(1, "isoWeek" === t ? "week" : t).subtract(1, "ms"));
                    }, Zn.format = function(t) {
                        t || (t = this.isUtc() ? n.defaultFormatUtc : n.defaultFormat);
                        var e = V(this, t);
                        return this.localeData().postformat(e);
                    }, Zn.from = function(t, e) {
                        return this.isValid() && (b(t) && t.isValid() || Nt(t).isValid()) ? Xt({
                            to: this,
                            from: t
                        }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate();
                    }, Zn.fromNow = function(t) {
                        return this.from(Nt(), t);
                    }, Zn.to = function(t, e) {
                        return this.isValid() && (b(t) && t.isValid() || Nt(t).isValid()) ? Xt({
                            from: this,
                            to: t
                        }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate();
                    }, Zn.toNow = function(t) {
                        return this.to(Nt(), t);
                    }, Zn.get = function(t) {
                        return t = A(t), D(this[t]) ? this[t]() : this;
                    }, Zn.invalidAt = function() {
                        return g(this).overflow;
                    }, Zn.isAfter = function(t, e) {
                        var n = b(t) ? t : Nt(t);
                        return !(!this.isValid() || !n.isValid()) && ("millisecond" === (e = A(o(e) ? "millisecond" : e)) ? this.valueOf() > n.valueOf() : n.valueOf() < this.clone().startOf(e).valueOf());
                    }, Zn.isBefore = function(t, e) {
                        var n = b(t) ? t : Nt(t);
                        return !(!this.isValid() || !n.isValid()) && ("millisecond" === (e = A(o(e) ? "millisecond" : e)) ? this.valueOf() < n.valueOf() : this.clone().endOf(e).valueOf() < n.valueOf());
                    }, Zn.isBetween = function(t, e, n, i) {
                        return ("(" === (i = i || "()")[0] ? this.isAfter(t, n) : !this.isBefore(t, n)) && (")" === i[1] ? this.isBefore(e, n) : !this.isAfter(e, n));
                    }, Zn.isSame = function(t, e) {
                        var n, i = b(t) ? t : Nt(t);
                        return !(!this.isValid() || !i.isValid()) && ("millisecond" === (e = A(e || "millisecond")) ? this.valueOf() === i.valueOf() : (n = i.valueOf(), this.clone().startOf(e).valueOf() <= n && n <= this.clone().endOf(e).valueOf()));
                    }, Zn.isSameOrAfter = function(t, e) {
                        return this.isSame(t, e) || this.isAfter(t, e);
                    }, Zn.isSameOrBefore = function(t, e) {
                        return this.isSame(t, e) || this.isBefore(t, e);
                    }, Zn.isValid = function() {
                        return m(this);
                    }, Zn.lang = Hn, Zn.locale = ne, Zn.localeData = ie, Zn.max = Ln, Zn.min = Rn, Zn.parsingFlags = function() {
                        return c({
                        }, g(this));
                    }, Zn.set = function(t, e) {
                        if ("object" == typeof t) for(var n = F(t = I(t)), i = 0; i < n.length; i++)this[n[i].unit](t[n[i].unit]);
                        else if (t = A(t), D(this[t])) return this[t](e);
                        return this;
                    }, Zn.startOf = function(t) {
                        switch(t = A(t)){
                            case "year":
                                this.month(0);
                            case "quarter":
                            case "month":
                                this.date(1);
                            case "week":
                            case "isoWeek":
                            case "day":
                            case "date":
                                this.hours(0);
                            case "hour":
                                this.minutes(0);
                            case "minute":
                                this.seconds(0);
                            case "second":
                                this.milliseconds(0);
                        }
                        return "week" === t && this.weekday(0), "isoWeek" === t && this.isoWeekday(1), "quarter" === t && this.month(3 * Math.floor(this.month() / 3)), this;
                    }, Zn.subtract = Vn, Zn.toArray = function() {
                        var t = this;
                        return [
                            t.year(),
                            t.month(),
                            t.date(),
                            t.hour(),
                            t.minute(),
                            t.second(),
                            t.millisecond()
                        ];
                    }, Zn.toObject = function() {
                        var t = this;
                        return {
                            years: t.year(),
                            months: t.month(),
                            date: t.date(),
                            hours: t.hours(),
                            minutes: t.minutes(),
                            seconds: t.seconds(),
                            milliseconds: t.milliseconds()
                        };
                    }, Zn.toDate = function() {
                        return new Date(this.valueOf());
                    }, Zn.toISOString = function() {
                        if (!this.isValid()) return null;
                        var t = this.clone().utc();
                        return t.year() < 0 || t.year() > 9999 ? V(t, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]") : D(Date.prototype.toISOString) ? this.toDate().toISOString() : V(t, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
                    }, Zn.inspect = function() {
                        if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
                        var t = "moment", e = "";
                        this.isLocal() || (t = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", e = "Z");
                        var n = "[" + t + '("]', i = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", a = e + '[")]';
                        return this.format(n + i + "-MM-DD[T]HH:mm:ss.SSS" + a);
                    }, Zn.toJSON = function() {
                        return this.isValid() ? this.toISOString() : null;
                    }, Zn.toString = function() {
                        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
                    }, Zn.unix = function() {
                        return Math.floor(this.valueOf() / 1000);
                    }, Zn.valueOf = function() {
                        return this._d.valueOf() - 60000 * (this._offset || 0);
                    }, Zn.creationData = function() {
                        return {
                            input: this._i,
                            format: this._f,
                            locale: this._locale,
                            isUTC: this._isUTC,
                            strict: this._strict
                        };
                    }, Zn.year = mn, Zn.isLeapYear = function() {
                        return nt(this.year());
                    }, Zn.weekYear = function(t) {
                        return re.call(this, t, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
                    }, Zn.isoWeekYear = function(t) {
                        return re.call(this, t, this.isoWeek(), this.isoWeekday(), 1, 4);
                    }, Zn.quarter = Zn.quarters = function(t) {
                        return null == t ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (t - 1) + this.month() % 3);
                    }, Zn.month = $, Zn.daysInMonth = function() {
                        return J(this.year(), this.month());
                    }, Zn.week = Zn.weeks = function(t) {
                        var e = this.localeData().week(this);
                        return null == t ? e : this.add(7 * (t - e), "d");
                    }, Zn.isoWeek = Zn.isoWeeks = function(t) {
                        var e = st(this, 1, 4).week;
                        return null == t ? e : this.add(7 * (t - e), "d");
                    }, Zn.weeksInYear = function() {
                        var t = this.localeData()._week;
                        return lt(this.year(), t.dow, t.doy);
                    }, Zn.isoWeeksInYear = function() {
                        return lt(this.year(), 1, 4);
                    }, Zn.date = En, Zn.day = Zn.days = function(t) {
                        if (!this.isValid()) return null != t ? this : NaN;
                        var e = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                        return null != t ? (t = ut(t, this.localeData()), this.add(t - e, "d")) : e;
                    }, Zn.weekday = function(t) {
                        if (!this.isValid()) return null != t ? this : NaN;
                        var e = (this.day() + 7 - this.localeData()._week.dow) % 7;
                        return null == t ? e : this.add(t - e, "d");
                    }, Zn.isoWeekday = function(t) {
                        if (!this.isValid()) return null != t ? this : NaN;
                        if (null != t) {
                            var e = dt(t, this.localeData());
                            return this.day(this.day() % 7 ? e : e - 7);
                        }
                        return this.day() || 7;
                    }, Zn.dayOfYear = function(t) {
                        var e = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 86400000) + 1;
                        return null == t ? e : this.add(t - e, "d");
                    }, Zn.hour = Zn.hours = wn, Zn.minute = Zn.minutes = jn, Zn.second = Zn.seconds = Un, Zn.millisecond = Zn.milliseconds = Gn, Zn.utcOffset = function(t, e, i) {
                        var a, r = this._offset || 0;
                        if (!this.isValid()) return null != t ? this : NaN;
                        if (null != t) {
                            if ("string" == typeof t) {
                                if (null === (t = Ut(Xe, t))) return this;
                            } else Math.abs(t) < 16 && !i && (t *= 60);
                            return !this._isUTC && e && (a = Gt(this)), this._offset = t, this._isUTC = !0, null != a && this.add(a, "m"), r !== t && (!e || this._changeInProgress ? te(this, Xt(t - r, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, n.updateOffset(this, !0), this._changeInProgress = null)), this;
                        }
                        return this._isUTC ? r : Gt(this);
                    }, Zn.utc = function(t) {
                        return this.utcOffset(0, t);
                    }, Zn.local = function(t) {
                        return this._isUTC && (this.utcOffset(0, t), this._isUTC = !1, t && this.subtract(Gt(this), "m")), this;
                    }, Zn.parseZone = function() {
                        if (null != this._tzm) this.utcOffset(this._tzm, !1, !0);
                        else if ("string" == typeof this._i) {
                            var t = Ut(Ze, this._i);
                            null != t ? this.utcOffset(t) : this.utcOffset(0, !0);
                        }
                        return this;
                    }, Zn.hasAlignedHourOffset = function(t) {
                        return !!this.isValid() && (t = t ? Nt(t).utcOffset() : 0, (this.utcOffset() - t) % 60 == 0);
                    }, Zn.isDST = function() {
                        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
                    }, Zn.isLocal = function() {
                        return !!this.isValid() && !this._isUTC;
                    }, Zn.isUtcOffset = function() {
                        return !!this.isValid() && this._isUTC;
                    }, Zn.isUtc = Zt, Zn.isUTC = Zt, Zn.zoneAbbr = function() {
                        return this._isUTC ? "UTC" : "";
                    }, Zn.zoneName = function() {
                        return this._isUTC ? "Coordinated Universal Time" : "";
                    }, Zn.dates = M("dates accessor is deprecated. Use date instead.", En), Zn.months = M("months accessor is deprecated. Use month instead", $), Zn.years = M("years accessor is deprecated. Use year instead", mn), Zn.zone = M("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function(t, e) {
                        return null != t ? ("string" != typeof t && (t = -t), this.utcOffset(t, e), this) : -this.utcOffset();
                    }), Zn.isDSTShifted = M("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function() {
                        if (!o(this._isDSTShifted)) return this._isDSTShifted;
                        var t = {
                        };
                        if (v(t, this), (t = Lt(t))._a) {
                            var e = t._isUTC ? h(t._a) : Nt(t._a);
                            this._isDSTShifted = this.isValid() && k(t._a, e.toArray()) > 0;
                        } else this._isDSTShifted = !1;
                        return this._isDSTShifted;
                    });
                    var Xn = P.prototype;
                    Xn.calendar = function(t, e, n) {
                        var i = this._calendar[t] || this._calendar.sameElse;
                        return D(i) ? i.call(e, n) : i;
                    }, Xn.longDateFormat = function(t) {
                        var e = this._longDateFormat[t], n = this._longDateFormat[t.toUpperCase()];
                        return e || !n ? e : (this._longDateFormat[t] = n.replace(/MMMM|MM|DD|dddd/g, function(t) {
                            return t.slice(1);
                        }), this._longDateFormat[t]);
                    }, Xn.invalidDate = function() {
                        return this._invalidDate;
                    }, Xn.ordinal = function(t) {
                        return this._ordinal.replace("%d", t);
                    }, Xn.preparse = se, Xn.postformat = se, Xn.relativeTime = function(t, e, n, i) {
                        var a = this._relativeTime[n];
                        return D(a) ? a(t, e, n, i) : a.replace(/%d/i, t);
                    }, Xn.pastFuture = function(t, e) {
                        var n = this._relativeTime[t > 0 ? "future" : "past"];
                        return D(n) ? n(e) : n.replace(/%s/i, e);
                    }, Xn.set = function(t) {
                        var e, n;
                        for(n in t)D(e = t[n]) ? this[n] = e : this["_" + n] = e;
                        this._config = t, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
                    }, Xn.months = function(t, e) {
                        return t ? i(this._months) ? this._months[t.month()] : this._months[(this._months.isFormat || dn).test(e) ? "format" : "standalone"][t.month()] : i(this._months) ? this._months : this._months.standalone;
                    }, Xn.monthsShort = function(t, e) {
                        return t ? i(this._monthsShort) ? this._monthsShort[t.month()] : this._monthsShort[dn.test(e) ? "format" : "standalone"][t.month()] : i(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
                    }, Xn.monthsParse = function(t, e, n) {
                        var i, a, r;
                        if (this._monthsParseExact) return K.call(this, t, e, n);
                        for(this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), i = 0; i < 12; i++){
                            if (a = h([
                                2000,
                                i
                            ]), n && !this._longMonthsParse[i] && (this._longMonthsParse[i] = new RegExp("^" + this.months(a, "").replace(".", "") + "$", "i"), this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(a, "").replace(".", "") + "$", "i")), n || this._monthsParse[i] || (r = "^" + this.months(a, "") + "|^" + this.monthsShort(a, ""), this._monthsParse[i] = new RegExp(r.replace(".", ""), "i")), n && "MMMM" === e && this._longMonthsParse[i].test(t)) return i;
                            if (n && "MMM" === e && this._shortMonthsParse[i].test(t)) return i;
                            if (!n && this._monthsParse[i].test(t)) return i;
                        }
                    }, Xn.monthsRegex = function(t) {
                        return this._monthsParseExact ? (d(this, "_monthsRegex") || tt.call(this), t ? this._monthsStrictRegex : this._monthsRegex) : (d(this, "_monthsRegex") || (this._monthsRegex = gn), this._monthsStrictRegex && t ? this._monthsStrictRegex : this._monthsRegex);
                    }, Xn.monthsShortRegex = function(t) {
                        return this._monthsParseExact ? (d(this, "_monthsRegex") || tt.call(this), t ? this._monthsShortStrictRegex : this._monthsShortRegex) : (d(this, "_monthsShortRegex") || (this._monthsShortRegex = fn), this._monthsShortStrictRegex && t ? this._monthsShortStrictRegex : this._monthsShortRegex);
                    }, Xn.week = function(t) {
                        return st(t, this._week.dow, this._week.doy).week;
                    }, Xn.firstDayOfYear = function() {
                        return this._week.doy;
                    }, Xn.firstDayOfWeek = function() {
                        return this._week.dow;
                    }, Xn.weekdays = function(t, e) {
                        return t ? i(this._weekdays) ? this._weekdays[t.day()] : this._weekdays[this._weekdays.isFormat.test(e) ? "format" : "standalone"][t.day()] : i(this._weekdays) ? this._weekdays : this._weekdays.standalone;
                    }, Xn.weekdaysMin = function(t) {
                        return t ? this._weekdaysMin[t.day()] : this._weekdaysMin;
                    }, Xn.weekdaysShort = function(t) {
                        return t ? this._weekdaysShort[t.day()] : this._weekdaysShort;
                    }, Xn.weekdaysParse = function(t, e, n) {
                        var i, a, r;
                        if (this._weekdaysParseExact) return ct.call(this, t, e, n);
                        for(this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), i = 0; i < 7; i++){
                            if (a = h([
                                2000,
                                1
                            ]).day(i), n && !this._fullWeekdaysParse[i] && (this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(a, "").replace(".", ".?") + "$", "i"), this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(a, "").replace(".", ".?") + "$", "i"), this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(a, "").replace(".", ".?") + "$", "i")), this._weekdaysParse[i] || (r = "^" + this.weekdays(a, "") + "|^" + this.weekdaysShort(a, "") + "|^" + this.weekdaysMin(a, ""), this._weekdaysParse[i] = new RegExp(r.replace(".", ""), "i")), n && "dddd" === e && this._fullWeekdaysParse[i].test(t)) return i;
                            if (n && "ddd" === e && this._shortWeekdaysParse[i].test(t)) return i;
                            if (n && "dd" === e && this._minWeekdaysParse[i].test(t)) return i;
                            if (!n && this._weekdaysParse[i].test(t)) return i;
                        }
                    }, Xn.weekdaysRegex = function(t) {
                        return this._weekdaysParseExact ? (d(this, "_weekdaysRegex") || ht.call(this), t ? this._weekdaysStrictRegex : this._weekdaysRegex) : (d(this, "_weekdaysRegex") || (this._weekdaysRegex = bn), this._weekdaysStrictRegex && t ? this._weekdaysStrictRegex : this._weekdaysRegex);
                    }, Xn.weekdaysShortRegex = function(t) {
                        return this._weekdaysParseExact ? (d(this, "_weekdaysRegex") || ht.call(this), t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (d(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = xn), this._weekdaysShortStrictRegex && t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
                    }, Xn.weekdaysMinRegex = function(t) {
                        return this._weekdaysParseExact ? (d(this, "_weekdaysRegex") || ht.call(this), t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (d(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = _n), this._weekdaysMinStrictRegex && t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
                    }, Xn.isPM = function(t) {
                        return "p" === (t + "").toLowerCase().charAt(0);
                    }, Xn.meridiem = function(t, e, n) {
                        return t > 11 ? n ? "pm" : "PM" : n ? "am" : "AM";
                    }, bt("en", {
                        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
                        ordinal: function(t) {
                            var e = t % 10;
                            return t + (1 === _(t % 100 / 10) ? "th" : 1 === e ? "st" : 2 === e ? "nd" : 3 === e ? "rd" : "th");
                        }
                    }), n.lang = M("moment.lang is deprecated. Use moment.locale instead.", bt), n.langData = M("moment.langData is deprecated. Use moment.localeData instead.", _t);
                    var Jn = Math.abs, Kn = me("ms"), Qn = me("s"), $n = me("m"), ti = me("h"), ei = me("d"), ni = me("w"), ii = me("M"), ai = me("y"), ri = pe("milliseconds"), oi = pe("seconds"), si = pe("minutes"), li = pe("hours"), ui = pe("days"), di = pe("months"), ci = pe("years"), hi = Math.round, fi = {
                        ss: 44,
                        s: 45,
                        m: 45,
                        h: 22,
                        d: 26,
                        M: 11
                    }, gi = Math.abs, mi = Vt.prototype;
                    return mi.isValid = function() {
                        return this._isValid;
                    }, mi.abs = function() {
                        var t = this._data;
                        return this._milliseconds = Jn(this._milliseconds), this._days = Jn(this._days), this._months = Jn(this._months), t.milliseconds = Jn(t.milliseconds), t.seconds = Jn(t.seconds), t.minutes = Jn(t.minutes), t.hours = Jn(t.hours), t.months = Jn(t.months), t.years = Jn(t.years), this;
                    }, mi.add = function(t, e) {
                        return ce(this, t, e, 1);
                    }, mi.subtract = function(t, e) {
                        return ce(this, t, e, -1);
                    }, mi.as = function(t) {
                        if (!this.isValid()) return NaN;
                        var e, n, i = this._milliseconds;
                        if ("month" === (t = A(t)) || "year" === t) return e = this._days + i / 86400000, n = this._months + fe(e), "month" === t ? n : n / 12;
                        switch(e = this._days + Math.round(ge(this._months)), t){
                            case "week":
                                return e / 7 + i / 604800000;
                            case "day":
                                return e + i / 86400000;
                            case "hour":
                                return 24 * e + i / 3600000;
                            case "minute":
                                return 1440 * e + i / 60000;
                            case "second":
                                return 86400 * e + i / 1000;
                            case "millisecond":
                                return Math.floor(86400000 * e) + i;
                            default:
                                throw new Error("Unknown unit " + t);
                        }
                    }, mi.asMilliseconds = Kn, mi.asSeconds = Qn, mi.asMinutes = $n, mi.asHours = ti, mi.asDays = ei, mi.asWeeks = ni, mi.asMonths = ii, mi.asYears = ai, mi.valueOf = function() {
                        return this.isValid() ? this._milliseconds + 86400000 * this._days + this._months % 12 * 2592000000 + 31536000000 * _(this._months / 12) : NaN;
                    }, mi._bubble = function() {
                        var t, e, n, i, a, r = this._milliseconds, o = this._days, s = this._months, l = this._data;
                        return r >= 0 && o >= 0 && s >= 0 || r <= 0 && o <= 0 && s <= 0 || (r += 86400000 * he(ge(s) + o), o = 0, s = 0), l.milliseconds = r % 1000, t = x(r / 1000), l.seconds = t % 60, e = x(t / 60), l.minutes = e % 60, n = x(e / 60), l.hours = n % 24, o += x(n / 24), a = x(fe(o)), s += a, o -= he(ge(a)), i = x(s / 12), s %= 12, l.days = o, l.months = s, l.years = i, this;
                    }, mi.get = function(t) {
                        return t = A(t), this.isValid() ? this[t + "s"]() : NaN;
                    }, mi.milliseconds = ri, mi.seconds = oi, mi.minutes = si, mi.hours = li, mi.days = ui, mi.weeks = function() {
                        return x(this.days() / 7);
                    }, mi.months = di, mi.years = ci, mi.humanize = function(t) {
                        if (!this.isValid()) return this.localeData().invalidDate();
                        var e = this.localeData(), n = ye(this, !t, e);
                        return t && (n = e.pastFuture(+this, n)), e.postformat(n);
                    }, mi.toISOString = be, mi.toString = be, mi.toJSON = be, mi.locale = ne, mi.localeData = ie, mi.toIsoString = M("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", be), mi.lang = Hn, N("X", 0, 0, "unix"), N("x", 0, 0, "valueOf"), E("x", Ge), E("X", /[+-]?\d+(\.\d{1,3})?/), G("X", function(t, e, n) {
                        n._d = new Date(1000 * parseFloat(t, 10));
                    }), G("x", function(t, e, n) {
                        n._d = new Date(_(t));
                    }), n.version = "2.18.1", (function(t) {
                        xe = t;
                    })(Nt), n.fn = Zn, n.min = function() {
                        return zt("isBefore", [].slice.call(arguments, 0));
                    }, n.max = function() {
                        return zt("isAfter", [].slice.call(arguments, 0));
                    }, n.now = function() {
                        return Date.now ? Date.now() : +new Date;
                    }, n.utc = h, n.unix = function(t) {
                        return Nt(1000 * t);
                    }, n.months = function(t, e) {
                        return ue(t, e, "months");
                    }, n.isDate = l, n.locale = bt, n.invalid = p, n.duration = Xt, n.isMoment = b, n.weekdays = function(t, e, n) {
                        return de(t, e, n, "weekdays");
                    }, n.parseZone = function() {
                        return Nt.apply(null, arguments).parseZone();
                    }, n.localeData = _t, n.isDuration = Ht, n.monthsShort = function(t, e) {
                        return ue(t, e, "monthsShort");
                    }, n.weekdaysMin = function(t, e, n) {
                        return de(t, e, n, "weekdaysMin");
                    }, n.defineLocale = xt, n.updateLocale = function(t, e) {
                        if (null != e) {
                            var n, i = Mn;
                            null != Sn[t] && (i = Sn[t]._config), (n = new P(e = C(i, e))).parentLocale = Sn[t], Sn[t] = n, bt(t);
                        } else null != Sn[t] && (null != Sn[t].parentLocale ? Sn[t] = Sn[t].parentLocale : null != Sn[t] && delete Sn[t]);
                        return Sn[t];
                    }, n.locales = function() {
                        return Pe(Sn);
                    }, n.weekdaysShort = function(t, e, n) {
                        return de(t, e, n, "weekdaysShort");
                    }, n.normalizeUnits = A, n.relativeTimeRounding = function(t) {
                        return void 0 === t ? hi : "function" == typeof t && (hi = t, !0);
                    }, n.relativeTimeThreshold = function(t, e) {
                        return void 0 !== fi[t] && (void 0 === e ? fi[t] : (fi[t] = e, "s" === t && (fi.ss = e - 1), !0));
                    }, n.calendarFormat = function(t, e) {
                        var n = t.diff(e, "days", !0);
                        return n < -6 ? "sameElse" : n < -1 ? "lastWeek" : n < 0 ? "lastDay" : n < 1 ? "sameDay" : n < 2 ? "nextDay" : n < 7 ? "nextWeek" : "sameElse";
                    }, n.prototype = Zn, n;
                });
            },
            {
            }
        ],
        7: [
            function(t, e, n) {
                var i = t(29)();
                i.helpers = t(45), t(27)(i), i.defaults = t(25), i.Element = t(26), i.elements = t(40), i.Interaction = t(28), i.platform = t(48), t(31)(i), t(22)(i), t(23)(i), t(24)(i), t(30)(i), t(33)(i), t(32)(i), t(35)(i), t(54)(i), t(52)(i), t(53)(i), t(55)(i), t(56)(i), t(57)(i), t(15)(i), t(16)(i), t(17)(i), t(18)(i), t(19)(i), t(20)(i), t(21)(i), t(8)(i), t(9)(i), t(10)(i), t(11)(i), t(12)(i), t(13)(i), t(14)(i);
                var a = [];
                a.push(t(49)(i), t(50)(i), t(51)(i)), i.plugins.register(a), i.platform.initialize(), e.exports = i, "undefined" != typeof window && (window.Chart = i), i.canvasHelpers = i.helpers.canvas;
            },
            {
                10: 10,
                11: 11,
                12: 12,
                13: 13,
                14: 14,
                15: 15,
                16: 16,
                17: 17,
                18: 18,
                19: 19,
                20: 20,
                21: 21,
                22: 22,
                23: 23,
                24: 24,
                25: 25,
                26: 26,
                27: 27,
                28: 28,
                29: 29,
                30: 30,
                31: 31,
                32: 32,
                33: 33,
                35: 35,
                40: 40,
                45: 45,
                48: 48,
                49: 49,
                50: 50,
                51: 51,
                52: 52,
                53: 53,
                54: 54,
                55: 55,
                56: 56,
                57: 57,
                8: 8,
                9: 9
            }
        ],
        8: [
            function(t, e, n) {
                "use strict";
                e.exports = function(t) {
                    t.Bar = function(e, n) {
                        return n.type = "bar", new t(e, n);
                    };
                };
            },
            {
            }
        ],
        9: [
            function(t, e, n) {
                "use strict";
                e.exports = function(t) {
                    t.Bubble = function(e, n) {
                        return n.type = "bubble", new t(e, n);
                    };
                };
            },
            {
            }
        ],
        10: [
            function(t, e, n) {
                "use strict";
                e.exports = function(t) {
                    t.Doughnut = function(e, n) {
                        return n.type = "doughnut", new t(e, n);
                    };
                };
            },
            {
            }
        ],
        11: [
            function(t, e, n) {
                "use strict";
                e.exports = function(t) {
                    t.Line = function(e, n) {
                        return n.type = "line", new t(e, n);
                    };
                };
            },
            {
            }
        ],
        12: [
            function(t, e, n) {
                "use strict";
                e.exports = function(t) {
                    t.PolarArea = function(e, n) {
                        return n.type = "polarArea", new t(e, n);
                    };
                };
            },
            {
            }
        ],
        13: [
            function(t, e, n) {
                "use strict";
                e.exports = function(t) {
                    t.Radar = function(e, n) {
                        return n.type = "radar", new t(e, n);
                    };
                };
            },
            {
            }
        ],
        14: [
            function(t, e, n) {
                "use strict";
                e.exports = function(t) {
                    t.Scatter = function(e, n) {
                        return n.type = "scatter", new t(e, n);
                    };
                };
            },
            {
            }
        ],
        15: [
            function(t, e, n) {
                "use strict";
                var i = t(25), a = t(40), r = t(45);
                i._set("bar", {
                    hover: {
                        mode: "label"
                    },
                    scales: {
                        xAxes: [
                            {
                                type: "category",
                                categoryPercentage: 0.8,
                                barPercentage: 0.9,
                                offset: !0,
                                gridLines: {
                                    offsetGridLines: !0
                                }
                            }
                        ],
                        yAxes: [
                            {
                                type: "linear"
                            }
                        ]
                    }
                }), i._set("horizontalBar", {
                    hover: {
                        mode: "index",
                        axis: "y"
                    },
                    scales: {
                        xAxes: [
                            {
                                type: "linear",
                                position: "bottom"
                            }
                        ],
                        yAxes: [
                            {
                                position: "left",
                                type: "category",
                                categoryPercentage: 0.8,
                                barPercentage: 0.9,
                                offset: !0,
                                gridLines: {
                                    offsetGridLines: !0
                                }
                            }
                        ]
                    },
                    elements: {
                        rectangle: {
                            borderSkipped: "left"
                        }
                    },
                    tooltips: {
                        callbacks: {
                            title: function(t, e) {
                                var n = "";
                                return t.length > 0 && (t[0].yLabel ? n = t[0].yLabel : e.labels.length > 0 && t[0].index < e.labels.length && (n = e.labels[t[0].index])), n;
                            },
                            label: function(t, e) {
                                return (e.datasets[t.datasetIndex].label || "") + ": " + t.xLabel;
                            }
                        },
                        mode: "index",
                        axis: "y"
                    }
                }), e.exports = function(t) {
                    t.controllers.bar = t.DatasetController.extend({
                        dataElementType: a.Rectangle,
                        initialize: function() {
                            var e, n = this;
                            t.DatasetController.prototype.initialize.apply(n, arguments), (e = n.getMeta()).stack = n.getDataset().stack, e.bar = !0;
                        },
                        update: function(t) {
                            var e, n, i = this, a = i.getMeta().data;
                            for(i._ruler = i.getRuler(), e = 0, n = a.length; e < n; ++e)i.updateElement(a[e], e, t);
                        },
                        updateElement: function(t, e, n) {
                            var i = this, a = i.chart, o = i.getMeta(), s = i.getDataset(), l = t.custom || {
                            }, u = a.options.elements.rectangle;
                            t._xScale = i.getScaleForId(o.xAxisID), t._yScale = i.getScaleForId(o.yAxisID), t._datasetIndex = i.index, t._index = e, t._model = {
                                datasetLabel: s.label,
                                label: a.data.labels[e],
                                borderSkipped: l.borderSkipped ? l.borderSkipped : u.borderSkipped,
                                backgroundColor: l.backgroundColor ? l.backgroundColor : r.valueAtIndexOrDefault(s.backgroundColor, e, u.backgroundColor),
                                borderColor: l.borderColor ? l.borderColor : r.valueAtIndexOrDefault(s.borderColor, e, u.borderColor),
                                borderWidth: l.borderWidth ? l.borderWidth : r.valueAtIndexOrDefault(s.borderWidth, e, u.borderWidth)
                            }, i.updateElementGeometry(t, e, n), t.pivot();
                        },
                        updateElementGeometry: function(t, e, n) {
                            var i = this, a = t._model, r = i.getValueScale(), o = r.getBasePixel(), s = r.isHorizontal(), l = i._ruler || i.getRuler(), u = i.calculateBarValuePixels(i.index, e), d = i.calculateBarIndexPixels(i.index, e, l);
                            a.horizontal = s, a.base = n ? o : u.base, a.x = s ? n ? o : u.head : d.center, a.y = s ? d.center : n ? o : u.head, a.height = s ? d.size : void 0, a.width = s ? void 0 : d.size;
                        },
                        getValueScaleId: function() {
                            return this.getMeta().yAxisID;
                        },
                        getIndexScaleId: function() {
                            return this.getMeta().xAxisID;
                        },
                        getValueScale: function() {
                            return this.getScaleForId(this.getValueScaleId());
                        },
                        getIndexScale: function() {
                            return this.getScaleForId(this.getIndexScaleId());
                        },
                        getStackCount: function(t) {
                            var e, n, i = this, a = i.chart, r = i.getIndexScale().options.stacked, o = void 0 === t ? a.data.datasets.length : t + 1, s = [];
                            for(e = 0; e < o; ++e)(n = a.getDatasetMeta(e)).bar && a.isDatasetVisible(e) && (!1 === r || !0 === r && -1 === s.indexOf(n.stack) || void 0 === r && (void 0 === n.stack || -1 === s.indexOf(n.stack))) && s.push(n.stack);
                            return s.length;
                        },
                        getStackIndex: function(t) {
                            return this.getStackCount(t) - 1;
                        },
                        getRuler: function() {
                            var t, e, n = this, i = n.getIndexScale(), a = n.getStackCount(), r = n.index, o = [], s = i.isHorizontal(), l = s ? i.left : i.top, u = l + (s ? i.width : i.height);
                            for(t = 0, e = n.getMeta().data.length; t < e; ++t)o.push(i.getPixelForValue(null, t, r));
                            return {
                                pixels: o,
                                start: l,
                                end: u,
                                stackCount: a,
                                scale: i
                            };
                        },
                        calculateBarValuePixels: function(t, e) {
                            var n, i, a, r, o, s, l = this, u = l.chart, d = l.getMeta(), c = l.getValueScale(), h = u.data.datasets, f = c.getRightValue(h[t].data[e]), g = c.options.stacked, m = d.stack, p = 0;
                            if (g || void 0 === g && void 0 !== m) for(n = 0; n < t; ++n)(i = u.getDatasetMeta(n)).bar && i.stack === m && i.controller.getValueScaleId() === c.id && u.isDatasetVisible(n) && (a = c.getRightValue(h[n].data[e]), (f < 0 && a < 0 || f >= 0 && a > 0) && (p += a));
                            return r = c.getPixelForValue(p), o = c.getPixelForValue(p + f), s = (o - r) / 2, {
                                size: s,
                                base: r,
                                head: o,
                                center: o + s / 2
                            };
                        },
                        calculateBarIndexPixels: function(t, e, n) {
                            var i, a, o, s, l, u, d = this, c = n.scale.options, h = d.getStackIndex(t), f = n.pixels, g = f[e], m = f.length, p = n.start, v = n.end;
                            return 1 === m ? (i = g > p ? g - p : v - g, a = g < v ? v - g : g - p) : (e > 0 && (i = (g - f[e - 1]) / 2, e === m - 1 && (a = i)), e < m - 1 && (a = (f[e + 1] - g) / 2, 0 === e && (i = a))), o = i * c.categoryPercentage, s = a * c.categoryPercentage, l = (o + s) / n.stackCount, u = l * c.barPercentage, u = Math.min(r.valueOrDefault(c.barThickness, u), r.valueOrDefault(c.maxBarThickness, 1 / 0)), g -= o, g += l * h, g += (l - u) / 2, {
                                size: u,
                                base: g,
                                head: g + u,
                                center: g + u / 2
                            };
                        },
                        draw: function() {
                            var t = this, e = t.chart, n = t.getValueScale(), i = t.getMeta().data, a = t.getDataset(), o = i.length, s = 0;
                            for(r.canvas.clipArea(e.ctx, e.chartArea); s < o; ++s)isNaN(n.getRightValue(a.data[s])) || i[s].draw();
                            r.canvas.unclipArea(e.ctx);
                        },
                        setHoverStyle: function(t) {
                            var e = this.chart.data.datasets[t._datasetIndex], n = t._index, i = t.custom || {
                            }, a = t._model;
                            a.backgroundColor = i.hoverBackgroundColor ? i.hoverBackgroundColor : r.valueAtIndexOrDefault(e.hoverBackgroundColor, n, r.getHoverColor(a.backgroundColor)), a.borderColor = i.hoverBorderColor ? i.hoverBorderColor : r.valueAtIndexOrDefault(e.hoverBorderColor, n, r.getHoverColor(a.borderColor)), a.borderWidth = i.hoverBorderWidth ? i.hoverBorderWidth : r.valueAtIndexOrDefault(e.hoverBorderWidth, n, a.borderWidth);
                        },
                        removeHoverStyle: function(t) {
                            var e = this.chart.data.datasets[t._datasetIndex], n = t._index, i = t.custom || {
                            }, a = t._model, o = this.chart.options.elements.rectangle;
                            a.backgroundColor = i.backgroundColor ? i.backgroundColor : r.valueAtIndexOrDefault(e.backgroundColor, n, o.backgroundColor), a.borderColor = i.borderColor ? i.borderColor : r.valueAtIndexOrDefault(e.borderColor, n, o.borderColor), a.borderWidth = i.borderWidth ? i.borderWidth : r.valueAtIndexOrDefault(e.borderWidth, n, o.borderWidth);
                        }
                    }), t.controllers.horizontalBar = t.controllers.bar.extend({
                        getValueScaleId: function() {
                            return this.getMeta().xAxisID;
                        },
                        getIndexScaleId: function() {
                            return this.getMeta().yAxisID;
                        }
                    });
                };
            },
            {
                25: 25,
                40: 40,
                45: 45
            }
        ],
        16: [
            function(t, e, n) {
                "use strict";
                var i = t(25), a = t(40), r = t(45);
                i._set("bubble", {
                    hover: {
                        mode: "single"
                    },
                    scales: {
                        xAxes: [
                            {
                                type: "linear",
                                position: "bottom",
                                id: "x-axis-0"
                            }
                        ],
                        yAxes: [
                            {
                                type: "linear",
                                position: "left",
                                id: "y-axis-0"
                            }
                        ]
                    },
                    tooltips: {
                        callbacks: {
                            title: function() {
                                return "";
                            },
                            label: function(t, e) {
                                var n = e.datasets[t.datasetIndex].label || "", i = e.datasets[t.datasetIndex].data[t.index];
                                return n + ": (" + t.xLabel + ", " + t.yLabel + ", " + i.r + ")";
                            }
                        }
                    }
                }), e.exports = function(t) {
                    t.controllers.bubble = t.DatasetController.extend({
                        dataElementType: a.Point,
                        update: function(t) {
                            var e = this, n = e.getMeta().data;
                            r.each(n, function(n, i) {
                                e.updateElement(n, i, t);
                            });
                        },
                        updateElement: function(t, e, n) {
                            var i = this, a = i.getMeta(), r = t.custom || {
                            }, o = i.getScaleForId(a.xAxisID), s = i.getScaleForId(a.yAxisID), l = i._resolveElementOptions(t, e), u = i.getDataset().data[e], d = i.index, c = n ? o.getPixelForDecimal(0.5) : o.getPixelForValue("object" == typeof u ? u : NaN, e, d), h = n ? s.getBasePixel() : s.getPixelForValue(u, e, d);
                            t._xScale = o, t._yScale = s, t._options = l, t._datasetIndex = d, t._index = e, t._model = {
                                backgroundColor: l.backgroundColor,
                                borderColor: l.borderColor,
                                borderWidth: l.borderWidth,
                                hitRadius: l.hitRadius,
                                pointStyle: l.pointStyle,
                                radius: n ? 0 : l.radius,
                                skip: r.skip || isNaN(c) || isNaN(h),
                                x: c,
                                y: h
                            }, t.pivot();
                        },
                        setHoverStyle: function(t) {
                            var e = t._model, n = t._options;
                            e.backgroundColor = r.valueOrDefault(n.hoverBackgroundColor, r.getHoverColor(n.backgroundColor)), e.borderColor = r.valueOrDefault(n.hoverBorderColor, r.getHoverColor(n.borderColor)), e.borderWidth = r.valueOrDefault(n.hoverBorderWidth, n.borderWidth), e.radius = n.radius + n.hoverRadius;
                        },
                        removeHoverStyle: function(t) {
                            var e = t._model, n = t._options;
                            e.backgroundColor = n.backgroundColor, e.borderColor = n.borderColor, e.borderWidth = n.borderWidth, e.radius = n.radius;
                        },
                        _resolveElementOptions: function(t, e) {
                            var n, i, a, o = this, s = o.chart, l = s.data.datasets[o.index], u = t.custom || {
                            }, d = s.options.elements.point, c = r.options.resolve, h = l.data[e], f = {
                            }, g = {
                                chart: s,
                                dataIndex: e,
                                dataset: l,
                                datasetIndex: o.index
                            }, m = [
                                "backgroundColor",
                                "borderColor",
                                "borderWidth",
                                "hoverBackgroundColor",
                                "hoverBorderColor",
                                "hoverBorderWidth",
                                "hoverRadius",
                                "hitRadius",
                                "pointStyle"
                            ];
                            for(n = 0, i = m.length; n < i; ++n)f[a = m[n]] = c([
                                u[a],
                                l[a],
                                d[a]
                            ], g, e);
                            return f.radius = c([
                                u.radius,
                                h ? h.r : void 0,
                                l.radius,
                                d.radius
                            ], g, e), f;
                        }
                    });
                };
            },
            {
                25: 25,
                40: 40,
                45: 45
            }
        ],
        17: [
            function(t, e, n) {
                "use strict";
                var i = t(25), a = t(40), r = t(45);
                i._set("doughnut", {
                    animation: {
                        animateRotate: !0,
                        animateScale: !1
                    },
                    hover: {
                        mode: "single"
                    },
                    legendCallback: function(t) {
                        var e = [];
                        e.push('<ul class="' + t.id + '-legend">');
                        var n = t.data, i = n.datasets, a = n.labels;
                        if (i.length) for(var r = 0; r < i[0].data.length; ++r)e.push('<li><span style="background-color:' + i[0].backgroundColor[r] + '"></span>'), a[r] && e.push(a[r]), e.push("</li>");
                        return e.push("</ul>"), e.join("");
                    },
                    legend: {
                        labels: {
                            generateLabels: function(t) {
                                var e = t.data;
                                return e.labels.length && e.datasets.length ? e.labels.map(function(n, i) {
                                    var a = t.getDatasetMeta(0), o = e.datasets[0], s = a.data[i], l = s && s.custom || {
                                    }, u = r.valueAtIndexOrDefault, d = t.options.elements.arc;
                                    return {
                                        text: n,
                                        fillStyle: l.backgroundColor ? l.backgroundColor : u(o.backgroundColor, i, d.backgroundColor),
                                        strokeStyle: l.borderColor ? l.borderColor : u(o.borderColor, i, d.borderColor),
                                        lineWidth: l.borderWidth ? l.borderWidth : u(o.borderWidth, i, d.borderWidth),
                                        hidden: isNaN(o.data[i]) || a.data[i].hidden,
                                        index: i
                                    };
                                }) : [];
                            }
                        },
                        onClick: function(t, e) {
                            var n, i, a, r = e.index, o = this.chart;
                            for(n = 0, i = (o.data.datasets || []).length; n < i; ++n)(a = o.getDatasetMeta(n)).data[r] && (a.data[r].hidden = !a.data[r].hidden);
                            o.update();
                        }
                    },
                    cutoutPercentage: 50,
                    rotation: -0.5 * Math.PI,
                    circumference: 2 * Math.PI,
                    tooltips: {
                        callbacks: {
                            title: function() {
                                return "";
                            },
                            label: function(t, e) {
                                var n = e.labels[t.index], i = ": " + e.datasets[t.datasetIndex].data[t.index];
                                return r.isArray(n) ? (n = n.slice())[0] += i : n += i, n;
                            }
                        }
                    }
                }), i._set("pie", r.clone(i.doughnut)), i._set("pie", {
                    cutoutPercentage: 0
                }), e.exports = function(t) {
                    t.controllers.doughnut = t.controllers.pie = t.DatasetController.extend({
                        dataElementType: a.Arc,
                        linkScales: r.noop,
                        getRingIndex: function(t) {
                            for(var e = 0, n = 0; n < t; ++n)this.chart.isDatasetVisible(n) && ++e;
                            return e;
                        },
                        update: function(t) {
                            var e = this, n = e.chart, i = n.chartArea, a = n.options, o = a.elements.arc, s = i.right - i.left - o.borderWidth, l = i.bottom - i.top - o.borderWidth, u = Math.min(s, l), d = {
                                x: 0,
                                y: 0
                            }, c = e.getMeta(), h = a.cutoutPercentage, f = a.circumference;
                            if (f < 2 * Math.PI) {
                                var g = a.rotation % (2 * Math.PI), m = (g += 2 * Math.PI * (g >= Math.PI ? -1 : g < -Math.PI ? 1 : 0)) + f, p = {
                                    x: Math.cos(g),
                                    y: Math.sin(g)
                                }, v = {
                                    x: Math.cos(m),
                                    y: Math.sin(m)
                                }, y = g <= 0 && m >= 0 || g <= 2 * Math.PI && 2 * Math.PI <= m, b = g <= 0.5 * Math.PI && 0.5 * Math.PI <= m || g <= 2.5 * Math.PI && 2.5 * Math.PI <= m, x = g <= -Math.PI && -Math.PI <= m || g <= Math.PI && Math.PI <= m, _ = g <= 0.5 * -Math.PI && 0.5 * -Math.PI <= m || g <= 1.5 * Math.PI && 1.5 * Math.PI <= m, k = h / 100, w = {
                                    x: x ? -1 : Math.min(p.x * (p.x < 0 ? 1 : k), v.x * (v.x < 0 ? 1 : k)),
                                    y: _ ? -1 : Math.min(p.y * (p.y < 0 ? 1 : k), v.y * (v.y < 0 ? 1 : k))
                                }, M = {
                                    x: y ? 1 : Math.max(p.x * (p.x > 0 ? 1 : k), v.x * (v.x > 0 ? 1 : k)),
                                    y: b ? 1 : Math.max(p.y * (p.y > 0 ? 1 : k), v.y * (v.y > 0 ? 1 : k))
                                }, S = {
                                    width: 0.5 * (M.x - w.x),
                                    height: 0.5 * (M.y - w.y)
                                };
                                u = Math.min(s / S.width, l / S.height), d = {
                                    x: -0.5 * (M.x + w.x),
                                    y: -0.5 * (M.y + w.y)
                                };
                            }
                            n.borderWidth = e.getMaxBorderWidth(c.data), n.outerRadius = Math.max((u - n.borderWidth) / 2, 0), n.innerRadius = Math.max(h ? n.outerRadius / 100 * h : 0, 0), n.radiusLength = (n.outerRadius - n.innerRadius) / n.getVisibleDatasetCount(), n.offsetX = d.x * n.outerRadius, n.offsetY = d.y * n.outerRadius, c.total = e.calculateTotal(), e.outerRadius = n.outerRadius - n.radiusLength * e.getRingIndex(e.index), e.innerRadius = Math.max(e.outerRadius - n.radiusLength, 0), r.each(c.data, function(n, i) {
                                e.updateElement(n, i, t);
                            });
                        },
                        updateElement: function(t, e, n) {
                            var i = this, a = i.chart, o = a.chartArea, s = a.options, l = s.animation, u = (o.left + o.right) / 2, d = (o.top + o.bottom) / 2, c = s.rotation, h = s.rotation, f = i.getDataset(), g = n && l.animateRotate ? 0 : t.hidden ? 0 : i.calculateCircumference(f.data[e]) * (s.circumference / (2 * Math.PI)), m = n && l.animateScale ? 0 : i.innerRadius, p = n && l.animateScale ? 0 : i.outerRadius, v = r.valueAtIndexOrDefault;
                            r.extend(t, {
                                _datasetIndex: i.index,
                                _index: e,
                                _model: {
                                    x: u + a.offsetX,
                                    y: d + a.offsetY,
                                    startAngle: c,
                                    endAngle: h,
                                    circumference: g,
                                    outerRadius: p,
                                    innerRadius: m,
                                    label: v(f.label, e, a.data.labels[e])
                                }
                            });
                            var y = t._model;
                            this.removeHoverStyle(t), n && l.animateRotate || (y.startAngle = 0 === e ? s.rotation : i.getMeta().data[e - 1]._model.endAngle, y.endAngle = y.startAngle + y.circumference), t.pivot();
                        },
                        removeHoverStyle: function(e) {
                            t.DatasetController.prototype.removeHoverStyle.call(this, e, this.chart.options.elements.arc);
                        },
                        calculateTotal: function() {
                            var t, e = this.getDataset(), n = this.getMeta(), i = 0;
                            return r.each(n.data, function(n, a) {
                                t = e.data[a], isNaN(t) || n.hidden || (i += Math.abs(t));
                            }), i;
                        },
                        calculateCircumference: function(t) {
                            var e = this.getMeta().total;
                            return e > 0 && !isNaN(t) ? 2 * Math.PI * (t / e) : 0;
                        },
                        getMaxBorderWidth: function(t) {
                            for(var e, n, i = 0, a = this.index, r = t.length, o = 0; o < r; o++)e = t[o]._model ? t[o]._model.borderWidth : 0, i = (n = t[o]._chart ? t[o]._chart.config.data.datasets[a].hoverBorderWidth : 0) > (i = e > i ? e : i) ? n : i;
                            return i;
                        }
                    });
                };
            },
            {
                25: 25,
                40: 40,
                45: 45
            }
        ],
        18: [
            function(t, e, n) {
                "use strict";
                var i = t(25), a = t(40), r = t(45);
                i._set("line", {
                    showLines: !0,
                    spanGaps: !1,
                    hover: {
                        mode: "label"
                    },
                    scales: {
                        xAxes: [
                            {
                                type: "category",
                                id: "x-axis-0"
                            }
                        ],
                        yAxes: [
                            {
                                type: "linear",
                                id: "y-axis-0"
                            }
                        ]
                    }
                }), e.exports = function(t) {
                    function e(t, e) {
                        return r.valueOrDefault(t.showLine, e.showLines);
                    }
                    t.controllers.line = t.DatasetController.extend({
                        datasetElementType: a.Line,
                        dataElementType: a.Point,
                        update: function(t) {
                            var n, i, a, o = this, s = o.getMeta(), l = s.dataset, u = s.data || [], d = o.chart.options, c = d.elements.line, h = o.getScaleForId(s.yAxisID), f = o.getDataset(), g = e(f, d);
                            for(g && (a = l.custom || {
                            }, void 0 !== f.tension && void 0 === f.lineTension && (f.lineTension = f.tension), l._scale = h, l._datasetIndex = o.index, l._children = u, l._model = {
                                spanGaps: f.spanGaps ? f.spanGaps : d.spanGaps,
                                tension: a.tension ? a.tension : r.valueOrDefault(f.lineTension, c.tension),
                                backgroundColor: a.backgroundColor ? a.backgroundColor : f.backgroundColor || c.backgroundColor,
                                borderWidth: a.borderWidth ? a.borderWidth : f.borderWidth || c.borderWidth,
                                borderColor: a.borderColor ? a.borderColor : f.borderColor || c.borderColor,
                                borderCapStyle: a.borderCapStyle ? a.borderCapStyle : f.borderCapStyle || c.borderCapStyle,
                                borderDash: a.borderDash ? a.borderDash : f.borderDash || c.borderDash,
                                borderDashOffset: a.borderDashOffset ? a.borderDashOffset : f.borderDashOffset || c.borderDashOffset,
                                borderJoinStyle: a.borderJoinStyle ? a.borderJoinStyle : f.borderJoinStyle || c.borderJoinStyle,
                                fill: a.fill ? a.fill : void 0 !== f.fill ? f.fill : c.fill,
                                steppedLine: a.steppedLine ? a.steppedLine : r.valueOrDefault(f.steppedLine, c.stepped),
                                cubicInterpolationMode: a.cubicInterpolationMode ? a.cubicInterpolationMode : r.valueOrDefault(f.cubicInterpolationMode, c.cubicInterpolationMode)
                            }, l.pivot()), n = 0, i = u.length; n < i; ++n)o.updateElement(u[n], n, t);
                            for(g && 0 !== l._model.tension && o.updateBezierControlPoints(), n = 0, i = u.length; n < i; ++n)u[n].pivot();
                        },
                        getPointBackgroundColor: function(t, e) {
                            var n = this.chart.options.elements.point.backgroundColor, i = this.getDataset(), a = t.custom || {
                            };
                            return a.backgroundColor ? n = a.backgroundColor : i.pointBackgroundColor ? n = r.valueAtIndexOrDefault(i.pointBackgroundColor, e, n) : i.backgroundColor && (n = i.backgroundColor), n;
                        },
                        getPointBorderColor: function(t, e) {
                            var n = this.chart.options.elements.point.borderColor, i = this.getDataset(), a = t.custom || {
                            };
                            return a.borderColor ? n = a.borderColor : i.pointBorderColor ? n = r.valueAtIndexOrDefault(i.pointBorderColor, e, n) : i.borderColor && (n = i.borderColor), n;
                        },
                        getPointBorderWidth: function(t, e) {
                            var n = this.chart.options.elements.point.borderWidth, i = this.getDataset(), a = t.custom || {
                            };
                            return isNaN(a.borderWidth) ? !isNaN(i.pointBorderWidth) || r.isArray(i.pointBorderWidth) ? n = r.valueAtIndexOrDefault(i.pointBorderWidth, e, n) : isNaN(i.borderWidth) || (n = i.borderWidth) : n = a.borderWidth, n;
                        },
                        updateElement: function(t, e, n) {
                            var i, a, o = this, s = o.getMeta(), l = t.custom || {
                            }, u = o.getDataset(), d = o.index, c = u.data[e], h = o.getScaleForId(s.yAxisID), f = o.getScaleForId(s.xAxisID), g = o.chart.options.elements.point;
                            void 0 !== u.radius && void 0 === u.pointRadius && (u.pointRadius = u.radius), void 0 !== u.hitRadius && void 0 === u.pointHitRadius && (u.pointHitRadius = u.hitRadius), i = f.getPixelForValue("object" == typeof c ? c : NaN, e, d), a = n ? h.getBasePixel() : o.calculatePointY(c, e, d), t._xScale = f, t._yScale = h, t._datasetIndex = d, t._index = e, t._model = {
                                x: i,
                                y: a,
                                skip: l.skip || isNaN(i) || isNaN(a),
                                radius: l.radius || r.valueAtIndexOrDefault(u.pointRadius, e, g.radius),
                                pointStyle: l.pointStyle || r.valueAtIndexOrDefault(u.pointStyle, e, g.pointStyle),
                                backgroundColor: o.getPointBackgroundColor(t, e),
                                borderColor: o.getPointBorderColor(t, e),
                                borderWidth: o.getPointBorderWidth(t, e),
                                tension: s.dataset._model ? s.dataset._model.tension : 0,
                                steppedLine: !!s.dataset._model && s.dataset._model.steppedLine,
                                hitRadius: l.hitRadius || r.valueAtIndexOrDefault(u.pointHitRadius, e, g.hitRadius)
                            };
                        },
                        calculatePointY: function(t, e, n) {
                            var i, a, r, o = this, s = o.chart, l = o.getMeta(), u = o.getScaleForId(l.yAxisID), d = 0, c = 0;
                            if (u.options.stacked) {
                                for(i = 0; i < n; i++)if (a = s.data.datasets[i], "line" === (r = s.getDatasetMeta(i)).type && r.yAxisID === u.id && s.isDatasetVisible(i)) {
                                    var h = Number(u.getRightValue(a.data[e]));
                                    h < 0 ? c += h || 0 : d += h || 0;
                                }
                                var f = Number(u.getRightValue(t));
                                return f < 0 ? u.getPixelForValue(c + f) : u.getPixelForValue(d + f);
                            }
                            return u.getPixelForValue(t);
                        },
                        updateBezierControlPoints: function() {
                            function t(t, e, n) {
                                return Math.max(Math.min(t, n), e);
                            }
                            var e, n, i, a, o = this, s = o.getMeta(), l = o.chart.chartArea, u = s.data || [];
                            if (s.dataset._model.spanGaps && (u = u.filter(function(t) {
                                return !t._model.skip;
                            })), "monotone" === s.dataset._model.cubicInterpolationMode) r.splineCurveMonotone(u);
                            else for(e = 0, n = u.length; e < n; ++e)i = u[e]._model, a = r.splineCurve(r.previousItem(u, e)._model, i, r.nextItem(u, e)._model, s.dataset._model.tension), i.controlPointPreviousX = a.previous.x, i.controlPointPreviousY = a.previous.y, i.controlPointNextX = a.next.x, i.controlPointNextY = a.next.y;
                            if (o.chart.options.elements.line.capBezierPoints) for(e = 0, n = u.length; e < n; ++e)(i = u[e]._model).controlPointPreviousX = t(i.controlPointPreviousX, l.left, l.right), i.controlPointPreviousY = t(i.controlPointPreviousY, l.top, l.bottom), i.controlPointNextX = t(i.controlPointNextX, l.left, l.right), i.controlPointNextY = t(i.controlPointNextY, l.top, l.bottom);
                        },
                        draw: function() {
                            var t = this, n = t.chart, i = t.getMeta(), a = i.data || [], o = n.chartArea, s = a.length, l = 0;
                            for(r.canvas.clipArea(n.ctx, o), e(t.getDataset(), n.options) && i.dataset.draw(), r.canvas.unclipArea(n.ctx); l < s; ++l)a[l].draw(o);
                        },
                        setHoverStyle: function(t) {
                            var e = this.chart.data.datasets[t._datasetIndex], n = t._index, i = t.custom || {
                            }, a = t._model;
                            a.radius = i.hoverRadius || r.valueAtIndexOrDefault(e.pointHoverRadius, n, this.chart.options.elements.point.hoverRadius), a.backgroundColor = i.hoverBackgroundColor || r.valueAtIndexOrDefault(e.pointHoverBackgroundColor, n, r.getHoverColor(a.backgroundColor)), a.borderColor = i.hoverBorderColor || r.valueAtIndexOrDefault(e.pointHoverBorderColor, n, r.getHoverColor(a.borderColor)), a.borderWidth = i.hoverBorderWidth || r.valueAtIndexOrDefault(e.pointHoverBorderWidth, n, a.borderWidth);
                        },
                        removeHoverStyle: function(t) {
                            var e = this, n = e.chart.data.datasets[t._datasetIndex], i = t._index, a = t.custom || {
                            }, o = t._model;
                            void 0 !== n.radius && void 0 === n.pointRadius && (n.pointRadius = n.radius), o.radius = a.radius || r.valueAtIndexOrDefault(n.pointRadius, i, e.chart.options.elements.point.radius), o.backgroundColor = e.getPointBackgroundColor(t, i), o.borderColor = e.getPointBorderColor(t, i), o.borderWidth = e.getPointBorderWidth(t, i);
                        }
                    });
                };
            },
            {
                25: 25,
                40: 40,
                45: 45
            }
        ],
        19: [
            function(t, e, n) {
                "use strict";
                var i = t(25), a = t(40), r = t(45);
                i._set("polarArea", {
                    scale: {
                        type: "radialLinear",
                        angleLines: {
                            display: !1
                        },
                        gridLines: {
                            circular: !0
                        },
                        pointLabels: {
                            display: !1
                        },
                        ticks: {
                            beginAtZero: !0
                        }
                    },
                    animation: {
                        animateRotate: !0,
                        animateScale: !0
                    },
                    startAngle: -0.5 * Math.PI,
                    legendCallback: function(t) {
                        var e = [];
                        e.push('<ul class="' + t.id + '-legend">');
                        var n = t.data, i = n.datasets, a = n.labels;
                        if (i.length) for(var r = 0; r < i[0].data.length; ++r)e.push('<li><span style="background-color:' + i[0].backgroundColor[r] + '"></span>'), a[r] && e.push(a[r]), e.push("</li>");
                        return e.push("</ul>"), e.join("");
                    },
                    legend: {
                        labels: {
                            generateLabels: function(t) {
                                var e = t.data;
                                return e.labels.length && e.datasets.length ? e.labels.map(function(n, i) {
                                    var a = t.getDatasetMeta(0), o = e.datasets[0], s = a.data[i].custom || {
                                    }, l = r.valueAtIndexOrDefault, u = t.options.elements.arc;
                                    return {
                                        text: n,
                                        fillStyle: s.backgroundColor ? s.backgroundColor : l(o.backgroundColor, i, u.backgroundColor),
                                        strokeStyle: s.borderColor ? s.borderColor : l(o.borderColor, i, u.borderColor),
                                        lineWidth: s.borderWidth ? s.borderWidth : l(o.borderWidth, i, u.borderWidth),
                                        hidden: isNaN(o.data[i]) || a.data[i].hidden,
                                        index: i
                                    };
                                }) : [];
                            }
                        },
                        onClick: function(t, e) {
                            var n, i, a, r = e.index, o = this.chart;
                            for(n = 0, i = (o.data.datasets || []).length; n < i; ++n)(a = o.getDatasetMeta(n)).data[r].hidden = !a.data[r].hidden;
                            o.update();
                        }
                    },
                    tooltips: {
                        callbacks: {
                            title: function() {
                                return "";
                            },
                            label: function(t, e) {
                                return e.labels[t.index] + ": " + t.yLabel;
                            }
                        }
                    }
                }), e.exports = function(t) {
                    t.controllers.polarArea = t.DatasetController.extend({
                        dataElementType: a.Arc,
                        linkScales: r.noop,
                        update: function(t) {
                            var e = this, n = e.chart, i = n.chartArea, a = e.getMeta(), o = n.options, s = o.elements.arc, l = Math.min(i.right - i.left, i.bottom - i.top);
                            n.outerRadius = Math.max((l - s.borderWidth / 2) / 2, 0), n.innerRadius = Math.max(o.cutoutPercentage ? n.outerRadius / 100 * o.cutoutPercentage : 1, 0), n.radiusLength = (n.outerRadius - n.innerRadius) / n.getVisibleDatasetCount(), e.outerRadius = n.outerRadius - n.radiusLength * e.index, e.innerRadius = e.outerRadius - n.radiusLength, a.count = e.countVisibleElements(), r.each(a.data, function(n, i) {
                                e.updateElement(n, i, t);
                            });
                        },
                        updateElement: function(t, e, n) {
                            for(var i = this, a = i.chart, o = i.getDataset(), s = a.options, l = s.animation, u = a.scale, d = a.data.labels, c = i.calculateCircumference(o.data[e]), h = u.xCenter, f = u.yCenter, g = 0, m = i.getMeta(), p = 0; p < e; ++p)isNaN(o.data[p]) || m.data[p].hidden || ++g;
                            var v = s.startAngle, y = t.hidden ? 0 : u.getDistanceFromCenterForValue(o.data[e]), b = v + c * g, x = b + (t.hidden ? 0 : c), _ = l.animateScale ? 0 : u.getDistanceFromCenterForValue(o.data[e]);
                            r.extend(t, {
                                _datasetIndex: i.index,
                                _index: e,
                                _scale: u,
                                _model: {
                                    x: h,
                                    y: f,
                                    innerRadius: 0,
                                    outerRadius: n ? _ : y,
                                    startAngle: n && l.animateRotate ? v : b,
                                    endAngle: n && l.animateRotate ? v : x,
                                    label: r.valueAtIndexOrDefault(d, e, d[e])
                                }
                            }), i.removeHoverStyle(t), t.pivot();
                        },
                        removeHoverStyle: function(e) {
                            t.DatasetController.prototype.removeHoverStyle.call(this, e, this.chart.options.elements.arc);
                        },
                        countVisibleElements: function() {
                            var t = this.getDataset(), e = this.getMeta(), n = 0;
                            return r.each(e.data, function(e, i) {
                                isNaN(t.data[i]) || e.hidden || n++;
                            }), n;
                        },
                        calculateCircumference: function(t) {
                            var e = this.getMeta().count;
                            return e > 0 && !isNaN(t) ? 2 * Math.PI / e : 0;
                        }
                    });
                };
            },
            {
                25: 25,
                40: 40,
                45: 45
            }
        ],
        20: [
            function(t, e, n) {
                "use strict";
                var i = t(25), a = t(40), r = t(45);
                i._set("radar", {
                    scale: {
                        type: "radialLinear"
                    },
                    elements: {
                        line: {
                            tension: 0
                        }
                    }
                }), e.exports = function(t) {
                    t.controllers.radar = t.DatasetController.extend({
                        datasetElementType: a.Line,
                        dataElementType: a.Point,
                        linkScales: r.noop,
                        update: function(t) {
                            var e = this, n = e.getMeta(), i = n.dataset, a = n.data, o = i.custom || {
                            }, s = e.getDataset(), l = e.chart.options.elements.line, u = e.chart.scale;
                            void 0 !== s.tension && void 0 === s.lineTension && (s.lineTension = s.tension), r.extend(n.dataset, {
                                _datasetIndex: e.index,
                                _scale: u,
                                _children: a,
                                _loop: !0,
                                _model: {
                                    tension: o.tension ? o.tension : r.valueOrDefault(s.lineTension, l.tension),
                                    backgroundColor: o.backgroundColor ? o.backgroundColor : s.backgroundColor || l.backgroundColor,
                                    borderWidth: o.borderWidth ? o.borderWidth : s.borderWidth || l.borderWidth,
                                    borderColor: o.borderColor ? o.borderColor : s.borderColor || l.borderColor,
                                    fill: o.fill ? o.fill : void 0 !== s.fill ? s.fill : l.fill,
                                    borderCapStyle: o.borderCapStyle ? o.borderCapStyle : s.borderCapStyle || l.borderCapStyle,
                                    borderDash: o.borderDash ? o.borderDash : s.borderDash || l.borderDash,
                                    borderDashOffset: o.borderDashOffset ? o.borderDashOffset : s.borderDashOffset || l.borderDashOffset,
                                    borderJoinStyle: o.borderJoinStyle ? o.borderJoinStyle : s.borderJoinStyle || l.borderJoinStyle
                                }
                            }), n.dataset.pivot(), r.each(a, function(n, i) {
                                e.updateElement(n, i, t);
                            }, e), e.updateBezierControlPoints();
                        },
                        updateElement: function(t, e, n) {
                            var i = this, a = t.custom || {
                            }, o = i.getDataset(), s = i.chart.scale, l = i.chart.options.elements.point, u = s.getPointPositionForValue(e, o.data[e]);
                            void 0 !== o.radius && void 0 === o.pointRadius && (o.pointRadius = o.radius), void 0 !== o.hitRadius && void 0 === o.pointHitRadius && (o.pointHitRadius = o.hitRadius), r.extend(t, {
                                _datasetIndex: i.index,
                                _index: e,
                                _scale: s,
                                _model: {
                                    x: n ? s.xCenter : u.x,
                                    y: n ? s.yCenter : u.y,
                                    tension: a.tension ? a.tension : r.valueOrDefault(o.lineTension, i.chart.options.elements.line.tension),
                                    radius: a.radius ? a.radius : r.valueAtIndexOrDefault(o.pointRadius, e, l.radius),
                                    backgroundColor: a.backgroundColor ? a.backgroundColor : r.valueAtIndexOrDefault(o.pointBackgroundColor, e, l.backgroundColor),
                                    borderColor: a.borderColor ? a.borderColor : r.valueAtIndexOrDefault(o.pointBorderColor, e, l.borderColor),
                                    borderWidth: a.borderWidth ? a.borderWidth : r.valueAtIndexOrDefault(o.pointBorderWidth, e, l.borderWidth),
                                    pointStyle: a.pointStyle ? a.pointStyle : r.valueAtIndexOrDefault(o.pointStyle, e, l.pointStyle),
                                    hitRadius: a.hitRadius ? a.hitRadius : r.valueAtIndexOrDefault(o.pointHitRadius, e, l.hitRadius)
                                }
                            }), t._model.skip = a.skip ? a.skip : isNaN(t._model.x) || isNaN(t._model.y);
                        },
                        updateBezierControlPoints: function() {
                            var t = this.chart.chartArea, e = this.getMeta();
                            r.each(e.data, function(n, i) {
                                var a = n._model, o = r.splineCurve(r.previousItem(e.data, i, !0)._model, a, r.nextItem(e.data, i, !0)._model, a.tension);
                                a.controlPointPreviousX = Math.max(Math.min(o.previous.x, t.right), t.left), a.controlPointPreviousY = Math.max(Math.min(o.previous.y, t.bottom), t.top), a.controlPointNextX = Math.max(Math.min(o.next.x, t.right), t.left), a.controlPointNextY = Math.max(Math.min(o.next.y, t.bottom), t.top), n.pivot();
                            });
                        },
                        setHoverStyle: function(t) {
                            var e = this.chart.data.datasets[t._datasetIndex], n = t.custom || {
                            }, i = t._index, a = t._model;
                            a.radius = n.hoverRadius ? n.hoverRadius : r.valueAtIndexOrDefault(e.pointHoverRadius, i, this.chart.options.elements.point.hoverRadius), a.backgroundColor = n.hoverBackgroundColor ? n.hoverBackgroundColor : r.valueAtIndexOrDefault(e.pointHoverBackgroundColor, i, r.getHoverColor(a.backgroundColor)), a.borderColor = n.hoverBorderColor ? n.hoverBorderColor : r.valueAtIndexOrDefault(e.pointHoverBorderColor, i, r.getHoverColor(a.borderColor)), a.borderWidth = n.hoverBorderWidth ? n.hoverBorderWidth : r.valueAtIndexOrDefault(e.pointHoverBorderWidth, i, a.borderWidth);
                        },
                        removeHoverStyle: function(t) {
                            var e = this.chart.data.datasets[t._datasetIndex], n = t.custom || {
                            }, i = t._index, a = t._model, o = this.chart.options.elements.point;
                            a.radius = n.radius ? n.radius : r.valueAtIndexOrDefault(e.pointRadius, i, o.radius), a.backgroundColor = n.backgroundColor ? n.backgroundColor : r.valueAtIndexOrDefault(e.pointBackgroundColor, i, o.backgroundColor), a.borderColor = n.borderColor ? n.borderColor : r.valueAtIndexOrDefault(e.pointBorderColor, i, o.borderColor), a.borderWidth = n.borderWidth ? n.borderWidth : r.valueAtIndexOrDefault(e.pointBorderWidth, i, o.borderWidth);
                        }
                    });
                };
            },
            {
                25: 25,
                40: 40,
                45: 45
            }
        ],
        21: [
            function(t, e, n) {
                "use strict";
                t(25)._set("scatter", {
                    hover: {
                        mode: "single"
                    },
                    scales: {
                        xAxes: [
                            {
                                id: "x-axis-1",
                                type: "linear",
                                position: "bottom"
                            }
                        ],
                        yAxes: [
                            {
                                id: "y-axis-1",
                                type: "linear",
                                position: "left"
                            }
                        ]
                    },
                    showLines: !1,
                    tooltips: {
                        callbacks: {
                            title: function() {
                                return "";
                            },
                            label: function(t) {
                                return "(" + t.xLabel + ", " + t.yLabel + ")";
                            }
                        }
                    }
                }), e.exports = function(t) {
                    t.controllers.scatter = t.controllers.line;
                };
            },
            {
                25: 25
            }
        ],
        22: [
            function(t, e, n) {
                "use strict";
                var i = t(25), a = t(26), r = t(45);
                i._set("global", {
                    animation: {
                        duration: 1000,
                        easing: "easeOutQuart",
                        onProgress: r.noop,
                        onComplete: r.noop
                    }
                }), e.exports = function(t) {
                    t.Animation = a.extend({
                        chart: null,
                        currentStep: 0,
                        numSteps: 60,
                        easing: "",
                        render: null,
                        onAnimationProgress: null,
                        onAnimationComplete: null
                    }), t.animationService = {
                        frameDuration: 17,
                        animations: [],
                        dropFrames: 0,
                        request: null,
                        addAnimation: function(t, e, n, i) {
                            var a, r, o = this.animations;
                            for(e.chart = t, i || (t.animating = !0), a = 0, r = o.length; a < r; ++a)if (o[a].chart === t) return void (o[a] = e);
                            o.push(e), 1 === o.length && this.requestAnimationFrame();
                        },
                        cancelAnimation: function(t) {
                            var e = r.findIndex(this.animations, function(e) {
                                return e.chart === t;
                            });
                            -1 !== e && (this.animations.splice(e, 1), t.animating = !1);
                        },
                        requestAnimationFrame: function() {
                            var t = this;
                            null === t.request && (t.request = r.requestAnimFrame.call(window, function() {
                                t.request = null, t.startDigest();
                            }));
                        },
                        startDigest: function() {
                            var t = this, e = Date.now(), n = 0;
                            t.dropFrames > 1 && (n = Math.floor(t.dropFrames), t.dropFrames = t.dropFrames % 1), t.advance(1 + n);
                            var i = Date.now();
                            t.dropFrames += (i - e) / t.frameDuration, t.animations.length > 0 && t.requestAnimationFrame();
                        },
                        advance: function(t) {
                            for(var e, n, i = this.animations, a = 0; a < i.length;)n = (e = i[a]).chart, e.currentStep = (e.currentStep || 0) + t, e.currentStep = Math.min(e.currentStep, e.numSteps), r.callback(e.render, [
                                n,
                                e
                            ], n), r.callback(e.onAnimationProgress, [
                                e
                            ], n), e.currentStep >= e.numSteps ? (r.callback(e.onAnimationComplete, [
                                e
                            ], n), n.animating = !1, i.splice(a, 1)) : ++a;
                        }
                    }, Object.defineProperty(t.Animation.prototype, "animationObject", {
                        get: function() {
                            return this;
                        }
                    }), Object.defineProperty(t.Animation.prototype, "chartInstance", {
                        get: function() {
                            return this.chart;
                        },
                        set: function(t) {
                            this.chart = t;
                        }
                    });
                };
            },
            {
                25: 25,
                26: 26,
                45: 45
            }
        ],
        23: [
            function(t, e, n) {
                "use strict";
                var i = t(25), a = t(45), r = t(28), o = t(48);
                e.exports = function(t) {
                    function e(t) {
                        var e = (t = t || {
                        }).data = t.data || {
                        };
                        return e.datasets = e.datasets || [], e.labels = e.labels || [], t.options = a.configMerge(i.global, i[t.type], t.options || {
                        }), t;
                    }
                    function n(t) {
                        var e = t.options;
                        e.scale ? t.scale.options = e.scale : e.scales && e.scales.xAxes.concat(e.scales.yAxes).forEach(function(e) {
                            t.scales[e.id].options = e;
                        }), t.tooltip._options = e.tooltips;
                    }
                    function s(t) {
                        return "top" === t || "bottom" === t;
                    }
                    var l = t.plugins;
                    t.types = {
                    }, t.instances = {
                    }, t.controllers = {
                    }, a.extend(t.prototype, {
                        construct: function(n, i) {
                            var r = this;
                            i = e(i);
                            var s = o.acquireContext(n, i), l = s && s.canvas, u = l && l.height, d = l && l.width;
                            r.id = a.uid(), r.ctx = s, r.canvas = l, r.config = i, r.width = d, r.height = u, r.aspectRatio = u ? d / u : null, r.options = i.options, r._bufferedRender = !1, r.chart = r, r.controller = r, t.instances[r.id] = r, Object.defineProperty(r, "data", {
                                get: function() {
                                    return r.config.data;
                                },
                                set: function(t) {
                                    r.config.data = t;
                                }
                            }), s && l ? (r.initialize(), r.update()) : console.error("Failed to create chart: can't acquire context from the given item");
                        },
                        initialize: function() {
                            var t = this;
                            return l.notify(t, "beforeInit"), a.retinaScale(t, t.options.devicePixelRatio), t.bindEvents(), t.options.responsive && t.resize(!0), t.ensureScalesHaveIDs(), t.buildScales(), t.initToolTip(), l.notify(t, "afterInit"), t;
                        },
                        clear: function() {
                            return a.canvas.clear(this), this;
                        },
                        stop: function() {
                            return t.animationService.cancelAnimation(this), this;
                        },
                        resize: function(t) {
                            var e = this, n = e.options, i = e.canvas, r = n.maintainAspectRatio && e.aspectRatio || null, o = Math.max(0, Math.floor(a.getMaximumWidth(i))), s = Math.max(0, Math.floor(r ? o / r : a.getMaximumHeight(i)));
                            if ((e.width !== o || e.height !== s) && (i.width = e.width = o, i.height = e.height = s, i.style.width = o + "px", i.style.height = s + "px", a.retinaScale(e, n.devicePixelRatio), !t)) {
                                var u = {
                                    width: o,
                                    height: s
                                };
                                l.notify(e, "resize", [
                                    u
                                ]), e.options.onResize && e.options.onResize(e, u), e.stop(), e.update(e.options.responsiveAnimationDuration);
                            }
                        },
                        ensureScalesHaveIDs: function() {
                            var t = this.options, e = t.scales || {
                            }, n = t.scale;
                            a.each(e.xAxes, function(t, e) {
                                t.id = t.id || "x-axis-" + e;
                            }), a.each(e.yAxes, function(t, e) {
                                t.id = t.id || "y-axis-" + e;
                            }), n && (n.id = n.id || "scale");
                        },
                        buildScales: function() {
                            var e = this, n = e.options, i = e.scales = {
                            }, r = [];
                            n.scales && (r = r.concat((n.scales.xAxes || []).map(function(t) {
                                return {
                                    options: t,
                                    dtype: "category",
                                    dposition: "bottom"
                                };
                            }), (n.scales.yAxes || []).map(function(t) {
                                return {
                                    options: t,
                                    dtype: "linear",
                                    dposition: "left"
                                };
                            }))), n.scale && r.push({
                                options: n.scale,
                                dtype: "radialLinear",
                                isDefault: !0,
                                dposition: "chartArea"
                            }), a.each(r, function(n) {
                                var r = n.options, o = a.valueOrDefault(r.type, n.dtype), l = t.scaleService.getScaleConstructor(o);
                                if (l) {
                                    s(r.position) !== s(n.dposition) && (r.position = n.dposition);
                                    var u = new l({
                                        id: r.id,
                                        options: r,
                                        ctx: e.ctx,
                                        chart: e
                                    });
                                    i[u.id] = u, u.mergeTicksOptions(), n.isDefault && (e.scale = u);
                                }
                            }), t.scaleService.addScalesToLayout(this);
                        },
                        buildOrUpdateControllers: function() {
                            var e = this, n = [], i = [];
                            return a.each(e.data.datasets, function(a, r) {
                                var o = e.getDatasetMeta(r), s = a.type || e.config.type;
                                if (o.type && o.type !== s && (e.destroyDatasetMeta(r), o = e.getDatasetMeta(r)), o.type = s, n.push(o.type), o.controller) o.controller.updateIndex(r);
                                else {
                                    var l = t.controllers[o.type];
                                    if (void 0 === l) throw new Error('"' + o.type + '" is not a chart type.');
                                    o.controller = new l(e, r), i.push(o.controller);
                                }
                            }, e), i;
                        },
                        resetElements: function() {
                            var t = this;
                            a.each(t.data.datasets, function(e, n) {
                                t.getDatasetMeta(n).controller.reset();
                            }, t);
                        },
                        reset: function() {
                            this.resetElements(), this.tooltip.initialize();
                        },
                        update: function(t) {
                            var e = this;
                            if (t && "object" == typeof t || (t = {
                                duration: t,
                                lazy: arguments[1]
                            }), n(e), !1 !== l.notify(e, "beforeUpdate")) {
                                e.tooltip._data = e.data;
                                var i = e.buildOrUpdateControllers();
                                a.each(e.data.datasets, function(t, n) {
                                    e.getDatasetMeta(n).controller.buildOrUpdateElements();
                                }, e), e.updateLayout(), a.each(i, function(t) {
                                    t.reset();
                                }), e.updateDatasets(), e.tooltip.initialize(), e.lastActive = [], l.notify(e, "afterUpdate"), e._bufferedRender ? e._bufferedRequest = {
                                    duration: t.duration,
                                    easing: t.easing,
                                    lazy: t.lazy
                                } : e.render(t);
                            }
                        },
                        updateLayout: function() {
                            var e = this;
                            !1 !== l.notify(e, "beforeLayout") && (t.layoutService.update(this, this.width, this.height), l.notify(e, "afterScaleUpdate"), l.notify(e, "afterLayout"));
                        },
                        updateDatasets: function() {
                            var t = this;
                            if (!1 !== l.notify(t, "beforeDatasetsUpdate")) {
                                for(var e = 0, n = t.data.datasets.length; e < n; ++e)t.updateDataset(e);
                                l.notify(t, "afterDatasetsUpdate");
                            }
                        },
                        updateDataset: function(t) {
                            var e = this, n = e.getDatasetMeta(t), i = {
                                meta: n,
                                index: t
                            };
                            !1 !== l.notify(e, "beforeDatasetUpdate", [
                                i
                            ]) && (n.controller.update(), l.notify(e, "afterDatasetUpdate", [
                                i
                            ]));
                        },
                        render: function(e) {
                            var n = this;
                            e && "object" == typeof e || (e = {
                                duration: e,
                                lazy: arguments[1]
                            });
                            var i = e.duration, r = e.lazy;
                            if (!1 !== l.notify(n, "beforeRender")) {
                                var o = n.options.animation, s = function(t) {
                                    l.notify(n, "afterRender"), a.callback(o && o.onComplete, [
                                        t
                                    ], n);
                                };
                                if (o && (void 0 !== i && 0 !== i || void 0 === i && 0 !== o.duration)) {
                                    var u = new t.Animation({
                                        numSteps: (i || o.duration) / 16.66,
                                        easing: e.easing || o.easing,
                                        render: function(t, e) {
                                            var n = a.easing.effects[e.easing], i = e.currentStep, r = i / e.numSteps;
                                            t.draw(n(r), r, i);
                                        },
                                        onAnimationProgress: o.onProgress,
                                        onAnimationComplete: s
                                    });
                                    t.animationService.addAnimation(n, u, i, r);
                                } else n.draw(), s(new t.Animation({
                                    numSteps: 0,
                                    chart: n
                                }));
                                return n;
                            }
                        },
                        draw: function(t) {
                            var e = this;
                            e.clear(), a.isNullOrUndef(t) && (t = 1), e.transition(t), !1 !== l.notify(e, "beforeDraw", [
                                t
                            ]) && (a.each(e.boxes, function(t) {
                                t.draw(e.chartArea);
                            }, e), e.scale && e.scale.draw(), e.drawDatasets(t), e._drawTooltip(t), l.notify(e, "afterDraw", [
                                t
                            ]));
                        },
                        transition: function(t) {
                            for(var e = this, n = 0, i = (e.data.datasets || []).length; n < i; ++n)e.isDatasetVisible(n) && e.getDatasetMeta(n).controller.transition(t);
                            e.tooltip.transition(t);
                        },
                        drawDatasets: function(t) {
                            var e = this;
                            if (!1 !== l.notify(e, "beforeDatasetsDraw", [
                                t
                            ])) {
                                for(var n = (e.data.datasets || []).length - 1; n >= 0; --n)e.isDatasetVisible(n) && e.drawDataset(n, t);
                                l.notify(e, "afterDatasetsDraw", [
                                    t
                                ]);
                            }
                        },
                        drawDataset: function(t, e) {
                            var n = this, i = n.getDatasetMeta(t), a = {
                                meta: i,
                                index: t,
                                easingValue: e
                            };
                            !1 !== l.notify(n, "beforeDatasetDraw", [
                                a
                            ]) && (i.controller.draw(e), l.notify(n, "afterDatasetDraw", [
                                a
                            ]));
                        },
                        _drawTooltip: function(t) {
                            var e = this, n = e.tooltip, i = {
                                tooltip: n,
                                easingValue: t
                            };
                            !1 !== l.notify(e, "beforeTooltipDraw", [
                                i
                            ]) && (n.draw(), l.notify(e, "afterTooltipDraw", [
                                i
                            ]));
                        },
                        getElementAtEvent: function(t) {
                            return r.modes.single(this, t);
                        },
                        getElementsAtEvent: function(t) {
                            return r.modes.label(this, t, {
                                intersect: !0
                            });
                        },
                        getElementsAtXAxis: function(t) {
                            return r.modes["x-axis"](this, t, {
                                intersect: !0
                            });
                        },
                        getElementsAtEventForMode: function(t, e, n) {
                            var i = r.modes[e];
                            return "function" == typeof i ? i(this, t, n) : [];
                        },
                        getDatasetAtEvent: function(t) {
                            return r.modes.dataset(this, t, {
                                intersect: !0
                            });
                        },
                        getDatasetMeta: function(t) {
                            var e = this, n = e.data.datasets[t];
                            n._meta || (n._meta = {
                            });
                            var i = n._meta[e.id];
                            return i || (i = n._meta[e.id] = {
                                type: null,
                                data: [],
                                dataset: null,
                                controller: null,
                                hidden: null,
                                xAxisID: null,
                                yAxisID: null
                            }), i;
                        },
                        getVisibleDatasetCount: function() {
                            for(var t = 0, e = 0, n = this.data.datasets.length; e < n; ++e)this.isDatasetVisible(e) && t++;
                            return t;
                        },
                        isDatasetVisible: function(t) {
                            var e = this.getDatasetMeta(t);
                            return "boolean" == typeof e.hidden ? !e.hidden : !this.data.datasets[t].hidden;
                        },
                        generateLegend: function() {
                            return this.options.legendCallback(this);
                        },
                        destroyDatasetMeta: function(t) {
                            var e = this.id, n = this.data.datasets[t], i = n._meta && n._meta[e];
                            i && (i.controller.destroy(), delete n._meta[e]);
                        },
                        destroy: function() {
                            var e, n, i = this, r = i.canvas;
                            for(i.stop(), e = 0, n = i.data.datasets.length; e < n; ++e)i.destroyDatasetMeta(e);
                            r && (i.unbindEvents(), a.canvas.clear(i), o.releaseContext(i.ctx), i.canvas = null, i.ctx = null), l.notify(i, "destroy"), delete t.instances[i.id];
                        },
                        toBase64Image: function() {
                            return this.canvas.toDataURL.apply(this.canvas, arguments);
                        },
                        initToolTip: function() {
                            var e = this;
                            e.tooltip = new t.Tooltip({
                                _chart: e,
                                _chartInstance: e,
                                _data: e.data,
                                _options: e.options.tooltips
                            }, e);
                        },
                        bindEvents: function() {
                            var t = this, e = t._listeners = {
                            }, n = function() {
                                t.eventHandler.apply(t, arguments);
                            };
                            a.each(t.options.events, function(i) {
                                o.addEventListener(t, i, n), e[i] = n;
                            }), t.options.responsive && (n = function() {
                                t.resize();
                            }, o.addEventListener(t, "resize", n), e.resize = n);
                        },
                        unbindEvents: function() {
                            var t = this, e = t._listeners;
                            e && (delete t._listeners, a.each(e, function(e, n) {
                                o.removeEventListener(t, n, e);
                            }));
                        },
                        updateHoverStyle: function(t, e, n) {
                            var i, a, r, o = n ? "setHoverStyle" : "removeHoverStyle";
                            for(a = 0, r = t.length; a < r; ++a)(i = t[a]) && this.getDatasetMeta(i._datasetIndex).controller[o](i);
                        },
                        eventHandler: function(t) {
                            var e = this, n = e.tooltip;
                            if (!1 !== l.notify(e, "beforeEvent", [
                                t
                            ])) {
                                e._bufferedRender = !0, e._bufferedRequest = null;
                                var i = e.handleEvent(t);
                                i |= n && n.handleEvent(t), l.notify(e, "afterEvent", [
                                    t
                                ]);
                                var a = e._bufferedRequest;
                                return a ? e.render(a) : i && !e.animating && (e.stop(), e.render(e.options.hover.animationDuration, !0)), e._bufferedRender = !1, e._bufferedRequest = null, e;
                            }
                        },
                        handleEvent: function(t) {
                            var e = this, n = e.options || {
                            }, i = n.hover, r = !1;
                            return e.lastActive = e.lastActive || [], "mouseout" === t.type ? e.active = [] : e.active = e.getElementsAtEventForMode(t, i.mode, i), a.callback(n.onHover || n.hover.onHover, [
                                t.native,
                                e.active
                            ], e), "mouseup" !== t.type && "click" !== t.type || n.onClick && n.onClick.call(e, t.native, e.active), e.lastActive.length && e.updateHoverStyle(e.lastActive, i.mode, !1), e.active.length && i.mode && e.updateHoverStyle(e.active, i.mode, !0), r = !a.arrayEquals(e.active, e.lastActive), e.lastActive = e.active, r;
                        }
                    }), t.Controller = t;
                };
            },
            {
                25: 25,
                28: 28,
                45: 45,
                48: 48
            }
        ],
        24: [
            function(t, e, n) {
                "use strict";
                var i = t(45);
                e.exports = function(t) {
                    function e(t, e) {
                        t._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, "_chartjs", {
                            configurable: !0,
                            enumerable: !1,
                            value: {
                                listeners: [
                                    e
                                ]
                            }
                        }), a.forEach(function(e) {
                            var n = "onData" + e.charAt(0).toUpperCase() + e.slice(1), a = t[e];
                            Object.defineProperty(t, e, {
                                configurable: !0,
                                enumerable: !1,
                                value: function() {
                                    var e = Array.prototype.slice.call(arguments), r = a.apply(this, e);
                                    return i.each(t._chartjs.listeners, function(t) {
                                        "function" == typeof t[n] && t[n].apply(t, e);
                                    }), r;
                                }
                            });
                        }));
                    }
                    function n(t, e) {
                        var n = t._chartjs;
                        if (n) {
                            var i = n.listeners, r = i.indexOf(e);
                            -1 !== r && i.splice(r, 1), i.length > 0 || (a.forEach(function(e) {
                                delete t[e];
                            }), delete t._chartjs);
                        }
                    }
                    var a = [
                        "push",
                        "pop",
                        "shift",
                        "splice",
                        "unshift"
                    ];
                    t.DatasetController = function(t, e) {
                        this.initialize(t, e);
                    }, i.extend(t.DatasetController.prototype, {
                        datasetElementType: null,
                        dataElementType: null,
                        initialize: function(t, e) {
                            var n = this;
                            n.chart = t, n.index = e, n.linkScales(), n.addElements();
                        },
                        updateIndex: function(t) {
                            this.index = t;
                        },
                        linkScales: function() {
                            var t = this, e = t.getMeta(), n = t.getDataset();
                            null === e.xAxisID && (e.xAxisID = n.xAxisID || t.chart.options.scales.xAxes[0].id), null === e.yAxisID && (e.yAxisID = n.yAxisID || t.chart.options.scales.yAxes[0].id);
                        },
                        getDataset: function() {
                            return this.chart.data.datasets[this.index];
                        },
                        getMeta: function() {
                            return this.chart.getDatasetMeta(this.index);
                        },
                        getScaleForId: function(t) {
                            return this.chart.scales[t];
                        },
                        reset: function() {
                            this.update(!0);
                        },
                        destroy: function() {
                            this._data && n(this._data, this);
                        },
                        createMetaDataset: function() {
                            var t = this, e = t.datasetElementType;
                            return e && new e({
                                _chart: t.chart,
                                _datasetIndex: t.index
                            });
                        },
                        createMetaData: function(t) {
                            var e = this, n = e.dataElementType;
                            return n && new n({
                                _chart: e.chart,
                                _datasetIndex: e.index,
                                _index: t
                            });
                        },
                        addElements: function() {
                            var t, e, n = this, i = n.getMeta(), a = n.getDataset().data || [], r = i.data;
                            for(t = 0, e = a.length; t < e; ++t)r[t] = r[t] || n.createMetaData(t);
                            i.dataset = i.dataset || n.createMetaDataset();
                        },
                        addElementAndReset: function(t) {
                            var e = this.createMetaData(t);
                            this.getMeta().data.splice(t, 0, e), this.updateElement(e, t, !0);
                        },
                        buildOrUpdateElements: function() {
                            var t = this, i = t.getDataset(), a = i.data || (i.data = []);
                            t._data !== a && (t._data && n(t._data, t), e(a, t), t._data = a), t.resyncElements();
                        },
                        update: i.noop,
                        transition: function(t) {
                            for(var e = this.getMeta(), n = e.data || [], i = n.length, a = 0; a < i; ++a)n[a].transition(t);
                            e.dataset && e.dataset.transition(t);
                        },
                        draw: function() {
                            var t = this.getMeta(), e = t.data || [], n = e.length, i = 0;
                            for(t.dataset && t.dataset.draw(); i < n; ++i)e[i].draw();
                        },
                        removeHoverStyle: function(t, e) {
                            var n = this.chart.data.datasets[t._datasetIndex], a = t._index, r = t.custom || {
                            }, o = i.valueAtIndexOrDefault, s = t._model;
                            s.backgroundColor = r.backgroundColor ? r.backgroundColor : o(n.backgroundColor, a, e.backgroundColor), s.borderColor = r.borderColor ? r.borderColor : o(n.borderColor, a, e.borderColor), s.borderWidth = r.borderWidth ? r.borderWidth : o(n.borderWidth, a, e.borderWidth);
                        },
                        setHoverStyle: function(t) {
                            var e = this.chart.data.datasets[t._datasetIndex], n = t._index, a = t.custom || {
                            }, r = i.valueAtIndexOrDefault, o = i.getHoverColor, s = t._model;
                            s.backgroundColor = a.hoverBackgroundColor ? a.hoverBackgroundColor : r(e.hoverBackgroundColor, n, o(s.backgroundColor)), s.borderColor = a.hoverBorderColor ? a.hoverBorderColor : r(e.hoverBorderColor, n, o(s.borderColor)), s.borderWidth = a.hoverBorderWidth ? a.hoverBorderWidth : r(e.hoverBorderWidth, n, s.borderWidth);
                        },
                        resyncElements: function() {
                            var t = this, e = t.getMeta(), n = t.getDataset().data, i = e.data.length, a = n.length;
                            a < i ? e.data.splice(a, i - a) : a > i && t.insertElements(i, a - i);
                        },
                        insertElements: function(t, e) {
                            for(var n = 0; n < e; ++n)this.addElementAndReset(t + n);
                        },
                        onDataPush: function() {
                            this.insertElements(this.getDataset().data.length - 1, arguments.length);
                        },
                        onDataPop: function() {
                            this.getMeta().data.pop();
                        },
                        onDataShift: function() {
                            this.getMeta().data.shift();
                        },
                        onDataSplice: function(t, e) {
                            this.getMeta().data.splice(t, e), this.insertElements(t, arguments.length - 2);
                        },
                        onDataUnshift: function() {
                            this.insertElements(0, arguments.length);
                        }
                    }), t.DatasetController.extend = i.inherits;
                };
            },
            {
                45: 45
            }
        ],
        25: [
            function(t, e, n) {
                "use strict";
                var i = t(45);
                e.exports = {
                    _set: function(t, e) {
                        return i.merge(this[t] || (this[t] = {
                        }), e);
                    }
                };
            },
            {
                45: 45
            }
        ],
        26: [
            function(t, e, n) {
                "use strict";
                function i(t, e, n, i) {
                    var r, o, s, l, u, d, c, h, f, g = Object.keys(n);
                    for(r = 0, o = g.length; r < o; ++r)if (s = g[r], d = n[s], e.hasOwnProperty(s) || (e[s] = d), (l = e[s]) !== d && "_" !== s[0]) {
                        if (t.hasOwnProperty(s) || (t[s] = l), u = t[s], (c = typeof d) === typeof u) {
                            if ("string" === c) {
                                if ((h = a(u)).valid && (f = a(d)).valid) {
                                    e[s] = f.mix(h, i).rgbString();
                                    continue;
                                }
                            } else if ("number" === c && isFinite(u) && isFinite(d)) {
                                e[s] = u + (d - u) * i;
                                continue;
                            }
                        }
                        e[s] = d;
                    }
                }
                var a = t(2), r = t(45), o = function(t) {
                    r.extend(this, t), this.initialize.apply(this, arguments);
                };
                r.extend(o.prototype, {
                    initialize: function() {
                        this.hidden = !1;
                    },
                    pivot: function() {
                        var t = this;
                        return t._view || (t._view = r.clone(t._model)), t._start = {
                        }, t;
                    },
                    transition: function(t) {
                        var e = this, n = e._model, a = e._start, r = e._view;
                        return n && 1 !== t ? (r || (r = e._view = {
                        }), a || (a = e._start = {
                        }), i(a, r, n, t), e) : (e._view = n, e._start = null, e);
                    },
                    tooltipPosition: function() {
                        return {
                            x: this._model.x,
                            y: this._model.y
                        };
                    },
                    hasValue: function() {
                        return r.isNumber(this._model.x) && r.isNumber(this._model.y);
                    }
                }), o.extend = r.inherits, e.exports = o;
            },
            {
                2: 2,
                45: 45
            }
        ],
        27: [
            function(t, e, n) {
                "use strict";
                var i = t(2), a = t(25), r = t(45);
                e.exports = function(t) {
                    function e(t, e, n) {
                        var i;
                        return "string" == typeof t ? (i = parseInt(t, 10), -1 !== t.indexOf("%") && (i = i / 100 * e.parentNode[n])) : i = t, i;
                    }
                    function n(t) {
                        return void 0 !== t && null !== t && "none" !== t;
                    }
                    function o(t, i, a) {
                        var r = document.defaultView, o = t.parentNode, s = r.getComputedStyle(t)[i], l = r.getComputedStyle(o)[i], u = n(s), d = n(l), c = Number.POSITIVE_INFINITY;
                        return u || d ? Math.min(u ? e(s, t, a) : c, d ? e(l, o, a) : c) : "none";
                    }
                    r.configMerge = function() {
                        return r.merge(r.clone(arguments[0]), [].slice.call(arguments, 1), {
                            merger: function(e, n, i, a) {
                                var o = n[e] || {
                                }, s = i[e];
                                "scales" === e ? n[e] = r.scaleMerge(o, s) : "scale" === e ? n[e] = r.merge(o, [
                                    t.scaleService.getScaleDefaults(s.type),
                                    s
                                ]) : r._merger(e, n, i, a);
                            }
                        });
                    }, r.scaleMerge = function() {
                        return r.merge(r.clone(arguments[0]), [].slice.call(arguments, 1), {
                            merger: function(e, n, i, a) {
                                if ("xAxes" === e || "yAxes" === e) {
                                    var o, s, l, u = i[e].length;
                                    for(n[e] || (n[e] = []), o = 0; o < u; ++o)l = i[e][o], s = r.valueOrDefault(l.type, "xAxes" === e ? "category" : "linear"), o >= n[e].length && n[e].push({
                                    }), !n[e][o].type || l.type && l.type !== n[e][o].type ? r.merge(n[e][o], [
                                        t.scaleService.getScaleDefaults(s),
                                        l
                                    ]) : r.merge(n[e][o], l);
                                } else r._merger(e, n, i, a);
                            }
                        });
                    }, r.where = function(t, e) {
                        if (r.isArray(t) && Array.prototype.filter) return t.filter(e);
                        var n = [];
                        return r.each(t, function(t) {
                            e(t) && n.push(t);
                        }), n;
                    }, r.findIndex = Array.prototype.findIndex ? function(t, e, n) {
                        return t.findIndex(e, n);
                    } : function(t, e, n) {
                        n = void 0 === n ? t : n;
                        for(var i = 0, a = t.length; i < a; ++i)if (e.call(n, t[i], i, t)) return i;
                        return -1;
                    }, r.findNextWhere = function(t, e, n) {
                        r.isNullOrUndef(n) && (n = -1);
                        for(var i = n + 1; i < t.length; i++){
                            var a = t[i];
                            if (e(a)) return a;
                        }
                    }, r.findPreviousWhere = function(t, e, n) {
                        r.isNullOrUndef(n) && (n = t.length);
                        for(var i = n - 1; i >= 0; i--){
                            var a = t[i];
                            if (e(a)) return a;
                        }
                    }, r.isNumber = function(t) {
                        return !isNaN(parseFloat(t)) && isFinite(t);
                    }, r.almostEquals = function(t, e, n) {
                        return Math.abs(t - e) < n;
                    }, r.almostWhole = function(t, e) {
                        var n = Math.round(t);
                        return n - e < t && n + e > t;
                    }, r.max = function(t) {
                        return t.reduce(function(t, e) {
                            return isNaN(e) ? t : Math.max(t, e);
                        }, Number.NEGATIVE_INFINITY);
                    }, r.min = function(t) {
                        return t.reduce(function(t, e) {
                            return isNaN(e) ? t : Math.min(t, e);
                        }, Number.POSITIVE_INFINITY);
                    }, r.sign = Math.sign ? function(t) {
                        return Math.sign(t);
                    } : function(t) {
                        return 0 == (t = +t) || isNaN(t) ? t : t > 0 ? 1 : -1;
                    }, r.log10 = Math.log10 ? function(t) {
                        return Math.log10(t);
                    } : function(t) {
                        return Math.log(t) / Math.LN10;
                    }, r.toRadians = function(t) {
                        return t * (Math.PI / 180);
                    }, r.toDegrees = function(t) {
                        return t * (180 / Math.PI);
                    }, r.getAngleFromPoint = function(t, e) {
                        var n = e.x - t.x, i = e.y - t.y, a = Math.sqrt(n * n + i * i), r = Math.atan2(i, n);
                        return r < -0.5 * Math.PI && (r += 2 * Math.PI), {
                            angle: r,
                            distance: a
                        };
                    }, r.distanceBetweenPoints = function(t, e) {
                        return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
                    }, r.aliasPixel = function(t) {
                        return t % 2 == 0 ? 0 : 0.5;
                    }, r.splineCurve = function(t, e, n, i) {
                        var a = t.skip ? e : t, r = e, o = n.skip ? e : n, s = Math.sqrt(Math.pow(r.x - a.x, 2) + Math.pow(r.y - a.y, 2)), l = Math.sqrt(Math.pow(o.x - r.x, 2) + Math.pow(o.y - r.y, 2)), u = s / (s + l), d = l / (s + l), c = i * (u = isNaN(u) ? 0 : u), h = i * (d = isNaN(d) ? 0 : d);
                        return {
                            previous: {
                                x: r.x - c * (o.x - a.x),
                                y: r.y - c * (o.y - a.y)
                            },
                            next: {
                                x: r.x + h * (o.x - a.x),
                                y: r.y + h * (o.y - a.y)
                            }
                        };
                    }, r.EPSILON = Number.EPSILON || 0.00000000000001, r.splineCurveMonotone = function(t) {
                        var e, n, i, a, o = (t || []).map(function(t) {
                            return {
                                model: t._model,
                                deltaK: 0,
                                mK: 0
                            };
                        }), s = o.length;
                        for(e = 0; e < s; ++e)if (!(i = o[e]).model.skip) {
                            if (n = e > 0 ? o[e - 1] : null, (a = e < s - 1 ? o[e + 1] : null) && !a.model.skip) {
                                var l = a.model.x - i.model.x;
                                i.deltaK = 0 !== l ? (a.model.y - i.model.y) / l : 0;
                            }
                            !n || n.model.skip ? i.mK = i.deltaK : !a || a.model.skip ? i.mK = n.deltaK : this.sign(n.deltaK) !== this.sign(i.deltaK) ? i.mK = 0 : i.mK = (n.deltaK + i.deltaK) / 2;
                        }
                        var u, d, c, h;
                        for(e = 0; e < s - 1; ++e)i = o[e], a = o[e + 1], i.model.skip || a.model.skip || (r.almostEquals(i.deltaK, 0, this.EPSILON) ? i.mK = a.mK = 0 : (u = i.mK / i.deltaK, d = a.mK / i.deltaK, (h = Math.pow(u, 2) + Math.pow(d, 2)) <= 9 || (c = 3 / Math.sqrt(h), i.mK = u * c * i.deltaK, a.mK = d * c * i.deltaK)));
                        var f;
                        for(e = 0; e < s; ++e)(i = o[e]).model.skip || (n = e > 0 ? o[e - 1] : null, a = e < s - 1 ? o[e + 1] : null, n && !n.model.skip && (f = (i.model.x - n.model.x) / 3, i.model.controlPointPreviousX = i.model.x - f, i.model.controlPointPreviousY = i.model.y - f * i.mK), a && !a.model.skip && (f = (a.model.x - i.model.x) / 3, i.model.controlPointNextX = i.model.x + f, i.model.controlPointNextY = i.model.y + f * i.mK));
                    }, r.nextItem = function(t, e, n) {
                        return n ? e >= t.length - 1 ? t[0] : t[e + 1] : e >= t.length - 1 ? t[t.length - 1] : t[e + 1];
                    }, r.previousItem = function(t, e, n) {
                        return n ? e <= 0 ? t[t.length - 1] : t[e - 1] : e <= 0 ? t[0] : t[e - 1];
                    }, r.niceNum = function(t, e) {
                        var n = Math.floor(r.log10(t)), i = t / Math.pow(10, n);
                        return (e ? i < 1.5 ? 1 : i < 3 ? 2 : i < 7 ? 5 : 10 : i <= 1 ? 1 : i <= 2 ? 2 : i <= 5 ? 5 : 10) * Math.pow(10, n);
                    }, r.requestAnimFrame = "undefined" == typeof window ? function(t) {
                        t();
                    } : window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t) {
                        return window.setTimeout(t, 1000 / 60);
                    }, r.getRelativePosition = function(t, e) {
                        var n, i, a = t.originalEvent || t, o = t.currentTarget || t.srcElement, s = o.getBoundingClientRect(), l = a.touches;
                        l && l.length > 0 ? (n = l[0].clientX, i = l[0].clientY) : (n = a.clientX, i = a.clientY);
                        var u = parseFloat(r.getStyle(o, "padding-left")), d = parseFloat(r.getStyle(o, "padding-top")), c = parseFloat(r.getStyle(o, "padding-right")), h = parseFloat(r.getStyle(o, "padding-bottom")), f = s.right - s.left - u - c, g = s.bottom - s.top - d - h;
                        return n = Math.round((n - s.left - u) / f * o.width / e.currentDevicePixelRatio), i = Math.round((i - s.top - d) / g * o.height / e.currentDevicePixelRatio), {
                            x: n,
                            y: i
                        };
                    }, r.getConstraintWidth = function(t) {
                        return o(t, "max-width", "clientWidth");
                    }, r.getConstraintHeight = function(t) {
                        return o(t, "max-height", "clientHeight");
                    }, r.getMaximumWidth = function(t) {
                        var e = t.parentNode;
                        if (!e) return t.clientWidth;
                        var n = parseInt(r.getStyle(e, "padding-left"), 10), i = parseInt(r.getStyle(e, "padding-right"), 10), a = e.clientWidth - n - i, o = r.getConstraintWidth(t);
                        return isNaN(o) ? a : Math.min(a, o);
                    }, r.getMaximumHeight = function(t) {
                        var e = t.parentNode;
                        if (!e) return t.clientHeight;
                        var n = parseInt(r.getStyle(e, "padding-top"), 10), i = parseInt(r.getStyle(e, "padding-bottom"), 10), a = e.clientHeight - n - i, o = r.getConstraintHeight(t);
                        return isNaN(o) ? a : Math.min(a, o);
                    }, r.getStyle = function(t, e) {
                        return t.currentStyle ? t.currentStyle[e] : document.defaultView.getComputedStyle(t, null).getPropertyValue(e);
                    }, r.retinaScale = function(t, e) {
                        var n = t.currentDevicePixelRatio = e || window.devicePixelRatio || 1;
                        if (1 !== n) {
                            var i = t.canvas, a = t.height, r = t.width;
                            i.height = a * n, i.width = r * n, t.ctx.scale(n, n), i.style.height = a + "px", i.style.width = r + "px";
                        }
                    }, r.fontString = function(t, e, n) {
                        return e + " " + t + "px " + n;
                    }, r.longestText = function(t, e, n, i) {
                        var a = (i = i || {
                        }).data = i.data || {
                        }, o = i.garbageCollect = i.garbageCollect || [];
                        i.font !== e && (a = i.data = {
                        }, o = i.garbageCollect = [], i.font = e), t.font = e;
                        var s = 0;
                        r.each(n, function(e) {
                            void 0 !== e && null !== e && !0 !== r.isArray(e) ? s = r.measureText(t, a, o, s, e) : r.isArray(e) && r.each(e, function(e) {
                                void 0 === e || null === e || r.isArray(e) || (s = r.measureText(t, a, o, s, e));
                            });
                        });
                        var l = o.length / 2;
                        if (l > n.length) {
                            for(var u = 0; u < l; u++)delete a[o[u]];
                            o.splice(0, l);
                        }
                        return s;
                    }, r.measureText = function(t, e, n, i, a) {
                        var r = e[a];
                        return r || (r = e[a] = t.measureText(a).width, n.push(a)), r > i && (i = r), i;
                    }, r.numberOfLabelLines = function(t) {
                        var e = 1;
                        return r.each(t, function(t) {
                            r.isArray(t) && t.length > e && (e = t.length);
                        }), e;
                    }, r.color = i ? function(t) {
                        return t instanceof CanvasGradient && (t = a.global.defaultColor), i(t);
                    } : function(t) {
                        return console.error("Color.js not found!"), t;
                    }, r.getHoverColor = function(t) {
                        return t instanceof CanvasPattern ? t : r.color(t).saturate(0.5).darken(0.1).rgbString();
                    };
                };
            },
            {
                2: 2,
                25: 25,
                45: 45
            }
        ],
        28: [
            function(t, e, n) {
                "use strict";
                function i(t, e) {
                    return t.native ? {
                        x: t.x,
                        y: t.y
                    } : u.getRelativePosition(t, e);
                }
                function a(t, e) {
                    var n, i, a, r, o;
                    for(i = 0, r = t.data.datasets.length; i < r; ++i)if (t.isDatasetVisible(i)) for(a = 0, o = (n = t.getDatasetMeta(i)).data.length; a < o; ++a){
                        var s = n.data[a];
                        s._view.skip || e(s);
                    }
                }
                function r(t, e) {
                    var n = [];
                    return a(t, function(t) {
                        t.inRange(e.x, e.y) && n.push(t);
                    }), n;
                }
                function o(t, e, n, i) {
                    var r = Number.POSITIVE_INFINITY, o = [];
                    return a(t, function(t) {
                        if (!n || t.inRange(e.x, e.y)) {
                            var a = t.getCenterPoint(), s = i(e, a);
                            s < r ? (o = [
                                t
                            ], r = s) : s === r && o.push(t);
                        }
                    }), o;
                }
                function s(t) {
                    var e = -1 !== t.indexOf("x"), n = -1 !== t.indexOf("y");
                    return function(t, i) {
                        var a = e ? Math.abs(t.x - i.x) : 0, r = n ? Math.abs(t.y - i.y) : 0;
                        return Math.sqrt(Math.pow(a, 2) + Math.pow(r, 2));
                    };
                }
                function l(t, e, n) {
                    var a = i(e, t);
                    n.axis = n.axis || "x";
                    var l = s(n.axis), u = n.intersect ? r(t, a) : o(t, a, !1, l), d = [];
                    return u.length ? (t.data.datasets.forEach(function(e, n) {
                        if (t.isDatasetVisible(n)) {
                            var i = t.getDatasetMeta(n).data[u[0]._index];
                            i && !i._view.skip && d.push(i);
                        }
                    }), d) : [];
                }
                var u = t(45);
                e.exports = {
                    modes: {
                        single: function(t, e) {
                            var n = i(e, t), r = [];
                            return a(t, function(t) {
                                if (t.inRange(n.x, n.y)) return r.push(t), r;
                            }), r.slice(0, 1);
                        },
                        label: l,
                        index: l,
                        dataset: function(t, e, n) {
                            var a = i(e, t);
                            n.axis = n.axis || "xy";
                            var l = s(n.axis), u = n.intersect ? r(t, a) : o(t, a, !1, l);
                            return u.length > 0 && (u = t.getDatasetMeta(u[0]._datasetIndex).data), u;
                        },
                        "x-axis": function(t, e) {
                            return l(t, e, {
                                intersect: !1
                            });
                        },
                        point: function(t, e) {
                            return r(t, i(e, t));
                        },
                        nearest: function(t, e, n) {
                            var a = i(e, t);
                            n.axis = n.axis || "xy";
                            var r = s(n.axis), l = o(t, a, n.intersect, r);
                            return l.length > 1 && l.sort(function(t, e) {
                                var n = t.getArea() - e.getArea();
                                return 0 === n && (n = t._datasetIndex - e._datasetIndex), n;
                            }), l.slice(0, 1);
                        },
                        x: function(t, e, n) {
                            var r = i(e, t), o = [], s = !1;
                            return a(t, function(t) {
                                t.inXRange(r.x) && o.push(t), t.inRange(r.x, r.y) && (s = !0);
                            }), n.intersect && !s && (o = []), o;
                        },
                        y: function(t, e, n) {
                            var r = i(e, t), o = [], s = !1;
                            return a(t, function(t) {
                                t.inYRange(r.y) && o.push(t), t.inRange(r.x, r.y) && (s = !0);
                            }), n.intersect && !s && (o = []), o;
                        }
                    }
                };
            },
            {
                45: 45
            }
        ],
        29: [
            function(t, e, n) {
                "use strict";
                t(25)._set("global", {
                    responsive: !0,
                    responsiveAnimationDuration: 0,
                    maintainAspectRatio: !0,
                    events: [
                        "mousemove",
                        "mouseout",
                        "click",
                        "touchstart",
                        "touchmove"
                    ],
                    hover: {
                        onHover: null,
                        mode: "nearest",
                        intersect: !0,
                        animationDuration: 400
                    },
                    onClick: null,
                    defaultColor: "rgba(0,0,0,0.1)",
                    defaultFontColor: "#666",
                    defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                    defaultFontSize: 12,
                    defaultFontStyle: "normal",
                    showLines: !0,
                    elements: {
                    },
                    layout: {
                        padding: {
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        }
                    }
                }), e.exports = function() {
                    var t = function(t, e) {
                        return this.construct(t, e), this;
                    };
                    return t.Chart = t, t;
                };
            },
            {
                25: 25
            }
        ],
        30: [
            function(t, e, n) {
                "use strict";
                var i = t(45);
                e.exports = function(t) {
                    function e(t, e) {
                        return i.where(t, function(t) {
                            return t.position === e;
                        });
                    }
                    function n(t, e) {
                        t.forEach(function(t, e) {
                            return t._tmpIndex_ = e, t;
                        }), t.sort(function(t, n) {
                            var i = e ? n : t, a = e ? t : n;
                            return i.weight === a.weight ? i._tmpIndex_ - a._tmpIndex_ : i.weight - a.weight;
                        }), t.forEach(function(t) {
                            delete t._tmpIndex_;
                        });
                    }
                    t.layoutService = {
                        defaults: {
                        },
                        addBox: function(t, e) {
                            t.boxes || (t.boxes = []), e.fullWidth = e.fullWidth || !1, e.position = e.position || "top", e.weight = e.weight || 0, t.boxes.push(e);
                        },
                        removeBox: function(t, e) {
                            var n = t.boxes ? t.boxes.indexOf(e) : -1;
                            -1 !== n && t.boxes.splice(n, 1);
                        },
                        configure: function(t, e, n) {
                            for(var i, a = [
                                "fullWidth",
                                "position",
                                "weight"
                            ], r = a.length, o = 0; o < r; ++o)i = a[o], n.hasOwnProperty(i) && (e[i] = n[i]);
                        },
                        update: function(t, a, r) {
                            function o(t) {
                                var e = i.findNextWhere(D, function(e) {
                                    return e.box === t;
                                });
                                if (e) if (t.isHorizontal()) {
                                    var n = {
                                        left: Math.max(I, C),
                                        right: Math.max(O, P),
                                        top: 0,
                                        bottom: 0
                                    };
                                    t.update(t.fullWidth ? b : M, x / 2, n);
                                } else t.update(e.minSize.width, S);
                            }
                            function s(t) {
                                t.isHorizontal() ? (t.left = t.fullWidth ? d : I, t.right = t.fullWidth ? a - c : I + M, t.top = B, t.bottom = B + t.height, B = t.bottom) : (t.left = z, t.right = z + t.width, t.top = F, t.bottom = F + S, z = t.right);
                            }
                            if (t) {
                                var l = t.options.layout || {
                                }, u = i.options.toPadding(l.padding), d = u.left, c = u.right, h = u.top, f = u.bottom, g = e(t.boxes, "left"), m = e(t.boxes, "right"), p = e(t.boxes, "top"), v = e(t.boxes, "bottom"), y = e(t.boxes, "chartArea");
                                n(g, !0), n(m, !1), n(p, !0), n(v, !1);
                                var b = a - d - c, x = r - h - f, _ = x / 2, k = (a - b / 2) / (g.length + m.length), w = (r - _) / (p.length + v.length), M = b, S = x, D = [];
                                i.each(g.concat(m, p, v), function(t) {
                                    var e, n = t.isHorizontal();
                                    n ? (e = t.update(t.fullWidth ? b : M, w), S -= e.height) : (e = t.update(k, _), M -= e.width), D.push({
                                        horizontal: n,
                                        minSize: e,
                                        box: t
                                    });
                                });
                                var C = 0, P = 0, T = 0, A = 0;
                                i.each(p.concat(v), function(t) {
                                    if (t.getPadding) {
                                        var e = t.getPadding();
                                        C = Math.max(C, e.left), P = Math.max(P, e.right);
                                    }
                                }), i.each(g.concat(m), function(t) {
                                    if (t.getPadding) {
                                        var e = t.getPadding();
                                        T = Math.max(T, e.top), A = Math.max(A, e.bottom);
                                    }
                                });
                                var I = d, O = c, F = h, R = f;
                                i.each(g.concat(m), o), i.each(g, function(t) {
                                    I += t.width;
                                }), i.each(m, function(t) {
                                    O += t.width;
                                }), i.each(p.concat(v), o), i.each(p, function(t) {
                                    F += t.height;
                                }), i.each(v, function(t) {
                                    R += t.height;
                                }), i.each(g.concat(m), function(t) {
                                    var e = i.findNextWhere(D, function(e) {
                                        return e.box === t;
                                    }), n = {
                                        left: 0,
                                        right: 0,
                                        top: F,
                                        bottom: R
                                    };
                                    e && t.update(e.minSize.width, S, n);
                                }), I = d, O = c, F = h, R = f, i.each(g, function(t) {
                                    I += t.width;
                                }), i.each(m, function(t) {
                                    O += t.width;
                                }), i.each(p, function(t) {
                                    F += t.height;
                                }), i.each(v, function(t) {
                                    R += t.height;
                                });
                                var L = Math.max(C - I, 0);
                                I += L, O += Math.max(P - O, 0);
                                var W = Math.max(T - F, 0);
                                F += W, R += Math.max(A - R, 0);
                                var Y = r - F - R, N = a - I - O;
                                N === M && Y === S || (i.each(g, function(t) {
                                    t.height = Y;
                                }), i.each(m, function(t) {
                                    t.height = Y;
                                }), i.each(p, function(t) {
                                    t.fullWidth || (t.width = N);
                                }), i.each(v, function(t) {
                                    t.fullWidth || (t.width = N);
                                }), S = Y, M = N);
                                var z = d + L, B = h + W;
                                i.each(g.concat(p), s), z += M, B += S, i.each(m, s), i.each(v, s), t.chartArea = {
                                    left: I,
                                    top: F,
                                    right: I + M,
                                    bottom: F + S
                                }, i.each(y, function(e) {
                                    e.left = t.chartArea.left, e.top = t.chartArea.top, e.right = t.chartArea.right, e.bottom = t.chartArea.bottom, e.update(M, S);
                                });
                            }
                        }
                    };
                };
            },
            {
                45: 45
            }
        ],
        31: [
            function(t, e, n) {
                "use strict";
                var i = t(25), a = t(26), r = t(45);
                i._set("global", {
                    plugins: {
                    }
                }), e.exports = function(t) {
                    t.plugins = {
                        _plugins: [],
                        _cacheId: 0,
                        register: function(t) {
                            var e = this._plugins;
                            [].concat(t).forEach(function(t) {
                                -1 === e.indexOf(t) && e.push(t);
                            }), this._cacheId++;
                        },
                        unregister: function(t) {
                            var e = this._plugins;
                            [].concat(t).forEach(function(t) {
                                var n = e.indexOf(t);
                                -1 !== n && e.splice(n, 1);
                            }), this._cacheId++;
                        },
                        clear: function() {
                            this._plugins = [], this._cacheId++;
                        },
                        count: function() {
                            return this._plugins.length;
                        },
                        getAll: function() {
                            return this._plugins;
                        },
                        notify: function(t, e, n) {
                            var i, a, r, o, s, l = this.descriptors(t), u = l.length;
                            for(i = 0; i < u; ++i)if (a = l[i], r = a.plugin, "function" == typeof (s = r[e]) && ((o = [
                                t
                            ].concat(n || [])).push(a.options), !1 === s.apply(r, o))) return !1;
                            return !0;
                        },
                        descriptors: function(t) {
                            var e = t._plugins || (t._plugins = {
                            });
                            if (e.id === this._cacheId) return e.descriptors;
                            var n = [], a = [], o = t && t.config || {
                            }, s = o.options && o.options.plugins || {
                            };
                            return this._plugins.concat(o.plugins || []).forEach(function(t) {
                                if (-1 === n.indexOf(t)) {
                                    var e = t.id, o = s[e];
                                    !1 !== o && (!0 === o && (o = r.clone(i.global.plugins[e])), n.push(t), a.push({
                                        plugin: t,
                                        options: o || {
                                        }
                                    }));
                                }
                            }), e.descriptors = a, e.id = this._cacheId, a;
                        }
                    }, t.pluginService = t.plugins, t.PluginBase = a.extend({
                    });
                };
            },
            {
                25: 25,
                26: 26,
                45: 45
            }
        ],
        32: [
            function(t, e, n) {
                "use strict";
                function i(t) {
                    var e, n, i = [];
                    for(e = 0, n = t.length; e < n; ++e)i.push(t[e].label);
                    return i;
                }
                function a(t, e, n) {
                    var i = t.getPixelForTick(e);
                    return n && (i -= 0 === e ? (t.getPixelForTick(1) - i) / 2 : (i - t.getPixelForTick(e - 1)) / 2), i;
                }
                var r = t(25), o = t(26), s = t(45), l = t(34);
                r._set("scale", {
                    display: !0,
                    position: "left",
                    offset: !1,
                    gridLines: {
                        display: !0,
                        color: "rgba(0, 0, 0, 0.1)",
                        lineWidth: 1,
                        drawBorder: !0,
                        drawOnChartArea: !0,
                        drawTicks: !0,
                        tickMarkLength: 10,
                        zeroLineWidth: 1,
                        zeroLineColor: "rgba(0,0,0,0.25)",
                        zeroLineBorderDash: [],
                        zeroLineBorderDashOffset: 0,
                        offsetGridLines: !1,
                        borderDash: [],
                        borderDashOffset: 0
                    },
                    scaleLabel: {
                        display: !1,
                        labelString: "",
                        lineHeight: 1.2,
                        padding: {
                            top: 4,
                            bottom: 4
                        }
                    },
                    ticks: {
                        beginAtZero: !1,
                        minRotation: 0,
                        maxRotation: 50,
                        mirror: !1,
                        padding: 0,
                        reverse: !1,
                        display: !0,
                        autoSkip: !0,
                        autoSkipPadding: 0,
                        labelOffset: 0,
                        callback: l.formatters.values,
                        minor: {
                        },
                        major: {
                        }
                    }
                }), e.exports = function(t) {
                    function e(t, e, n) {
                        return s.isArray(e) ? s.longestText(t, n, e) : t.measureText(e).width;
                    }
                    function n(t) {
                        var e = s.valueOrDefault, n = r.global, i = e(t.fontSize, n.defaultFontSize), a = e(t.fontStyle, n.defaultFontStyle), o = e(t.fontFamily, n.defaultFontFamily);
                        return {
                            size: i,
                            style: a,
                            family: o,
                            font: s.fontString(i, a, o)
                        };
                    }
                    function l(t) {
                        return s.options.toLineHeight(s.valueOrDefault(t.lineHeight, 1.2), s.valueOrDefault(t.fontSize, r.global.defaultFontSize));
                    }
                    t.Scale = o.extend({
                        getPadding: function() {
                            var t = this;
                            return {
                                left: t.paddingLeft || 0,
                                top: t.paddingTop || 0,
                                right: t.paddingRight || 0,
                                bottom: t.paddingBottom || 0
                            };
                        },
                        getTicks: function() {
                            return this._ticks;
                        },
                        mergeTicksOptions: function() {
                            var t = this.options.ticks;
                            !1 === t.minor && (t.minor = {
                                display: !1
                            }), !1 === t.major && (t.major = {
                                display: !1
                            });
                            for(var e in t)"major" !== e && "minor" !== e && (void 0 === t.minor[e] && (t.minor[e] = t[e]), void 0 === t.major[e] && (t.major[e] = t[e]));
                        },
                        beforeUpdate: function() {
                            s.callback(this.options.beforeUpdate, [
                                this
                            ]);
                        },
                        update: function(t, e, n) {
                            var i, a, r, o, l, u, d = this;
                            for(d.beforeUpdate(), d.maxWidth = t, d.maxHeight = e, d.margins = s.extend({
                                left: 0,
                                right: 0,
                                top: 0,
                                bottom: 0
                            }, n), d.longestTextCache = d.longestTextCache || {
                            }, d.beforeSetDimensions(), d.setDimensions(), d.afterSetDimensions(), d.beforeDataLimits(), d.determineDataLimits(), d.afterDataLimits(), d.beforeBuildTicks(), l = d.buildTicks() || [], d.afterBuildTicks(), d.beforeTickToLabelConversion(), r = d.convertTicksToLabels(l) || d.ticks, d.afterTickToLabelConversion(), d.ticks = r, i = 0, a = r.length; i < a; ++i)o = r[i], (u = l[i]) ? u.label = o : l.push(u = {
                                label: o,
                                major: !1
                            });
                            return d._ticks = l, d.beforeCalculateTickRotation(), d.calculateTickRotation(), d.afterCalculateTickRotation(), d.beforeFit(), d.fit(), d.afterFit(), d.afterUpdate(), d.minSize;
                        },
                        afterUpdate: function() {
                            s.callback(this.options.afterUpdate, [
                                this
                            ]);
                        },
                        beforeSetDimensions: function() {
                            s.callback(this.options.beforeSetDimensions, [
                                this
                            ]);
                        },
                        setDimensions: function() {
                            var t = this;
                            t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0;
                        },
                        afterSetDimensions: function() {
                            s.callback(this.options.afterSetDimensions, [
                                this
                            ]);
                        },
                        beforeDataLimits: function() {
                            s.callback(this.options.beforeDataLimits, [
                                this
                            ]);
                        },
                        determineDataLimits: s.noop,
                        afterDataLimits: function() {
                            s.callback(this.options.afterDataLimits, [
                                this
                            ]);
                        },
                        beforeBuildTicks: function() {
                            s.callback(this.options.beforeBuildTicks, [
                                this
                            ]);
                        },
                        buildTicks: s.noop,
                        afterBuildTicks: function() {
                            s.callback(this.options.afterBuildTicks, [
                                this
                            ]);
                        },
                        beforeTickToLabelConversion: function() {
                            s.callback(this.options.beforeTickToLabelConversion, [
                                this
                            ]);
                        },
                        convertTicksToLabels: function() {
                            var t = this, e = t.options.ticks;
                            t.ticks = t.ticks.map(e.userCallback || e.callback, this);
                        },
                        afterTickToLabelConversion: function() {
                            s.callback(this.options.afterTickToLabelConversion, [
                                this
                            ]);
                        },
                        beforeCalculateTickRotation: function() {
                            s.callback(this.options.beforeCalculateTickRotation, [
                                this
                            ]);
                        },
                        calculateTickRotation: function() {
                            var t = this, e = t.ctx, a = t.options.ticks, r = i(t._ticks), o = n(a);
                            e.font = o.font;
                            var l = a.minRotation || 0;
                            if (r.length && t.options.display && t.isHorizontal()) for(var u, d = s.longestText(e, o.font, r, t.longestTextCache), c = d, h = t.getPixelForTick(1) - t.getPixelForTick(0) - 6; c > h && l < a.maxRotation;){
                                var f = s.toRadians(l);
                                if (u = Math.cos(f), Math.sin(f) * d > t.maxHeight) {
                                    l--;
                                    break;
                                }
                                l++, c = u * d;
                            }
                            t.labelRotation = l;
                        },
                        afterCalculateTickRotation: function() {
                            s.callback(this.options.afterCalculateTickRotation, [
                                this
                            ]);
                        },
                        beforeFit: function() {
                            s.callback(this.options.beforeFit, [
                                this
                            ]);
                        },
                        fit: function() {
                            var t = this, a = t.minSize = {
                                width: 0,
                                height: 0
                            }, r = i(t._ticks), o = t.options, u = o.ticks, d = o.scaleLabel, c = o.gridLines, h = o.display, f = t.isHorizontal(), g = n(u), m = o.gridLines.tickMarkLength;
                            if (a.width = f ? t.isFullWidth() ? t.maxWidth - t.margins.left - t.margins.right : t.maxWidth : h && c.drawTicks ? m : 0, a.height = f ? h && c.drawTicks ? m : 0 : t.maxHeight, d.display && h) {
                                var p = l(d) + s.options.toPadding(d.padding).height;
                                f ? a.height += p : a.width += p;
                            }
                            if (u.display && h) {
                                var v = s.longestText(t.ctx, g.font, r, t.longestTextCache), y = s.numberOfLabelLines(r), b = 0.5 * g.size, x = t.options.ticks.padding;
                                if (f) {
                                    t.longestLabelWidth = v;
                                    var _ = s.toRadians(t.labelRotation), k = Math.cos(_), w = Math.sin(_) * v + g.size * y + b * (y - 1) + b;
                                    a.height = Math.min(t.maxHeight, a.height + w + x), t.ctx.font = g.font;
                                    var M = e(t.ctx, r[0], g.font), S = e(t.ctx, r[r.length - 1], g.font);
                                    0 !== t.labelRotation ? (t.paddingLeft = "bottom" === o.position ? k * M + 3 : k * b + 3, t.paddingRight = "bottom" === o.position ? k * b + 3 : k * S + 3) : (t.paddingLeft = M / 2 + 3, t.paddingRight = S / 2 + 3);
                                } else u.mirror ? v = 0 : v += x + b, a.width = Math.min(t.maxWidth, a.width + v), t.paddingTop = g.size / 2, t.paddingBottom = g.size / 2;
                            }
                            t.handleMargins(), t.width = a.width, t.height = a.height;
                        },
                        handleMargins: function() {
                            var t = this;
                            t.margins && (t.paddingLeft = Math.max(t.paddingLeft - t.margins.left, 0), t.paddingTop = Math.max(t.paddingTop - t.margins.top, 0), t.paddingRight = Math.max(t.paddingRight - t.margins.right, 0), t.paddingBottom = Math.max(t.paddingBottom - t.margins.bottom, 0));
                        },
                        afterFit: function() {
                            s.callback(this.options.afterFit, [
                                this
                            ]);
                        },
                        isHorizontal: function() {
                            return "top" === this.options.position || "bottom" === this.options.position;
                        },
                        isFullWidth: function() {
                            return this.options.fullWidth;
                        },
                        getRightValue: function(t) {
                            if (s.isNullOrUndef(t)) return NaN;
                            if ("number" == typeof t && !isFinite(t)) return NaN;
                            if (t) {
                                if (this.isHorizontal()) {
                                    if (void 0 !== t.x) return this.getRightValue(t.x);
                                } else if (void 0 !== t.y) return this.getRightValue(t.y);
                            }
                            return t;
                        },
                        getLabelForIndex: s.noop,
                        getPixelForValue: s.noop,
                        getValueForPixel: s.noop,
                        getPixelForTick: function(t) {
                            var e = this, n = e.options.offset;
                            if (e.isHorizontal()) {
                                var i = (e.width - (e.paddingLeft + e.paddingRight)) / Math.max(e._ticks.length - (n ? 0 : 1), 1), a = i * t + e.paddingLeft;
                                n && (a += i / 2);
                                var r = e.left + Math.round(a);
                                return r += e.isFullWidth() ? e.margins.left : 0;
                            }
                            var o = e.height - (e.paddingTop + e.paddingBottom);
                            return e.top + t * (o / (e._ticks.length - 1));
                        },
                        getPixelForDecimal: function(t) {
                            var e = this;
                            if (e.isHorizontal()) {
                                var n = (e.width - (e.paddingLeft + e.paddingRight)) * t + e.paddingLeft, i = e.left + Math.round(n);
                                return i += e.isFullWidth() ? e.margins.left : 0;
                            }
                            return e.top + t * e.height;
                        },
                        getBasePixel: function() {
                            return this.getPixelForValue(this.getBaseValue());
                        },
                        getBaseValue: function() {
                            var t = this, e = t.min, n = t.max;
                            return t.beginAtZero ? 0 : e < 0 && n < 0 ? n : e > 0 && n > 0 ? e : 0;
                        },
                        _autoSkip: function(t) {
                            var e, n, i, a, r = this, o = r.isHorizontal(), l = r.options.ticks.minor, u = t.length, d = s.toRadians(r.labelRotation), c = Math.cos(d), h = r.longestLabelWidth * c, f = [];
                            for(l.maxTicksLimit && (a = l.maxTicksLimit), o && (e = !1, (h + l.autoSkipPadding) * u > r.width - (r.paddingLeft + r.paddingRight) && (e = 1 + Math.floor((h + l.autoSkipPadding) * u / (r.width - (r.paddingLeft + r.paddingRight)))), a && u > a && (e = Math.max(e, Math.floor(u / a)))), n = 0; n < u; n++)i = t[n], (e > 1 && n % e > 0 || n % e == 0 && n + e >= u) && n !== u - 1 && delete i.label, f.push(i);
                            return f;
                        },
                        draw: function(t) {
                            var e = this, i = e.options;
                            if (i.display) {
                                var o = e.ctx, u = r.global, d = i.ticks.minor, c = i.ticks.major || d, h = i.gridLines, f = i.scaleLabel, g = 0 !== e.labelRotation, m = e.isHorizontal(), p = d.autoSkip ? e._autoSkip(e.getTicks()) : e.getTicks(), v = s.valueOrDefault(d.fontColor, u.defaultFontColor), y = n(d), b = s.valueOrDefault(c.fontColor, u.defaultFontColor), x = n(c), _ = h.drawTicks ? h.tickMarkLength : 0, k = s.valueOrDefault(f.fontColor, u.defaultFontColor), w = n(f), M = s.options.toPadding(f.padding), S = s.toRadians(e.labelRotation), D = [], C = "right" === i.position ? e.left : e.right - _, P = "right" === i.position ? e.left + _ : e.right, T = "bottom" === i.position ? e.top : e.bottom - _, A = "bottom" === i.position ? e.top + _ : e.bottom;
                                if (s.each(p, function(n, r) {
                                    if (!s.isNullOrUndef(n.label)) {
                                        var o, l, c, f, v = n.label;
                                        r === e.zeroLineIndex && i.offset === h.offsetGridLines ? (o = h.zeroLineWidth, l = h.zeroLineColor, c = h.zeroLineBorderDash, f = h.zeroLineBorderDashOffset) : (o = s.valueAtIndexOrDefault(h.lineWidth, r), l = s.valueAtIndexOrDefault(h.color, r), c = s.valueOrDefault(h.borderDash, u.borderDash), f = s.valueOrDefault(h.borderDashOffset, u.borderDashOffset));
                                        var y, b, x, k, w, M, I, O, F, R, L = "middle", W = "middle", Y = d.padding;
                                        if (m) {
                                            var N = _ + Y;
                                            "bottom" === i.position ? (W = g ? "middle" : "top", L = g ? "right" : "center", R = e.top + N) : (W = g ? "middle" : "bottom", L = g ? "left" : "center", R = e.bottom - N);
                                            var z = a(e, r, h.offsetGridLines && p.length > 1);
                                            z < e.left && (l = "rgba(0,0,0,0)"), z += s.aliasPixel(o), F = e.getPixelForTick(r) + d.labelOffset, y = x = w = I = z, b = T, k = A, M = t.top, O = t.bottom;
                                        } else {
                                            var B, V = "left" === i.position;
                                            d.mirror ? (L = V ? "left" : "right", B = Y) : (L = V ? "right" : "left", B = _ + Y), F = V ? e.right - B : e.left + B;
                                            var H = a(e, r, h.offsetGridLines && p.length > 1);
                                            H < e.top && (l = "rgba(0,0,0,0)"), H += s.aliasPixel(o), R = e.getPixelForTick(r) + d.labelOffset, y = C, x = P, w = t.left, I = t.right, b = k = M = O = H;
                                        }
                                        D.push({
                                            tx1: y,
                                            ty1: b,
                                            tx2: x,
                                            ty2: k,
                                            x1: w,
                                            y1: M,
                                            x2: I,
                                            y2: O,
                                            labelX: F,
                                            labelY: R,
                                            glWidth: o,
                                            glColor: l,
                                            glBorderDash: c,
                                            glBorderDashOffset: f,
                                            rotation: -1 * S,
                                            label: v,
                                            major: n.major,
                                            textBaseline: W,
                                            textAlign: L
                                        });
                                    }
                                }), s.each(D, function(t) {
                                    if (h.display && (o.save(), o.lineWidth = t.glWidth, o.strokeStyle = t.glColor, o.setLineDash && (o.setLineDash(t.glBorderDash), o.lineDashOffset = t.glBorderDashOffset), o.beginPath(), h.drawTicks && (o.moveTo(t.tx1, t.ty1), o.lineTo(t.tx2, t.ty2)), h.drawOnChartArea && (o.moveTo(t.x1, t.y1), o.lineTo(t.x2, t.y2)), o.stroke(), o.restore()), d.display) {
                                        o.save(), o.translate(t.labelX, t.labelY), o.rotate(t.rotation), o.font = t.major ? x.font : y.font, o.fillStyle = t.major ? b : v, o.textBaseline = t.textBaseline, o.textAlign = t.textAlign;
                                        var e = t.label;
                                        if (s.isArray(e)) for(var n = 0, i = 0; n < e.length; ++n)o.fillText("" + e[n], 0, i), i += 1.5 * y.size;
                                        else o.fillText(e, 0, 0);
                                        o.restore();
                                    }
                                }), f.display) {
                                    var I, O, F = 0, R = l(f) / 2;
                                    if (m) I = e.left + (e.right - e.left) / 2, O = "bottom" === i.position ? e.bottom - R - M.bottom : e.top + R + M.top;
                                    else {
                                        var L = "left" === i.position;
                                        I = L ? e.left + R + M.top : e.right - R - M.top, O = e.top + (e.bottom - e.top) / 2, F = L ? -0.5 * Math.PI : 0.5 * Math.PI;
                                    }
                                    o.save(), o.translate(I, O), o.rotate(F), o.textAlign = "center", o.textBaseline = "middle", o.fillStyle = k, o.font = w.font, o.fillText(f.labelString, 0, 0), o.restore();
                                }
                                if (h.drawBorder) {
                                    o.lineWidth = s.valueAtIndexOrDefault(h.lineWidth, 0), o.strokeStyle = s.valueAtIndexOrDefault(h.color, 0);
                                    var W = e.left, Y = e.right, N = e.top, z = e.bottom, B = s.aliasPixel(o.lineWidth);
                                    m ? (N = z = "top" === i.position ? e.bottom : e.top, N += B, z += B) : (W = Y = "left" === i.position ? e.right : e.left, W += B, Y += B), o.beginPath(), o.moveTo(W, N), o.lineTo(Y, z), o.stroke();
                                }
                            }
                        }
                    });
                };
            },
            {
                25: 25,
                26: 26,
                34: 34,
                45: 45
            }
        ],
        33: [
            function(t, e, n) {
                "use strict";
                var i = t(25), a = t(45);
                e.exports = function(t) {
                    t.scaleService = {
                        constructors: {
                        },
                        defaults: {
                        },
                        registerScaleType: function(t, e, n) {
                            this.constructors[t] = e, this.defaults[t] = a.clone(n);
                        },
                        getScaleConstructor: function(t) {
                            return this.constructors.hasOwnProperty(t) ? this.constructors[t] : void 0;
                        },
                        getScaleDefaults: function(t) {
                            return this.defaults.hasOwnProperty(t) ? a.merge({
                            }, [
                                i.scale,
                                this.defaults[t]
                            ]) : {
                            };
                        },
                        updateScaleDefaults: function(t, e) {
                            var n = this;
                            n.defaults.hasOwnProperty(t) && (n.defaults[t] = a.extend(n.defaults[t], e));
                        },
                        addScalesToLayout: function(e) {
                            a.each(e.scales, function(n) {
                                n.fullWidth = n.options.fullWidth, n.position = n.options.position, n.weight = n.options.weight, t.layoutService.addBox(e, n);
                            });
                        }
                    };
                };
            },
            {
                25: 25,
                45: 45
            }
        ],
        34: [
            function(t, e, n) {
                "use strict";
                var i = t(45);
                e.exports = {
                    generators: {
                        linear: function(t, e) {
                            var n, a = [];
                            if (t.stepSize && t.stepSize > 0) n = t.stepSize;
                            else {
                                var r = i.niceNum(e.max - e.min, !1);
                                n = i.niceNum(r / (t.maxTicks - 1), !0);
                            }
                            var o = Math.floor(e.min / n) * n, s = Math.ceil(e.max / n) * n;
                            t.min && t.max && t.stepSize && i.almostWhole((t.max - t.min) / t.stepSize, n / 1000) && (o = t.min, s = t.max);
                            var l = (s - o) / n;
                            l = i.almostEquals(l, Math.round(l), n / 1000) ? Math.round(l) : Math.ceil(l), a.push(void 0 !== t.min ? t.min : o);
                            for(var u = 1; u < l; ++u)a.push(o + u * n);
                            return a.push(void 0 !== t.max ? t.max : s), a;
                        },
                        logarithmic: function(t, e) {
                            var n, a, r = [], o = i.valueOrDefault, s = o(t.min, Math.pow(10, Math.floor(i.log10(e.min)))), l = Math.floor(i.log10(e.max)), u = Math.ceil(e.max / Math.pow(10, l));
                            0 === s ? (n = Math.floor(i.log10(e.minNotZero)), a = Math.floor(e.minNotZero / Math.pow(10, n)), r.push(s), s = a * Math.pow(10, n)) : (n = Math.floor(i.log10(s)), a = Math.floor(s / Math.pow(10, n)));
                            do {
                                r.push(s), 10 === ++a && (a = 1, ++n), s = a * Math.pow(10, n);
                            }while (n < l || n === l && a < u)
                            var d = o(t.max, s);
                            return r.push(d), r;
                        }
                    },
                    formatters: {
                        values: function(t) {
                            return i.isArray(t) ? t : "" + t;
                        },
                        linear: function(t, e, n) {
                            var a = n.length > 3 ? n[2] - n[1] : n[1] - n[0];
                            Math.abs(a) > 1 && t !== Math.floor(t) && (a = t - Math.floor(t));
                            var r = i.log10(Math.abs(a)), o = "";
                            if (0 !== t) {
                                var s = -1 * Math.floor(r);
                                s = Math.max(Math.min(s, 20), 0), o = t.toFixed(s);
                            } else o = "0";
                            return o;
                        },
                        logarithmic: function(t, e, n) {
                            var a = t / Math.pow(10, Math.floor(i.log10(t)));
                            return 0 === t ? "0" : 1 === a || 2 === a || 5 === a || 0 === e || e === n.length - 1 ? t.toExponential() : "";
                        }
                    }
                };
            },
            {
                45: 45
            }
        ],
        35: [
            function(t, e, n) {
                "use strict";
                var i = t(25), a = t(26), r = t(45);
                i._set("global", {
                    tooltips: {
                        enabled: !0,
                        custom: null,
                        mode: "nearest",
                        position: "average",
                        intersect: !0,
                        backgroundColor: "rgba(0,0,0,0.8)",
                        titleFontStyle: "bold",
                        titleSpacing: 2,
                        titleMarginBottom: 6,
                        titleFontColor: "#fff",
                        titleAlign: "left",
                        bodySpacing: 2,
                        bodyFontColor: "#fff",
                        bodyAlign: "left",
                        footerFontStyle: "bold",
                        footerSpacing: 2,
                        footerMarginTop: 6,
                        footerFontColor: "#fff",
                        footerAlign: "left",
                        yPadding: 6,
                        xPadding: 6,
                        caretPadding: 2,
                        caretSize: 5,
                        cornerRadius: 6,
                        multiKeyBackground: "#fff",
                        displayColors: !0,
                        borderColor: "rgba(0,0,0,0)",
                        borderWidth: 0,
                        callbacks: {
                            beforeTitle: r.noop,
                            title: function(t, e) {
                                var n = "", i = e.labels, a = i ? i.length : 0;
                                if (t.length > 0) {
                                    var r = t[0];
                                    r.xLabel ? n = r.xLabel : a > 0 && r.index < a && (n = i[r.index]);
                                }
                                return n;
                            },
                            afterTitle: r.noop,
                            beforeBody: r.noop,
                            beforeLabel: r.noop,
                            label: function(t, e) {
                                var n = e.datasets[t.datasetIndex].label || "";
                                return n && (n += ": "), n += t.yLabel;
                            },
                            labelColor: function(t, e) {
                                var n = e.getDatasetMeta(t.datasetIndex).data[t.index]._view;
                                return {
                                    borderColor: n.borderColor,
                                    backgroundColor: n.backgroundColor
                                };
                            },
                            labelTextColor: function() {
                                return this._options.bodyFontColor;
                            },
                            afterLabel: r.noop,
                            afterBody: r.noop,
                            beforeFooter: r.noop,
                            footer: r.noop,
                            afterFooter: r.noop
                        }
                    }
                }), e.exports = function(t) {
                    function e(t, e) {
                        var n = r.color(t);
                        return n.alpha(e * n.alpha()).rgbaString();
                    }
                    function n(t, e) {
                        return e && (r.isArray(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t;
                    }
                    function o(t) {
                        var e = t._xScale, n = t._yScale || t._scale, i = t._index, a = t._datasetIndex;
                        return {
                            xLabel: e ? e.getLabelForIndex(i, a) : "",
                            yLabel: n ? n.getLabelForIndex(i, a) : "",
                            index: i,
                            datasetIndex: a,
                            x: t._model.x,
                            y: t._model.y
                        };
                    }
                    function s(t) {
                        var e = i.global, n = r.valueOrDefault;
                        return {
                            xPadding: t.xPadding,
                            yPadding: t.yPadding,
                            xAlign: t.xAlign,
                            yAlign: t.yAlign,
                            bodyFontColor: t.bodyFontColor,
                            _bodyFontFamily: n(t.bodyFontFamily, e.defaultFontFamily),
                            _bodyFontStyle: n(t.bodyFontStyle, e.defaultFontStyle),
                            _bodyAlign: t.bodyAlign,
                            bodyFontSize: n(t.bodyFontSize, e.defaultFontSize),
                            bodySpacing: t.bodySpacing,
                            titleFontColor: t.titleFontColor,
                            _titleFontFamily: n(t.titleFontFamily, e.defaultFontFamily),
                            _titleFontStyle: n(t.titleFontStyle, e.defaultFontStyle),
                            titleFontSize: n(t.titleFontSize, e.defaultFontSize),
                            _titleAlign: t.titleAlign,
                            titleSpacing: t.titleSpacing,
                            titleMarginBottom: t.titleMarginBottom,
                            footerFontColor: t.footerFontColor,
                            _footerFontFamily: n(t.footerFontFamily, e.defaultFontFamily),
                            _footerFontStyle: n(t.footerFontStyle, e.defaultFontStyle),
                            footerFontSize: n(t.footerFontSize, e.defaultFontSize),
                            _footerAlign: t.footerAlign,
                            footerSpacing: t.footerSpacing,
                            footerMarginTop: t.footerMarginTop,
                            caretSize: t.caretSize,
                            cornerRadius: t.cornerRadius,
                            backgroundColor: t.backgroundColor,
                            opacity: 0,
                            legendColorBackground: t.multiKeyBackground,
                            displayColors: t.displayColors,
                            borderColor: t.borderColor,
                            borderWidth: t.borderWidth
                        };
                    }
                    function l(t, e) {
                        var n = t._chart.ctx, i = 2 * e.yPadding, a = 0, o = e.body, s = o.reduce(function(t, e) {
                            return t + e.before.length + e.lines.length + e.after.length;
                        }, 0);
                        s += e.beforeBody.length + e.afterBody.length;
                        var l = e.title.length, u = e.footer.length, d = e.titleFontSize, c = e.bodyFontSize, h = e.footerFontSize;
                        i += l * d, i += l ? (l - 1) * e.titleSpacing : 0, i += l ? e.titleMarginBottom : 0, i += s * c, i += s ? (s - 1) * e.bodySpacing : 0, i += u ? e.footerMarginTop : 0, i += u * h, i += u ? (u - 1) * e.footerSpacing : 0;
                        var f = 0, g = function(t) {
                            a = Math.max(a, n.measureText(t).width + f);
                        };
                        return n.font = r.fontString(d, e._titleFontStyle, e._titleFontFamily), r.each(e.title, g), n.font = r.fontString(c, e._bodyFontStyle, e._bodyFontFamily), r.each(e.beforeBody.concat(e.afterBody), g), f = e.displayColors ? c + 2 : 0, r.each(o, function(t) {
                            r.each(t.before, g), r.each(t.lines, g), r.each(t.after, g);
                        }), f = 0, n.font = r.fontString(h, e._footerFontStyle, e._footerFontFamily), r.each(e.footer, g), a += 2 * e.xPadding, {
                            width: a,
                            height: i
                        };
                    }
                    function u(t, e) {
                        var n = t._model, i = t._chart, a = t._chart.chartArea, r = "center", o = "center";
                        n.y < e.height ? o = "top" : n.y > i.height - e.height && (o = "bottom");
                        var s, l, u, d, c, h = (a.left + a.right) / 2, f = (a.top + a.bottom) / 2;
                        "center" === o ? (s = function(t) {
                            return t <= h;
                        }, l = function(t) {
                            return t > h;
                        }) : (s = function(t) {
                            return t <= e.width / 2;
                        }, l = function(t) {
                            return t >= i.width - e.width / 2;
                        }), u = function(t) {
                            return t + e.width > i.width;
                        }, d = function(t) {
                            return t - e.width < 0;
                        }, c = function(t) {
                            return t <= f ? "top" : "bottom";
                        }, s(n.x) ? (r = "left", u(n.x) && (r = "center", o = c(n.y))) : l(n.x) && (r = "right", d(n.x) && (r = "center", o = c(n.y)));
                        var g = t._options;
                        return {
                            xAlign: g.xAlign ? g.xAlign : r,
                            yAlign: g.yAlign ? g.yAlign : o
                        };
                    }
                    function d(t, e, n) {
                        var i = t.x, a = t.y, r = t.caretSize, o = t.caretPadding, s = t.cornerRadius, l = n.xAlign, u = n.yAlign, d = r + o, c = s + o;
                        return "right" === l ? i -= e.width : "center" === l && (i -= e.width / 2), "top" === u ? a += d : a -= "bottom" === u ? e.height + d : e.height / 2, "center" === u ? "left" === l ? i += d : "right" === l && (i -= d) : "left" === l ? i -= c : "right" === l && (i += c), {
                            x: i,
                            y: a
                        };
                    }
                    t.Tooltip = a.extend({
                        initialize: function() {
                            this._model = s(this._options), this._lastActive = [];
                        },
                        getTitle: function() {
                            var t = this, e = t._options.callbacks, i = e.beforeTitle.apply(t, arguments), a = e.title.apply(t, arguments), r = e.afterTitle.apply(t, arguments), o = [];
                            return o = n(o, i), o = n(o, a), o = n(o, r);
                        },
                        getBeforeBody: function() {
                            var t = this._options.callbacks.beforeBody.apply(this, arguments);
                            return r.isArray(t) ? t : void 0 !== t ? [
                                t
                            ] : [];
                        },
                        getBody: function(t, e) {
                            var i = this, a = i._options.callbacks, o = [];
                            return r.each(t, function(t) {
                                var r = {
                                    before: [],
                                    lines: [],
                                    after: []
                                };
                                n(r.before, a.beforeLabel.call(i, t, e)), n(r.lines, a.label.call(i, t, e)), n(r.after, a.afterLabel.call(i, t, e)), o.push(r);
                            }), o;
                        },
                        getAfterBody: function() {
                            var t = this._options.callbacks.afterBody.apply(this, arguments);
                            return r.isArray(t) ? t : void 0 !== t ? [
                                t
                            ] : [];
                        },
                        getFooter: function() {
                            var t = this, e = t._options.callbacks, i = e.beforeFooter.apply(t, arguments), a = e.footer.apply(t, arguments), r = e.afterFooter.apply(t, arguments), o = [];
                            return o = n(o, i), o = n(o, a), o = n(o, r);
                        },
                        update: function(e) {
                            var n, i, a = this, c = a._options, h = a._model, f = a._model = s(c), g = a._active, m = a._data, p = {
                                xAlign: h.xAlign,
                                yAlign: h.yAlign
                            }, v = {
                                x: h.x,
                                y: h.y
                            }, y = {
                                width: h.width,
                                height: h.height
                            }, b = {
                                x: h.caretX,
                                y: h.caretY
                            };
                            if (g.length) {
                                f.opacity = 1;
                                var x = [], _ = [];
                                b = t.Tooltip.positioners[c.position].call(a, g, a._eventPosition);
                                var k = [];
                                for(n = 0, i = g.length; n < i; ++n)k.push(o(g[n]));
                                c.filter && (k = k.filter(function(t) {
                                    return c.filter(t, m);
                                })), c.itemSort && (k = k.sort(function(t, e) {
                                    return c.itemSort(t, e, m);
                                })), r.each(k, function(t) {
                                    x.push(c.callbacks.labelColor.call(a, t, a._chart)), _.push(c.callbacks.labelTextColor.call(a, t, a._chart));
                                }), f.title = a.getTitle(k, m), f.beforeBody = a.getBeforeBody(k, m), f.body = a.getBody(k, m), f.afterBody = a.getAfterBody(k, m), f.footer = a.getFooter(k, m), f.x = Math.round(b.x), f.y = Math.round(b.y), f.caretPadding = c.caretPadding, f.labelColors = x, f.labelTextColors = _, f.dataPoints = k, v = d(f, y = l(this, f), p = u(this, y));
                            } else f.opacity = 0;
                            return f.xAlign = p.xAlign, f.yAlign = p.yAlign, f.x = v.x, f.y = v.y, f.width = y.width, f.height = y.height, f.caretX = b.x, f.caretY = b.y, a._model = f, e && c.custom && c.custom.call(a, f), a;
                        },
                        drawCaret: function(t, e) {
                            var n = this._chart.ctx, i = this._view, a = this.getCaretPosition(t, e, i);
                            n.lineTo(a.x1, a.y1), n.lineTo(a.x2, a.y2), n.lineTo(a.x3, a.y3);
                        },
                        getCaretPosition: function(t, e, n) {
                            var i, a, r, o, s, l, u = n.caretSize, d = n.cornerRadius, c = n.xAlign, h = n.yAlign, f = t.x, g = t.y, m = e.width, p = e.height;
                            if ("center" === h) s = g + p / 2, "left" === c ? (a = (i = f) - u, r = i, o = s + u, l = s - u) : (a = (i = f + m) + u, r = i, o = s - u, l = s + u);
                            else if ("left" === c ? (i = (a = f + d + u) - u, r = a + u) : "right" === c ? (i = (a = f + m - d - u) - u, r = a + u) : (i = (a = f + m / 2) - u, r = a + u), "top" === h) s = (o = g) - u, l = o;
                            else {
                                s = (o = g + p) + u, l = o;
                                var v = r;
                                r = i, i = v;
                            }
                            return {
                                x1: i,
                                x2: a,
                                x3: r,
                                y1: o,
                                y2: s,
                                y3: l
                            };
                        },
                        drawTitle: function(t, n, i, a) {
                            var o = n.title;
                            if (o.length) {
                                i.textAlign = n._titleAlign, i.textBaseline = "top";
                                var s = n.titleFontSize, l = n.titleSpacing;
                                i.fillStyle = e(n.titleFontColor, a), i.font = r.fontString(s, n._titleFontStyle, n._titleFontFamily);
                                var u, d;
                                for(u = 0, d = o.length; u < d; ++u)i.fillText(o[u], t.x, t.y), t.y += s + l, u + 1 === o.length && (t.y += n.titleMarginBottom - l);
                            }
                        },
                        drawBody: function(t, n, i, a) {
                            var o = n.bodyFontSize, s = n.bodySpacing, l = n.body;
                            i.textAlign = n._bodyAlign, i.textBaseline = "top", i.font = r.fontString(o, n._bodyFontStyle, n._bodyFontFamily);
                            var u = 0, d = function(e) {
                                i.fillText(e, t.x + u, t.y), t.y += o + s;
                            };
                            i.fillStyle = e(n.bodyFontColor, a), r.each(n.beforeBody, d);
                            var c = n.displayColors;
                            u = c ? o + 2 : 0, r.each(l, function(s, l) {
                                var u = e(n.labelTextColors[l], a);
                                i.fillStyle = u, r.each(s.before, d), r.each(s.lines, function(r) {
                                    c && (i.fillStyle = e(n.legendColorBackground, a), i.fillRect(t.x, t.y, o, o), i.lineWidth = 1, i.strokeStyle = e(n.labelColors[l].borderColor, a), i.strokeRect(t.x, t.y, o, o), i.fillStyle = e(n.labelColors[l].backgroundColor, a), i.fillRect(t.x + 1, t.y + 1, o - 2, o - 2), i.fillStyle = u), d(r);
                                }), r.each(s.after, d);
                            }), u = 0, r.each(n.afterBody, d), t.y -= s;
                        },
                        drawFooter: function(t, n, i, a) {
                            var o = n.footer;
                            o.length && (t.y += n.footerMarginTop, i.textAlign = n._footerAlign, i.textBaseline = "top", i.fillStyle = e(n.footerFontColor, a), i.font = r.fontString(n.footerFontSize, n._footerFontStyle, n._footerFontFamily), r.each(o, function(e) {
                                i.fillText(e, t.x, t.y), t.y += n.footerFontSize + n.footerSpacing;
                            }));
                        },
                        drawBackground: function(t, n, i, a, r) {
                            i.fillStyle = e(n.backgroundColor, r), i.strokeStyle = e(n.borderColor, r), i.lineWidth = n.borderWidth;
                            var o = n.xAlign, s = n.yAlign, l = t.x, u = t.y, d = a.width, c = a.height, h = n.cornerRadius;
                            i.beginPath(), i.moveTo(l + h, u), "top" === s && this.drawCaret(t, a), i.lineTo(l + d - h, u), i.quadraticCurveTo(l + d, u, l + d, u + h), "center" === s && "right" === o && this.drawCaret(t, a), i.lineTo(l + d, u + c - h), i.quadraticCurveTo(l + d, u + c, l + d - h, u + c), "bottom" === s && this.drawCaret(t, a), i.lineTo(l + h, u + c), i.quadraticCurveTo(l, u + c, l, u + c - h), "center" === s && "left" === o && this.drawCaret(t, a), i.lineTo(l, u + h), i.quadraticCurveTo(l, u, l + h, u), i.closePath(), i.fill(), n.borderWidth > 0 && i.stroke();
                        },
                        draw: function() {
                            var t = this._chart.ctx, e = this._view;
                            if (0 !== e.opacity) {
                                var n = {
                                    width: e.width,
                                    height: e.height
                                }, i = {
                                    x: e.x,
                                    y: e.y
                                }, a = Math.abs(e.opacity < 0.001) ? 0 : e.opacity, r = e.title.length || e.beforeBody.length || e.body.length || e.afterBody.length || e.footer.length;
                                this._options.enabled && r && (this.drawBackground(i, e, t, n, a), i.x += e.xPadding, i.y += e.yPadding, this.drawTitle(i, e, t, a), this.drawBody(i, e, t, a), this.drawFooter(i, e, t, a));
                            }
                        },
                        handleEvent: function(t) {
                            var e = this, n = e._options, i = !1;
                            if (e._lastActive = e._lastActive || [], "mouseout" === t.type ? e._active = [] : e._active = e._chart.getElementsAtEventForMode(t, n.mode, n), !(i = !r.arrayEquals(e._active, e._lastActive))) return !1;
                            if (e._lastActive = e._active, n.enabled || n.custom) {
                                e._eventPosition = {
                                    x: t.x,
                                    y: t.y
                                };
                                var a = e._model;
                                e.update(!0), e.pivot(), i |= a.x !== e._model.x || a.y !== e._model.y;
                            }
                            return i;
                        }
                    }), t.Tooltip.positioners = {
                        average: function(t) {
                            if (!t.length) return !1;
                            var e, n, i = 0, a = 0, r = 0;
                            for(e = 0, n = t.length; e < n; ++e){
                                var o = t[e];
                                if (o && o.hasValue()) {
                                    var s = o.tooltipPosition();
                                    i += s.x, a += s.y, ++r;
                                }
                            }
                            return {
                                x: Math.round(i / r),
                                y: Math.round(a / r)
                            };
                        },
                        nearest: function(t, e) {
                            var n, i, a, o = e.x, s = e.y, l = Number.POSITIVE_INFINITY;
                            for(n = 0, i = t.length; n < i; ++n){
                                var u = t[n];
                                if (u && u.hasValue()) {
                                    var d = u.getCenterPoint(), c = r.distanceBetweenPoints(e, d);
                                    c < l && (l = c, a = u);
                                }
                            }
                            if (a) {
                                var h = a.tooltipPosition();
                                o = h.x, s = h.y;
                            }
                            return {
                                x: o,
                                y: s
                            };
                        }
                    };
                };
            },
            {
                25: 25,
                26: 26,
                45: 45
            }
        ],
        36: [
            function(t, e, n) {
                "use strict";
                var i = t(25), a = t(26), r = t(45);
                i._set("global", {
                    elements: {
                        arc: {
                            backgroundColor: i.global.defaultColor,
                            borderColor: "#fff",
                            borderWidth: 2
                        }
                    }
                }), e.exports = a.extend({
                    inLabelRange: function(t) {
                        var e = this._view;
                        return !!e && Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hoverRadius, 2);
                    },
                    inRange: function(t, e) {
                        var n = this._view;
                        if (n) {
                            for(var i = r.getAngleFromPoint(n, {
                                x: t,
                                y: e
                            }), a = i.angle, o = i.distance, s = n.startAngle, l = n.endAngle; l < s;)l += 2 * Math.PI;
                            for(; a > l;)a -= 2 * Math.PI;
                            for(; a < s;)a += 2 * Math.PI;
                            var u = a >= s && a <= l, d = o >= n.innerRadius && o <= n.outerRadius;
                            return u && d;
                        }
                        return !1;
                    },
                    getCenterPoint: function() {
                        var t = this._view, e = (t.startAngle + t.endAngle) / 2, n = (t.innerRadius + t.outerRadius) / 2;
                        return {
                            x: t.x + Math.cos(e) * n,
                            y: t.y + Math.sin(e) * n
                        };
                    },
                    getArea: function() {
                        var t = this._view;
                        return Math.PI * ((t.endAngle - t.startAngle) / (2 * Math.PI)) * (Math.pow(t.outerRadius, 2) - Math.pow(t.innerRadius, 2));
                    },
                    tooltipPosition: function() {
                        var t = this._view, e = t.startAngle + (t.endAngle - t.startAngle) / 2, n = (t.outerRadius - t.innerRadius) / 2 + t.innerRadius;
                        return {
                            x: t.x + Math.cos(e) * n,
                            y: t.y + Math.sin(e) * n
                        };
                    },
                    draw: function() {
                        var t = this._chart.ctx, e = this._view, n = e.startAngle, i = e.endAngle;
                        t.beginPath(), t.arc(e.x, e.y, e.outerRadius, n, i), t.arc(e.x, e.y, e.innerRadius, i, n, !0), t.closePath(), t.strokeStyle = e.borderColor, t.lineWidth = e.borderWidth, t.fillStyle = e.backgroundColor, t.fill(), t.lineJoin = "bevel", e.borderWidth && t.stroke();
                    }
                });
            },
            {
                25: 25,
                26: 26,
                45: 45
            }
        ],
        37: [
            function(t, e, n) {
                "use strict";
                var i = t(25), a = t(26), r = t(45), o = i.global;
                i._set("global", {
                    elements: {
                        line: {
                            tension: 0.4,
                            backgroundColor: o.defaultColor,
                            borderWidth: 3,
                            borderColor: o.defaultColor,
                            borderCapStyle: "butt",
                            borderDash: [],
                            borderDashOffset: 0,
                            borderJoinStyle: "miter",
                            capBezierPoints: !0,
                            fill: !0
                        }
                    }
                }), e.exports = a.extend({
                    draw: function() {
                        var t, e, n, i, a = this, s = a._view, l = a._chart.ctx, u = s.spanGaps, d = a._children.slice(), c = o.elements.line, h = -1;
                        for(a._loop && d.length && d.push(d[0]), l.save(), l.lineCap = s.borderCapStyle || c.borderCapStyle, l.setLineDash && l.setLineDash(s.borderDash || c.borderDash), l.lineDashOffset = s.borderDashOffset || c.borderDashOffset, l.lineJoin = s.borderJoinStyle || c.borderJoinStyle, l.lineWidth = s.borderWidth || c.borderWidth, l.strokeStyle = s.borderColor || o.defaultColor, l.beginPath(), h = -1, t = 0; t < d.length; ++t)e = d[t], n = r.previousItem(d, t), i = e._view, 0 === t ? i.skip || (l.moveTo(i.x, i.y), h = t) : (n = -1 === h ? n : d[h], i.skip || (h !== t - 1 && !u || -1 === h ? l.moveTo(i.x, i.y) : r.canvas.lineTo(l, n._view, e._view), h = t));
                        l.stroke(), l.restore();
                    }
                });
            },
            {
                25: 25,
                26: 26,
                45: 45
            }
        ],
        38: [
            function(t, e, n) {
                "use strict";
                function i(t) {
                    var e = this._view;
                    return !!e && Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hitRadius, 2);
                }
                var a = t(25), r = t(26), o = t(45), s = a.global.defaultColor;
                a._set("global", {
                    elements: {
                        point: {
                            radius: 3,
                            pointStyle: "circle",
                            backgroundColor: s,
                            borderColor: s,
                            borderWidth: 1,
                            hitRadius: 1,
                            hoverRadius: 4,
                            hoverBorderWidth: 1
                        }
                    }
                }), e.exports = r.extend({
                    inRange: function(t, e) {
                        var n = this._view;
                        return !!n && Math.pow(t - n.x, 2) + Math.pow(e - n.y, 2) < Math.pow(n.hitRadius + n.radius, 2);
                    },
                    inLabelRange: i,
                    inXRange: i,
                    inYRange: function(t) {
                        var e = this._view;
                        return !!e && Math.pow(t - e.y, 2) < Math.pow(e.radius + e.hitRadius, 2);
                    },
                    getCenterPoint: function() {
                        var t = this._view;
                        return {
                            x: t.x,
                            y: t.y
                        };
                    },
                    getArea: function() {
                        return Math.PI * Math.pow(this._view.radius, 2);
                    },
                    tooltipPosition: function() {
                        var t = this._view;
                        return {
                            x: t.x,
                            y: t.y,
                            padding: t.radius + t.borderWidth
                        };
                    },
                    draw: function(t) {
                        var e = this._view, n = this._model, i = this._chart.ctx, r = e.pointStyle, l = e.radius, u = e.x, d = e.y, c = o.color, h = 0;
                        e.skip || (i.strokeStyle = e.borderColor || s, i.lineWidth = o.valueOrDefault(e.borderWidth, a.global.elements.point.borderWidth), i.fillStyle = e.backgroundColor || s, void 0 !== t && (n.x < t.left || 1.01 * t.right < n.x || n.y < t.top || 1.01 * t.bottom < n.y) && (n.x < t.left ? h = (u - n.x) / (t.left - n.x) : 1.01 * t.right < n.x ? h = (n.x - u) / (n.x - t.right) : n.y < t.top ? h = (d - n.y) / (t.top - n.y) : 1.01 * t.bottom < n.y && (h = (n.y - d) / (n.y - t.bottom)), h = Math.round(100 * h) / 100, i.strokeStyle = c(i.strokeStyle).alpha(h).rgbString(), i.fillStyle = c(i.fillStyle).alpha(h).rgbString()), o.canvas.drawPoint(i, r, l, u, d));
                    }
                });
            },
            {
                25: 25,
                26: 26,
                45: 45
            }
        ],
        39: [
            function(t, e, n) {
                "use strict";
                function i(t) {
                    return void 0 !== t._view.width;
                }
                function a(t) {
                    var e, n, a, r, o = t._view;
                    if (i(t)) {
                        var s = o.width / 2;
                        e = o.x - s, n = o.x + s, a = Math.min(o.y, o.base), r = Math.max(o.y, o.base);
                    } else {
                        var l = o.height / 2;
                        e = Math.min(o.x, o.base), n = Math.max(o.x, o.base), a = o.y - l, r = o.y + l;
                    }
                    return {
                        left: e,
                        top: a,
                        right: n,
                        bottom: r
                    };
                }
                var r = t(25), o = t(26);
                r._set("global", {
                    elements: {
                        rectangle: {
                            backgroundColor: r.global.defaultColor,
                            borderColor: r.global.defaultColor,
                            borderSkipped: "bottom",
                            borderWidth: 0
                        }
                    }
                }), e.exports = o.extend({
                    draw: function() {
                        function t(t) {
                            return v[(y + t) % 4];
                        }
                        var e, n, i, a, r, o, s, l = this._chart.ctx, u = this._view, d = u.borderWidth;
                        if (u.horizontal ? (e = u.base, n = u.x, i = u.y - u.height / 2, a = u.y + u.height / 2, r = n > e ? 1 : -1, o = 1, s = u.borderSkipped || "left") : (e = u.x - u.width / 2, n = u.x + u.width / 2, i = u.y, r = 1, o = (a = u.base) > i ? 1 : -1, s = u.borderSkipped || "bottom"), d) {
                            var c = Math.min(Math.abs(e - n), Math.abs(i - a)), h = (d = d > c ? c : d) / 2, f = e + ("left" !== s ? h * r : 0), g = n + ("right" !== s ? -h * r : 0), m = i + ("top" !== s ? h * o : 0), p = a + ("bottom" !== s ? -h * o : 0);
                            f !== g && (i = m, a = p), m !== p && (e = f, n = g);
                        }
                        l.beginPath(), l.fillStyle = u.backgroundColor, l.strokeStyle = u.borderColor, l.lineWidth = d;
                        var v = [
                            [
                                e,
                                a
                            ],
                            [
                                e,
                                i
                            ],
                            [
                                n,
                                i
                            ],
                            [
                                n,
                                a
                            ]
                        ], y = [
                            "bottom",
                            "left",
                            "top",
                            "right"
                        ].indexOf(s, 0);
                        -1 === y && (y = 0);
                        var b = t(0);
                        l.moveTo(b[0], b[1]);
                        for(var x = 1; x < 4; x++)b = t(x), l.lineTo(b[0], b[1]);
                        l.fill(), d && l.stroke();
                    },
                    height: function() {
                        var t = this._view;
                        return t.base - t.y;
                    },
                    inRange: function(t, e) {
                        var n = !1;
                        if (this._view) {
                            var i = a(this);
                            n = t >= i.left && t <= i.right && e >= i.top && e <= i.bottom;
                        }
                        return n;
                    },
                    inLabelRange: function(t, e) {
                        var n = this;
                        if (!n._view) return !1;
                        var r = a(n);
                        return i(n) ? t >= r.left && t <= r.right : e >= r.top && e <= r.bottom;
                    },
                    inXRange: function(t) {
                        var e = a(this);
                        return t >= e.left && t <= e.right;
                    },
                    inYRange: function(t) {
                        var e = a(this);
                        return t >= e.top && t <= e.bottom;
                    },
                    getCenterPoint: function() {
                        var t, e, n = this._view;
                        return i(this) ? (t = n.x, e = (n.y + n.base) / 2) : (t = (n.x + n.base) / 2, e = n.y), {
                            x: t,
                            y: e
                        };
                    },
                    getArea: function() {
                        var t = this._view;
                        return t.width * Math.abs(t.y - t.base);
                    },
                    tooltipPosition: function() {
                        var t = this._view;
                        return {
                            x: t.x,
                            y: t.y
                        };
                    }
                });
            },
            {
                25: 25,
                26: 26
            }
        ],
        40: [
            function(t, e, n) {
                "use strict";
                e.exports = {
                }, e.exports.Arc = t(36), e.exports.Line = t(37), e.exports.Point = t(38), e.exports.Rectangle = t(39);
            },
            {
                36: 36,
                37: 37,
                38: 38,
                39: 39
            }
        ],
        41: [
            function(t, e, n) {
                "use strict";
                var i = t(42), n = e.exports = {
                    clear: function(t) {
                        t.ctx.clearRect(0, 0, t.width, t.height);
                    },
                    roundedRect: function(t, e, n, i, a, r) {
                        if (r) {
                            var o = Math.min(r, i / 2), s = Math.min(r, a / 2);
                            t.moveTo(e + o, n), t.lineTo(e + i - o, n), t.quadraticCurveTo(e + i, n, e + i, n + s), t.lineTo(e + i, n + a - s), t.quadraticCurveTo(e + i, n + a, e + i - o, n + a), t.lineTo(e + o, n + a), t.quadraticCurveTo(e, n + a, e, n + a - s), t.lineTo(e, n + s), t.quadraticCurveTo(e, n, e + o, n);
                        } else t.rect(e, n, i, a);
                    },
                    drawPoint: function(t, e, n, i, a) {
                        var r, o, s, l, u, d;
                        if (!e || "object" != typeof e || "[object HTMLImageElement]" !== (r = e.toString()) && "[object HTMLCanvasElement]" !== r) {
                            if (!(isNaN(n) || n <= 0)) {
                                switch(e){
                                    default:
                                        t.beginPath(), t.arc(i, a, n, 0, 2 * Math.PI), t.closePath(), t.fill();
                                        break;
                                    case "triangle":
                                        t.beginPath(), u = (o = 3 * n / Math.sqrt(3)) * Math.sqrt(3) / 2, t.moveTo(i - o / 2, a + u / 3), t.lineTo(i + o / 2, a + u / 3), t.lineTo(i, a - 2 * u / 3), t.closePath(), t.fill();
                                        break;
                                    case "rect":
                                        d = 1 / Math.SQRT2 * n, t.beginPath(), t.fillRect(i - d, a - d, 2 * d, 2 * d), t.strokeRect(i - d, a - d, 2 * d, 2 * d);
                                        break;
                                    case "rectRounded":
                                        var c = n / Math.SQRT2, h = i - c, f = a - c, g = Math.SQRT2 * n;
                                        t.beginPath(), this.roundedRect(t, h, f, g, g, n / 2), t.closePath(), t.fill();
                                        break;
                                    case "rectRot":
                                        d = 1 / Math.SQRT2 * n, t.beginPath(), t.moveTo(i - d, a), t.lineTo(i, a + d), t.lineTo(i + d, a), t.lineTo(i, a - d), t.closePath(), t.fill();
                                        break;
                                    case "cross":
                                        t.beginPath(), t.moveTo(i, a + n), t.lineTo(i, a - n), t.moveTo(i - n, a), t.lineTo(i + n, a), t.closePath();
                                        break;
                                    case "crossRot":
                                        t.beginPath(), s = Math.cos(Math.PI / 4) * n, l = Math.sin(Math.PI / 4) * n, t.moveTo(i - s, a - l), t.lineTo(i + s, a + l), t.moveTo(i - s, a + l), t.lineTo(i + s, a - l), t.closePath();
                                        break;
                                    case "star":
                                        t.beginPath(), t.moveTo(i, a + n), t.lineTo(i, a - n), t.moveTo(i - n, a), t.lineTo(i + n, a), s = Math.cos(Math.PI / 4) * n, l = Math.sin(Math.PI / 4) * n, t.moveTo(i - s, a - l), t.lineTo(i + s, a + l), t.moveTo(i - s, a + l), t.lineTo(i + s, a - l), t.closePath();
                                        break;
                                    case "line":
                                        t.beginPath(), t.moveTo(i - n, a), t.lineTo(i + n, a), t.closePath();
                                        break;
                                    case "dash":
                                        t.beginPath(), t.moveTo(i, a), t.lineTo(i + n, a), t.closePath();
                                }
                                t.stroke();
                            }
                        } else t.drawImage(e, i - e.width / 2, a - e.height / 2, e.width, e.height);
                    },
                    clipArea: function(t, e) {
                        t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip();
                    },
                    unclipArea: function(t) {
                        t.restore();
                    },
                    lineTo: function(t, e, n, i) {
                        if (n.steppedLine) return "after" === n.steppedLine && !i || "after" !== n.steppedLine && i ? t.lineTo(e.x, n.y) : t.lineTo(n.x, e.y), void t.lineTo(n.x, n.y);
                        n.tension ? t.bezierCurveTo(i ? e.controlPointPreviousX : e.controlPointNextX, i ? e.controlPointPreviousY : e.controlPointNextY, i ? n.controlPointNextX : n.controlPointPreviousX, i ? n.controlPointNextY : n.controlPointPreviousY, n.x, n.y) : t.lineTo(n.x, n.y);
                    }
                };
                i.clear = n.clear, i.drawRoundedRectangle = function(t) {
                    t.beginPath(), n.roundedRect.apply(n, arguments), t.closePath();
                };
            },
            {
                42: 42
            }
        ],
        42: [
            function(t, e, n) {
                "use strict";
                var i = {
                    noop: function() {
                    },
                    uid: function() {
                        var t = 0;
                        return function() {
                            return t++;
                        };
                    }(),
                    isNullOrUndef: function(t) {
                        return null === t || void 0 === t;
                    },
                    isArray: Array.isArray ? Array.isArray : function(t) {
                        return "[object Array]" === Object.prototype.toString.call(t);
                    },
                    isObject: function(t) {
                        return null !== t && "[object Object]" === Object.prototype.toString.call(t);
                    },
                    valueOrDefault: function(t, e) {
                        return void 0 === t ? e : t;
                    },
                    valueAtIndexOrDefault: function(t, e, n) {
                        return i.valueOrDefault(i.isArray(t) ? t[e] : t, n);
                    },
                    callback: function(t, e, n) {
                        if (t && "function" == typeof t.call) return t.apply(n, e);
                    },
                    each: function(t, e, n, a) {
                        var r, o, s;
                        if (i.isArray(t)) if (o = t.length, a) for(r = o - 1; r >= 0; r--)e.call(n, t[r], r);
                        else for(r = 0; r < o; r++)e.call(n, t[r], r);
                        else if (i.isObject(t)) for(o = (s = Object.keys(t)).length, r = 0; r < o; r++)e.call(n, t[s[r]], s[r]);
                    },
                    arrayEquals: function(t, e) {
                        var n, a, r, o;
                        if (!t || !e || t.length !== e.length) return !1;
                        for(n = 0, a = t.length; n < a; ++n)if (r = t[n], o = e[n], r instanceof Array && o instanceof Array) {
                            if (!i.arrayEquals(r, o)) return !1;
                        } else if (r !== o) return !1;
                        return !0;
                    },
                    clone: function(t) {
                        if (i.isArray(t)) return t.map(i.clone);
                        if (i.isObject(t)) {
                            for(var e = {
                            }, n = Object.keys(t), a = n.length, r = 0; r < a; ++r)e[n[r]] = i.clone(t[n[r]]);
                            return e;
                        }
                        return t;
                    },
                    _merger: function(t, e, n, a) {
                        var r = e[t], o = n[t];
                        i.isObject(r) && i.isObject(o) ? i.merge(r, o, a) : e[t] = i.clone(o);
                    },
                    _mergerIf: function(t, e, n) {
                        var a = e[t], r = n[t];
                        i.isObject(a) && i.isObject(r) ? i.mergeIf(a, r) : e.hasOwnProperty(t) || (e[t] = i.clone(r));
                    },
                    merge: function(t, e, n) {
                        var a, r, o, s, l, u = i.isArray(e) ? e : [
                            e
                        ], d = u.length;
                        if (!i.isObject(t)) return t;
                        for(a = (n = n || {
                        }).merger || i._merger, r = 0; r < d; ++r)if (e = u[r], i.isObject(e)) for(l = 0, s = (o = Object.keys(e)).length; l < s; ++l)a(o[l], t, e, n);
                        return t;
                    },
                    mergeIf: function(t, e) {
                        return i.merge(t, e, {
                            merger: i._mergerIf
                        });
                    },
                    extend: function(t) {
                        for(var e = 1, n = arguments.length; e < n; ++e)i.each(arguments[e], function(e, n) {
                            t[n] = e;
                        });
                        return t;
                    },
                    inherits: function(t) {
                        var e = this, n = t && t.hasOwnProperty("constructor") ? t.constructor : function() {
                            return e.apply(this, arguments);
                        }, a = function() {
                            this.constructor = n;
                        };
                        return a.prototype = e.prototype, n.prototype = new a, n.extend = i.inherits, t && i.extend(n.prototype, t), n.__super__ = e.prototype, n;
                    }
                };
                e.exports = i, i.callCallback = i.callback, i.indexOf = function(t, e, n) {
                    return Array.prototype.indexOf.call(t, e, n);
                }, i.getValueOrDefault = i.valueOrDefault, i.getValueAtIndexOrDefault = i.valueAtIndexOrDefault;
            },
            {
            }
        ],
        43: [
            function(t, e, n) {
                "use strict";
                var i = t(42), a = {
                    linear: function(t) {
                        return t;
                    },
                    easeInQuad: function(t) {
                        return t * t;
                    },
                    easeOutQuad: function(t) {
                        return -t * (t - 2);
                    },
                    easeInOutQuad: function(t) {
                        return (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1);
                    },
                    easeInCubic: function(t) {
                        return t * t * t;
                    },
                    easeOutCubic: function(t) {
                        return (t -= 1) * t * t + 1;
                    },
                    easeInOutCubic: function(t) {
                        return (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2);
                    },
                    easeInQuart: function(t) {
                        return t * t * t * t;
                    },
                    easeOutQuart: function(t) {
                        return -((t -= 1) * t * t * t - 1);
                    },
                    easeInOutQuart: function(t) {
                        return (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2);
                    },
                    easeInQuint: function(t) {
                        return t * t * t * t * t;
                    },
                    easeOutQuint: function(t) {
                        return (t -= 1) * t * t * t * t + 1;
                    },
                    easeInOutQuint: function(t) {
                        return (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2);
                    },
                    easeInSine: function(t) {
                        return 1 - Math.cos(t * (Math.PI / 2));
                    },
                    easeOutSine: function(t) {
                        return Math.sin(t * (Math.PI / 2));
                    },
                    easeInOutSine: function(t) {
                        return -0.5 * (Math.cos(Math.PI * t) - 1);
                    },
                    easeInExpo: function(t) {
                        return 0 === t ? 0 : Math.pow(2, 10 * (t - 1));
                    },
                    easeOutExpo: function(t) {
                        return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
                    },
                    easeInOutExpo: function(t) {
                        return 0 === t ? 0 : 1 === t ? 1 : (t /= 0.5) < 1 ? 0.5 * Math.pow(2, 10 * (t - 1)) : 0.5 * (2 - Math.pow(2, -10 * --t));
                    },
                    easeInCirc: function(t) {
                        return t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1);
                    },
                    easeOutCirc: function(t) {
                        return Math.sqrt(1 - (t -= 1) * t);
                    },
                    easeInOutCirc: function(t) {
                        return (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
                    },
                    easeInElastic: function(t) {
                        var e = 1.70158, n = 0, i = 1;
                        return 0 === t ? 0 : 1 === t ? 1 : (n || (n = 0.3), i < 1 ? (i = 1, e = n / 4) : e = n / (2 * Math.PI) * Math.asin(1 / i), -i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n));
                    },
                    easeOutElastic: function(t) {
                        var e = 1.70158, n = 0, i = 1;
                        return 0 === t ? 0 : 1 === t ? 1 : (n || (n = 0.3), i < 1 ? (i = 1, e = n / 4) : e = n / (2 * Math.PI) * Math.asin(1 / i), i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / n) + 1);
                    },
                    easeInOutElastic: function(t) {
                        var e = 1.70158, n = 0, i = 1;
                        return 0 === t ? 0 : 2 == (t /= 0.5) ? 1 : (n || (n = 0.45), i < 1 ? (i = 1, e = n / 4) : e = n / (2 * Math.PI) * Math.asin(1 / i), t < 1 ? i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n) * -0.5 : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n) * 0.5 + 1);
                    },
                    easeInBack: function(t) {
                        var e = 1.70158;
                        return t * t * ((e + 1) * t - e);
                    },
                    easeOutBack: function(t) {
                        var e = 1.70158;
                        return (t -= 1) * t * ((e + 1) * t + e) + 1;
                    },
                    easeInOutBack: function(t) {
                        var e = 1.70158;
                        return (t /= 0.5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * 0.5 : 0.5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2);
                    },
                    easeInBounce: function(t) {
                        return 1 - a.easeOutBounce(1 - t);
                    },
                    easeOutBounce: function(t) {
                        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
                    },
                    easeInOutBounce: function(t) {
                        return t < 0.5 ? 0.5 * a.easeInBounce(2 * t) : 0.5 * a.easeOutBounce(2 * t - 1) + 0.5;
                    }
                };
                e.exports = {
                    effects: a
                }, i.easingEffects = a;
            },
            {
                42: 42
            }
        ],
        44: [
            function(t, e, n) {
                "use strict";
                var i = t(42);
                e.exports = {
                    toLineHeight: function(t, e) {
                        var n = ("" + t).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
                        if (!n || "normal" === n[1]) return 1.2 * e;
                        switch(t = +n[2], n[3]){
                            case "px":
                                return t;
                            case "%":
                                t /= 100;
                        }
                        return e * t;
                    },
                    toPadding: function(t) {
                        var e, n, a, r;
                        return i.isObject(t) ? (e = +t.top || 0, n = +t.right || 0, a = +t.bottom || 0, r = +t.left || 0) : e = n = a = r = +t || 0, {
                            top: e,
                            right: n,
                            bottom: a,
                            left: r,
                            height: e + a,
                            width: r + n
                        };
                    },
                    resolve: function(t, e, n) {
                        var a, r, o;
                        for(a = 0, r = t.length; a < r; ++a)if (void 0 !== (o = t[a]) && (void 0 !== e && "function" == typeof o && (o = o(e)), void 0 !== n && i.isArray(o) && (o = o[n]), void 0 !== o)) return o;
                    }
                };
            },
            {
                42: 42
            }
        ],
        45: [
            function(t, e, n) {
                "use strict";
                e.exports = t(42), e.exports.easing = t(43), e.exports.canvas = t(41), e.exports.options = t(44);
            },
            {
                41: 41,
                42: 42,
                43: 43,
                44: 44
            }
        ],
        46: [
            function(t, e, n) {
                e.exports = {
                    acquireContext: function(t) {
                        return t && t.canvas && (t = t.canvas), t && t.getContext("2d") || null;
                    }
                };
            },
            {
            }
        ],
        47: [
            function(t15, e, n) {
                "use strict";
                function i(t, e) {
                    var n = p.getStyle(t, e), i = n && n.match(/^(\d+)(\.\d+)?px$/);
                    return i ? Number(i[1]) : void 0;
                }
                function a(t, e) {
                    var n = t.style, a = t.getAttribute("height"), r = t.getAttribute("width");
                    if (t[v] = {
                        initial: {
                            height: a,
                            width: r,
                            style: {
                                display: n.display,
                                height: n.height,
                                width: n.width
                            }
                        }
                    }, n.display = n.display || "block", null === r || "" === r) {
                        var o = i(t, "width");
                        void 0 !== o && (t.width = o);
                    }
                    if (null === a || "" === a) if ("" === t.style.height) t.height = t.width / (e.options.aspectRatio || 2);
                    else {
                        var s = i(t, "height");
                        void 0 !== o && (t.height = s);
                    }
                    return t;
                }
                function r(t, e, n) {
                    t.addEventListener(e, n, w);
                }
                function o(t, e, n) {
                    t.removeEventListener(e, n, w);
                }
                function s(t, e, n, i, a) {
                    return {
                        type: t,
                        chart: e,
                        native: a || null,
                        x: void 0 !== n ? n : null,
                        y: void 0 !== i ? i : null
                    };
                }
                function l(t, e) {
                    var n = k[t.type] || t.type, i = p.getRelativePosition(t, e);
                    return s(n, e, i.x, i.y, t);
                }
                function u(t, e) {
                    var n = !1, i = [];
                    return function() {
                        i = Array.prototype.slice.call(arguments), e = e || this, n || (n = !0, p.requestAnimFrame.call(window, function() {
                            n = !1, t.apply(e, i);
                        }));
                    };
                }
                function d(t) {
                    var e = document.createElement("div"), n = y + "size-monitor", i = "position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1;";
                    e.style.cssText = i, e.className = n, e.innerHTML = '<div class="' + n + '-expand" style="' + i + '"><div style="position:absolute;width:1000000px;height:1000000px;left:0;top:0"></div></div><div class="' + n + '-shrink" style="' + i + '"><div style="position:absolute;width:200%;height:200%;left:0; top:0"></div></div>';
                    var a = e.childNodes[0], o = e.childNodes[1];
                    e._reset = function() {
                        a.scrollLeft = 1000000, a.scrollTop = 1000000, o.scrollLeft = 1000000, o.scrollTop = 1000000;
                    };
                    var s = function() {
                        e._reset(), t();
                    };
                    return r(a, "scroll", s.bind(a, "expand")), r(o, "scroll", s.bind(o, "shrink")), e;
                }
                function c(t, e) {
                    var n = t[v] || (t[v] = {
                    }), i = n.renderProxy = function(t) {
                        t.animationName === x && e();
                    };
                    p.each(_, function(e) {
                        r(t, e, i);
                    }), n.reflow = !!t.offsetParent, t.classList.add(b);
                }
                function h(t) {
                    var e = t[v] || {
                    }, n = e.renderProxy;
                    n && (p.each(_, function(e) {
                        o(t, e, n);
                    }), delete e.renderProxy), t.classList.remove(b);
                }
                function f(t, e, n) {
                    var i = t[v] || (t[v] = {
                    }), a = i.resizer = d(u(function() {
                        if (i.resizer) return e(s("resize", n));
                    }));
                    c(t, function() {
                        if (i.resizer) {
                            var e = t.parentNode;
                            e && e !== a.parentNode && e.insertBefore(a, e.firstChild), a._reset();
                        }
                    });
                }
                function g(t) {
                    var e = t[v] || {
                    }, n = e.resizer;
                    delete e.resizer, h(t), n && n.parentNode && n.parentNode.removeChild(n);
                }
                function m(t, e) {
                    var n = t._style || document.createElement("style");
                    t._style || (t._style = n, e = "/* Chart.js */\n" + e, n.setAttribute("type", "text/css"), document.getElementsByTagName("head")[0].appendChild(n)), n.appendChild(document.createTextNode(e));
                }
                var p = t15(45), v = "$chartjs", y = "chartjs-", b = y + "render-monitor", x = y + "render-animation", _ = [
                    "animationstart",
                    "webkitAnimationStart"
                ], k = {
                    touchstart: "mousedown",
                    touchmove: "mousemove",
                    touchend: "mouseup",
                    pointerenter: "mouseenter",
                    pointerdown: "mousedown",
                    pointermove: "mousemove",
                    pointerup: "mouseup",
                    pointerleave: "mouseout",
                    pointerout: "mouseout"
                }, w = !!function() {
                    var t = !1;
                    try {
                        var e = Object.defineProperty({
                        }, "passive", {
                            get: function() {
                                t = !0;
                            }
                        });
                        window.addEventListener("e", null, e);
                    } catch (t14) {
                    }
                    return t;
                }() && {
                    passive: !0
                };
                e.exports = {
                    _enabled: "undefined" != typeof window && "undefined" != typeof document,
                    initialize: function() {
                        var t = "from{opacity:0.99}to{opacity:1}";
                        m(this, "@-webkit-keyframes " + x + "{" + t + "}@keyframes " + x + "{" + t + "}." + b + "{-webkit-animation:" + x + " 0.001s;animation:" + x + " 0.001s;}");
                    },
                    acquireContext: function(t, e) {
                        "string" == typeof t ? t = document.getElementById(t) : t.length && (t = t[0]), t && t.canvas && (t = t.canvas);
                        var n = t && t.getContext && t.getContext("2d");
                        return n && n.canvas === t ? (a(t, e), n) : null;
                    },
                    releaseContext: function(t) {
                        var e = t.canvas;
                        if (e[v]) {
                            var n = e[v].initial;
                            [
                                "height",
                                "width"
                            ].forEach(function(t) {
                                var i = n[t];
                                p.isNullOrUndef(i) ? e.removeAttribute(t) : e.setAttribute(t, i);
                            }), p.each(n.style || {
                            }, function(t, n) {
                                e.style[n] = t;
                            }), e.width = e.width, delete e[v];
                        }
                    },
                    addEventListener: function(t, e, n) {
                        var i = t.canvas;
                        if ("resize" !== e) {
                            var a = n[v] || (n[v] = {
                            });
                            r(i, e, (a.proxies || (a.proxies = {
                            }))[t.id + "_" + e] = function(e) {
                                n(l(e, t));
                            });
                        } else f(i, n, t);
                    },
                    removeEventListener: function(t, e, n) {
                        var i = t.canvas;
                        if ("resize" !== e) {
                            var a = ((n[v] || {
                            }).proxies || {
                            })[t.id + "_" + e];
                            a && o(i, e, a);
                        } else g(i);
                    }
                }, p.addEvent = r, p.removeEvent = o;
            },
            {
                45: 45
            }
        ],
        48: [
            function(t, e, n) {
                "use strict";
                var i = t(45), a = t(46), r = t(47), o = r._enabled ? r : a;
                e.exports = i.extend({
                    initialize: function() {
                    },
                    acquireContext: function() {
                    },
                    releaseContext: function() {
                    },
                    addEventListener: function() {
                    },
                    removeEventListener: function() {
                    }
                }, o);
            },
            {
                45: 45,
                46: 46,
                47: 47
            }
        ],
        49: [
            function(t, e, n) {
                "use strict";
                var i = t(25), a = t(40), r = t(45);
                i._set("global", {
                    plugins: {
                        filler: {
                            propagate: !0
                        }
                    }
                }), e.exports = function() {
                    function t(t, e, n) {
                        var i, a = t._model || {
                        }, r = a.fill;
                        if (void 0 === r && (r = !!a.backgroundColor), !1 === r || null === r) return !1;
                        if (!0 === r) return "origin";
                        if (i = parseFloat(r, 10), isFinite(i) && Math.floor(i) === i) return "-" !== r[0] && "+" !== r[0] || (i = e + i), !(i === e || i < 0 || i >= n) && i;
                        switch(r){
                            case "bottom":
                                return "start";
                            case "top":
                                return "end";
                            case "zero":
                                return "origin";
                            case "origin":
                            case "start":
                            case "end":
                                return r;
                            default:
                                return !1;
                        }
                    }
                    function e(t) {
                        var e, n = t.el._model || {
                        }, i = t.el._scale || {
                        }, a = t.fill, r = null;
                        if (isFinite(a)) return null;
                        if ("start" === a ? r = void 0 === n.scaleBottom ? i.bottom : n.scaleBottom : "end" === a ? r = void 0 === n.scaleTop ? i.top : n.scaleTop : void 0 !== n.scaleZero ? r = n.scaleZero : i.getBasePosition ? r = i.getBasePosition() : i.getBasePixel && (r = i.getBasePixel()), void 0 !== r && null !== r) {
                            if (void 0 !== r.x && void 0 !== r.y) return r;
                            if ("number" == typeof r && isFinite(r)) return e = i.isHorizontal(), {
                                x: e ? r : null,
                                y: e ? null : r
                            };
                        }
                        return null;
                    }
                    function n(t, e, n) {
                        var i, a = t[e].fill, r = [
                            e
                        ];
                        if (!n) return a;
                        for(; !1 !== a && -1 === r.indexOf(a);){
                            if (!isFinite(a)) return a;
                            if (!(i = t[a])) return !1;
                            if (i.visible) return a;
                            r.push(a), a = i.fill;
                        }
                        return !1;
                    }
                    function o(t) {
                        var e = t.fill, n = "dataset";
                        return !1 === e ? null : (isFinite(e) || (n = "boundary"), d[n](t));
                    }
                    function s(t) {
                        return t && !t.skip;
                    }
                    function l(t, e, n, i, a) {
                        var o;
                        if (i && a) {
                            for(t.moveTo(e[0].x, e[0].y), o = 1; o < i; ++o)r.canvas.lineTo(t, e[o - 1], e[o]);
                            for(t.lineTo(n[a - 1].x, n[a - 1].y), o = a - 1; o > 0; --o)r.canvas.lineTo(t, n[o], n[o - 1], !0);
                        }
                    }
                    function u(t, e, n, i, a, r) {
                        var o, u, d, c, h, f, g, m = e.length, p = i.spanGaps, v = [], y = [], b = 0, x = 0;
                        for(t.beginPath(), o = 0, u = m + !!r; o < u; ++o)h = n(c = e[d = o % m]._view, d, i), f = s(c), g = s(h), f && g ? (b = v.push(c), x = y.push(h)) : b && x && (p ? (f && v.push(c), g && y.push(h)) : (l(t, v, y, b, x), b = x = 0, v = [], y = []));
                        l(t, v, y, b, x), t.closePath(), t.fillStyle = a, t.fill();
                    }
                    var d = {
                        dataset: function(t) {
                            var e = t.fill, n = t.chart, i = n.getDatasetMeta(e), a = i && n.isDatasetVisible(e) && i.dataset._children || [], r = a.length || 0;
                            return r ? function(t, e) {
                                return e < r && a[e]._view || null;
                            } : null;
                        },
                        boundary: function(t) {
                            var e = t.boundary, n = e ? e.x : null, i = e ? e.y : null;
                            return function(t) {
                                return {
                                    x: null === n ? t.x : n,
                                    y: null === i ? t.y : i
                                };
                            };
                        }
                    };
                    return {
                        id: "filler",
                        afterDatasetsUpdate: function(i, r) {
                            var s, l, u, d, c = (i.data.datasets || []).length, h = r.propagate, f = [];
                            for(l = 0; l < c; ++l)d = null, (u = (s = i.getDatasetMeta(l)).dataset) && u._model && u instanceof a.Line && (d = {
                                visible: i.isDatasetVisible(l),
                                fill: t(u, l, c),
                                chart: i,
                                el: u
                            }), s.$filler = d, f.push(d);
                            for(l = 0; l < c; ++l)(d = f[l]) && (d.fill = n(f, l, h), d.boundary = e(d), d.mapper = o(d));
                        },
                        beforeDatasetDraw: function(t, e) {
                            var n = e.meta.$filler;
                            if (n) {
                                var a = t.ctx, o = n.el, s = o._view, l = o._children || [], d = n.mapper, c = s.backgroundColor || i.global.defaultColor;
                                d && c && l.length && (r.canvas.clipArea(a, t.chartArea), u(a, l, d, s, c, o._loop), r.canvas.unclipArea(a));
                            }
                        }
                    };
                };
            },
            {
                25: 25,
                40: 40,
                45: 45
            }
        ],
        50: [
            function(t, e, n) {
                "use strict";
                var i = t(25), a = t(26), r = t(45);
                i._set("global", {
                    legend: {
                        display: !0,
                        position: "top",
                        fullWidth: !0,
                        reverse: !1,
                        weight: 1000,
                        onClick: function(t, e) {
                            var n = e.datasetIndex, i = this.chart, a = i.getDatasetMeta(n);
                            a.hidden = null === a.hidden ? !i.data.datasets[n].hidden : null, i.update();
                        },
                        onHover: null,
                        labels: {
                            boxWidth: 40,
                            padding: 10,
                            generateLabels: function(t) {
                                var e = t.data;
                                return r.isArray(e.datasets) ? e.datasets.map(function(e, n) {
                                    return {
                                        text: e.label,
                                        fillStyle: r.isArray(e.backgroundColor) ? e.backgroundColor[0] : e.backgroundColor,
                                        hidden: !t.isDatasetVisible(n),
                                        lineCap: e.borderCapStyle,
                                        lineDash: e.borderDash,
                                        lineDashOffset: e.borderDashOffset,
                                        lineJoin: e.borderJoinStyle,
                                        lineWidth: e.borderWidth,
                                        strokeStyle: e.borderColor,
                                        pointStyle: e.pointStyle,
                                        datasetIndex: n
                                    };
                                }, this) : [];
                            }
                        }
                    },
                    legendCallback: function(t) {
                        var e = [];
                        e.push('<ul class="' + t.id + '-legend">');
                        for(var n = 0; n < t.data.datasets.length; n++)e.push('<li><span style="background-color:' + t.data.datasets[n].backgroundColor + '"></span>'), t.data.datasets[n].label && e.push(t.data.datasets[n].label), e.push("</li>");
                        return e.push("</ul>"), e.join("");
                    }
                }), e.exports = function(t) {
                    function e(t, e) {
                        return t.usePointStyle ? e * Math.SQRT2 : t.boxWidth;
                    }
                    function n(e, n) {
                        var i = new t.Legend({
                            ctx: e.ctx,
                            options: n,
                            chart: e
                        });
                        o.configure(e, i, n), o.addBox(e, i), e.legend = i;
                    }
                    var o = t.layoutService, s = r.noop;
                    return t.Legend = a.extend({
                        initialize: function(t) {
                            r.extend(this, t), this.legendHitBoxes = [], this.doughnutMode = !1;
                        },
                        beforeUpdate: s,
                        update: function(t, e, n) {
                            var i = this;
                            return i.beforeUpdate(), i.maxWidth = t, i.maxHeight = e, i.margins = n, i.beforeSetDimensions(), i.setDimensions(), i.afterSetDimensions(), i.beforeBuildLabels(), i.buildLabels(), i.afterBuildLabels(), i.beforeFit(), i.fit(), i.afterFit(), i.afterUpdate(), i.minSize;
                        },
                        afterUpdate: s,
                        beforeSetDimensions: s,
                        setDimensions: function() {
                            var t = this;
                            t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = {
                                width: 0,
                                height: 0
                            };
                        },
                        afterSetDimensions: s,
                        beforeBuildLabels: s,
                        buildLabels: function() {
                            var t = this, e = t.options.labels || {
                            }, n = r.callback(e.generateLabels, [
                                t.chart
                            ], t) || [];
                            e.filter && (n = n.filter(function(n) {
                                return e.filter(n, t.chart.data);
                            })), t.options.reverse && n.reverse(), t.legendItems = n;
                        },
                        afterBuildLabels: s,
                        beforeFit: s,
                        fit: function() {
                            var t = this, n = t.options, a = n.labels, o = n.display, s = t.ctx, l = i.global, u = r.valueOrDefault, d = u(a.fontSize, l.defaultFontSize), c = u(a.fontStyle, l.defaultFontStyle), h = u(a.fontFamily, l.defaultFontFamily), f = r.fontString(d, c, h), g = t.legendHitBoxes = [], m = t.minSize, p = t.isHorizontal();
                            if (p ? (m.width = t.maxWidth, m.height = o ? 10 : 0) : (m.width = o ? 10 : 0, m.height = t.maxHeight), o) if (s.font = f, p) {
                                var v = t.lineWidths = [
                                    0
                                ], y = t.legendItems.length ? d + a.padding : 0;
                                s.textAlign = "left", s.textBaseline = "top", r.each(t.legendItems, function(n, i) {
                                    var r = e(a, d) + d / 2 + s.measureText(n.text).width;
                                    v[v.length - 1] + r + a.padding >= t.width && (y += d + a.padding, v[v.length] = t.left), g[i] = {
                                        left: 0,
                                        top: 0,
                                        width: r,
                                        height: d
                                    }, v[v.length - 1] += r + a.padding;
                                }), m.height += y;
                            } else {
                                var b = a.padding, x = t.columnWidths = [], _ = a.padding, k = 0, w = 0, M = d + b;
                                r.each(t.legendItems, function(t, n) {
                                    var i = e(a, d) + d / 2 + s.measureText(t.text).width;
                                    w + M > m.height && (_ += k + a.padding, x.push(k), k = 0, w = 0), k = Math.max(k, i), w += M, g[n] = {
                                        left: 0,
                                        top: 0,
                                        width: i,
                                        height: d
                                    };
                                }), _ += k, x.push(k), m.width += _;
                            }
                            t.width = m.width, t.height = m.height;
                        },
                        afterFit: s,
                        isHorizontal: function() {
                            return "top" === this.options.position || "bottom" === this.options.position;
                        },
                        draw: function() {
                            var t = this, n = t.options, a = n.labels, o = i.global, s = o.elements.line, l = t.width, u = t.lineWidths;
                            if (n.display) {
                                var d, c = t.ctx, h = r.valueOrDefault, f = h(a.fontColor, o.defaultFontColor), g = h(a.fontSize, o.defaultFontSize), m = h(a.fontStyle, o.defaultFontStyle), p = h(a.fontFamily, o.defaultFontFamily), v = r.fontString(g, m, p);
                                c.textAlign = "left", c.textBaseline = "middle", c.lineWidth = 0.5, c.strokeStyle = f, c.fillStyle = f, c.font = v;
                                var y = e(a, g), b = t.legendHitBoxes, x = function(t, e, i) {
                                    if (!(isNaN(y) || y <= 0)) {
                                        c.save(), c.fillStyle = h(i.fillStyle, o.defaultColor), c.lineCap = h(i.lineCap, s.borderCapStyle), c.lineDashOffset = h(i.lineDashOffset, s.borderDashOffset), c.lineJoin = h(i.lineJoin, s.borderJoinStyle), c.lineWidth = h(i.lineWidth, s.borderWidth), c.strokeStyle = h(i.strokeStyle, o.defaultColor);
                                        var a = 0 === h(i.lineWidth, s.borderWidth);
                                        if (c.setLineDash && c.setLineDash(h(i.lineDash, s.borderDash)), n.labels && n.labels.usePointStyle) {
                                            var l = g * Math.SQRT2 / 2, u = l / Math.SQRT2, d = t + u, f = e + u;
                                            r.canvas.drawPoint(c, i.pointStyle, l, d, f);
                                        } else a || c.strokeRect(t, e, y, g), c.fillRect(t, e, y, g);
                                        c.restore();
                                    }
                                }, _ = function(t, e, n, i) {
                                    var a = g / 2, r = y + a + t, o = e + a;
                                    c.fillText(n.text, r, o), n.hidden && (c.beginPath(), c.lineWidth = 2, c.moveTo(r, o), c.lineTo(r + i, o), c.stroke());
                                }, k = t.isHorizontal();
                                d = k ? {
                                    x: t.left + (l - u[0]) / 2,
                                    y: t.top + a.padding,
                                    line: 0
                                } : {
                                    x: t.left + a.padding,
                                    y: t.top + a.padding,
                                    line: 0
                                };
                                var w = g + a.padding;
                                r.each(t.legendItems, function(e, n) {
                                    var i = c.measureText(e.text).width, r = y + g / 2 + i, o = d.x, s = d.y;
                                    k ? o + r >= l && (s = d.y += w, d.line++, o = d.x = t.left + (l - u[d.line]) / 2) : s + w > t.bottom && (o = d.x = o + t.columnWidths[d.line] + a.padding, s = d.y = t.top + a.padding, d.line++), x(o, s, e), b[n].left = o, b[n].top = s, _(o, s, e, i), k ? d.x += r + a.padding : d.y += w;
                                });
                            }
                        },
                        handleEvent: function(t) {
                            var e = this, n = e.options, i = "mouseup" === t.type ? "click" : t.type, a = !1;
                            if ("mousemove" === i) {
                                if (!n.onHover) return;
                            } else {
                                if ("click" !== i) return;
                                if (!n.onClick) return;
                            }
                            var r = t.x, o = t.y;
                            if (r >= e.left && r <= e.right && o >= e.top && o <= e.bottom) for(var s = e.legendHitBoxes, l = 0; l < s.length; ++l){
                                var u = s[l];
                                if (r >= u.left && r <= u.left + u.width && o >= u.top && o <= u.top + u.height) {
                                    if ("click" === i) {
                                        n.onClick.call(e, t.native, e.legendItems[l]), a = !0;
                                        break;
                                    }
                                    if ("mousemove" === i) {
                                        n.onHover.call(e, t.native, e.legendItems[l]), a = !0;
                                        break;
                                    }
                                }
                            }
                            return a;
                        }
                    }), {
                        id: "legend",
                        beforeInit: function(t) {
                            var e = t.options.legend;
                            e && n(t, e);
                        },
                        beforeUpdate: function(t) {
                            var e = t.options.legend, a = t.legend;
                            e ? (r.mergeIf(e, i.global.legend), a ? (o.configure(t, a, e), a.options = e) : n(t, e)) : a && (o.removeBox(t, a), delete t.legend);
                        },
                        afterEvent: function(t, e) {
                            var n = t.legend;
                            n && n.handleEvent(e);
                        }
                    };
                };
            },
            {
                25: 25,
                26: 26,
                45: 45
            }
        ],
        51: [
            function(t, e, n) {
                "use strict";
                var i = t(25), a = t(26), r = t(45);
                i._set("global", {
                    title: {
                        display: !1,
                        fontStyle: "bold",
                        fullWidth: !0,
                        lineHeight: 1.2,
                        padding: 10,
                        position: "top",
                        text: "",
                        weight: 2000
                    }
                }), e.exports = function(t) {
                    function e(e, i) {
                        var a = new t.Title({
                            ctx: e.ctx,
                            options: i,
                            chart: e
                        });
                        n.configure(e, a, i), n.addBox(e, a), e.titleBlock = a;
                    }
                    var n = t.layoutService, o = r.noop;
                    return t.Title = a.extend({
                        initialize: function(t) {
                            var e = this;
                            r.extend(e, t), e.legendHitBoxes = [];
                        },
                        beforeUpdate: o,
                        update: function(t, e, n) {
                            var i = this;
                            return i.beforeUpdate(), i.maxWidth = t, i.maxHeight = e, i.margins = n, i.beforeSetDimensions(), i.setDimensions(), i.afterSetDimensions(), i.beforeBuildLabels(), i.buildLabels(), i.afterBuildLabels(), i.beforeFit(), i.fit(), i.afterFit(), i.afterUpdate(), i.minSize;
                        },
                        afterUpdate: o,
                        beforeSetDimensions: o,
                        setDimensions: function() {
                            var t = this;
                            t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = {
                                width: 0,
                                height: 0
                            };
                        },
                        afterSetDimensions: o,
                        beforeBuildLabels: o,
                        buildLabels: o,
                        afterBuildLabels: o,
                        beforeFit: o,
                        fit: function() {
                            var t = this, e = r.valueOrDefault, n = t.options, a = n.display, o = e(n.fontSize, i.global.defaultFontSize), s = t.minSize, l = r.isArray(n.text) ? n.text.length : 1, u = r.options.toLineHeight(n.lineHeight, o), d = a ? l * u + 2 * n.padding : 0;
                            t.isHorizontal() ? (s.width = t.maxWidth, s.height = d) : (s.width = d, s.height = t.maxHeight), t.width = s.width, t.height = s.height;
                        },
                        afterFit: o,
                        isHorizontal: function() {
                            var t = this.options.position;
                            return "top" === t || "bottom" === t;
                        },
                        draw: function() {
                            var t = this, e = t.ctx, n = r.valueOrDefault, a = t.options, o = i.global;
                            if (a.display) {
                                var s, l, u, d = n(a.fontSize, o.defaultFontSize), c = n(a.fontStyle, o.defaultFontStyle), h = n(a.fontFamily, o.defaultFontFamily), f = r.fontString(d, c, h), g = r.options.toLineHeight(a.lineHeight, d), m = g / 2 + a.padding, p = 0, v = t.top, y = t.left, b = t.bottom, x = t.right;
                                e.fillStyle = n(a.fontColor, o.defaultFontColor), e.font = f, t.isHorizontal() ? (l = y + (x - y) / 2, u = v + m, s = x - y) : (l = "left" === a.position ? y + m : x - m, u = v + (b - v) / 2, s = b - v, p = Math.PI * ("left" === a.position ? -0.5 : 0.5)), e.save(), e.translate(l, u), e.rotate(p), e.textAlign = "center", e.textBaseline = "middle";
                                var _ = a.text;
                                if (r.isArray(_)) for(var k = 0, w = 0; w < _.length; ++w)e.fillText(_[w], 0, k, s), k += g;
                                else e.fillText(_, 0, 0, s);
                                e.restore();
                            }
                        }
                    }), {
                        id: "title",
                        beforeInit: function(t) {
                            var n = t.options.title;
                            n && e(t, n);
                        },
                        beforeUpdate: function(a) {
                            var o = a.options.title, s = a.titleBlock;
                            o ? (r.mergeIf(o, i.global.title), s ? (n.configure(a, s, o), s.options = o) : e(a, o)) : s && (t.layoutService.removeBox(a, s), delete a.titleBlock);
                        }
                    };
                };
            },
            {
                25: 25,
                26: 26,
                45: 45
            }
        ],
        52: [
            function(t, e, n) {
                "use strict";
                e.exports = function(t) {
                    var e = t.Scale.extend({
                        getLabels: function() {
                            var t = this.chart.data;
                            return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels;
                        },
                        determineDataLimits: function() {
                            var t = this, e = t.getLabels();
                            t.minIndex = 0, t.maxIndex = e.length - 1;
                            var n;
                            void 0 !== t.options.ticks.min && (n = e.indexOf(t.options.ticks.min), t.minIndex = -1 !== n ? n : t.minIndex), void 0 !== t.options.ticks.max && (n = e.indexOf(t.options.ticks.max), t.maxIndex = -1 !== n ? n : t.maxIndex), t.min = e[t.minIndex], t.max = e[t.maxIndex];
                        },
                        buildTicks: function() {
                            var t = this, e = t.getLabels();
                            t.ticks = 0 === t.minIndex && t.maxIndex === e.length - 1 ? e : e.slice(t.minIndex, t.maxIndex + 1);
                        },
                        getLabelForIndex: function(t, e) {
                            var n = this, i = n.chart.data, a = n.isHorizontal();
                            return i.yLabels && !a ? n.getRightValue(i.datasets[e].data[t]) : n.ticks[t - n.minIndex];
                        },
                        getPixelForValue: function(t, e) {
                            var n, i = this, a = i.options.offset, r = Math.max(i.maxIndex + 1 - i.minIndex - (a ? 0 : 1), 1);
                            if (void 0 !== t && null !== t && (n = i.isHorizontal() ? t.x : t.y), void 0 !== n || void 0 !== t && isNaN(e)) {
                                var o = i.getLabels();
                                t = n || t;
                                var s = o.indexOf(t);
                                e = -1 !== s ? s : e;
                            }
                            if (i.isHorizontal()) {
                                var l = i.width / r, u = l * (e - i.minIndex);
                                return a && (u += l / 2), i.left + Math.round(u);
                            }
                            var d = i.height / r, c = d * (e - i.minIndex);
                            return a && (c += d / 2), i.top + Math.round(c);
                        },
                        getPixelForTick: function(t) {
                            return this.getPixelForValue(this.ticks[t], t + this.minIndex, null);
                        },
                        getValueForPixel: function(t) {
                            var e = this, n = e.options.offset, i = Math.max(e._ticks.length - (n ? 0 : 1), 1), a = e.isHorizontal(), r = (a ? e.width : e.height) / i;
                            return t -= a ? e.left : e.top, n && (t -= r / 2), (t <= 0 ? 0 : Math.round(t / r)) + e.minIndex;
                        },
                        getBasePixel: function() {
                            return this.bottom;
                        }
                    });
                    t.scaleService.registerScaleType("category", e, {
                        position: "bottom"
                    });
                };
            },
            {
            }
        ],
        53: [
            function(t, e, n) {
                "use strict";
                var i = t(25), a = t(45), r = t(34);
                e.exports = function(t) {
                    var e = {
                        position: "left",
                        ticks: {
                            callback: r.formatters.linear
                        }
                    }, n = t.LinearScaleBase.extend({
                        determineDataLimits: function() {
                            function t(t) {
                                return o ? t.xAxisID === e.id : t.yAxisID === e.id;
                            }
                            var e = this, n = e.options, i = e.chart, r = i.data.datasets, o = e.isHorizontal();
                            e.min = null, e.max = null;
                            var s = n.stacked;
                            if (void 0 === s && a.each(r, function(e, n) {
                                if (!s) {
                                    var a = i.getDatasetMeta(n);
                                    i.isDatasetVisible(n) && t(a) && void 0 !== a.stack && (s = !0);
                                }
                            }), n.stacked || s) {
                                var l = {
                                };
                                a.each(r, function(r, o) {
                                    var s = i.getDatasetMeta(o), u = [
                                        s.type,
                                        void 0 === n.stacked && void 0 === s.stack ? o : "",
                                        s.stack
                                    ].join(".");
                                    void 0 === l[u] && (l[u] = {
                                        positiveValues: [],
                                        negativeValues: []
                                    });
                                    var d = l[u].positiveValues, c = l[u].negativeValues;
                                    i.isDatasetVisible(o) && t(s) && a.each(r.data, function(t, i) {
                                        var a = +e.getRightValue(t);
                                        isNaN(a) || s.data[i].hidden || (d[i] = d[i] || 0, c[i] = c[i] || 0, n.relativePoints ? d[i] = 100 : a < 0 ? c[i] += a : d[i] += a);
                                    });
                                }), a.each(l, function(t) {
                                    var n = t.positiveValues.concat(t.negativeValues), i = a.min(n), r = a.max(n);
                                    e.min = null === e.min ? i : Math.min(e.min, i), e.max = null === e.max ? r : Math.max(e.max, r);
                                });
                            } else a.each(r, function(n, r) {
                                var o = i.getDatasetMeta(r);
                                i.isDatasetVisible(r) && t(o) && a.each(n.data, function(t, n) {
                                    var i = +e.getRightValue(t);
                                    isNaN(i) || o.data[n].hidden || (null === e.min ? e.min = i : i < e.min && (e.min = i), null === e.max ? e.max = i : i > e.max && (e.max = i));
                                });
                            });
                            e.min = isFinite(e.min) && !isNaN(e.min) ? e.min : 0, e.max = isFinite(e.max) && !isNaN(e.max) ? e.max : 1, this.handleTickRangeOptions();
                        },
                        getTickLimit: function() {
                            var t, e = this, n = e.options.ticks;
                            if (e.isHorizontal()) t = Math.min(n.maxTicksLimit ? n.maxTicksLimit : 11, Math.ceil(e.width / 50));
                            else {
                                var r = a.valueOrDefault(n.fontSize, i.global.defaultFontSize);
                                t = Math.min(n.maxTicksLimit ? n.maxTicksLimit : 11, Math.ceil(e.height / (2 * r)));
                            }
                            return t;
                        },
                        handleDirectionalChanges: function() {
                            this.isHorizontal() || this.ticks.reverse();
                        },
                        getLabelForIndex: function(t, e) {
                            return +this.getRightValue(this.chart.data.datasets[e].data[t]);
                        },
                        getPixelForValue: function(t) {
                            var e, n = this, i = n.start, a = +n.getRightValue(t), r = n.end - i;
                            return n.isHorizontal() ? (e = n.left + n.width / r * (a - i), Math.round(e)) : (e = n.bottom - n.height / r * (a - i), Math.round(e));
                        },
                        getValueForPixel: function(t) {
                            var e = this, n = e.isHorizontal(), i = n ? e.width : e.height, a = (n ? t - e.left : e.bottom - t) / i;
                            return e.start + (e.end - e.start) * a;
                        },
                        getPixelForTick: function(t) {
                            return this.getPixelForValue(this.ticksAsNumbers[t]);
                        }
                    });
                    t.scaleService.registerScaleType("linear", n, e);
                };
            },
            {
                25: 25,
                34: 34,
                45: 45
            }
        ],
        54: [
            function(t, e, n) {
                "use strict";
                var i = t(45), a = t(34);
                e.exports = function(t) {
                    var e = i.noop;
                    t.LinearScaleBase = t.Scale.extend({
                        getRightValue: function(e) {
                            return "string" == typeof e ? +e : t.Scale.prototype.getRightValue.call(this, e);
                        },
                        handleTickRangeOptions: function() {
                            var t = this, e = t.options.ticks;
                            if (e.beginAtZero) {
                                var n = i.sign(t.min), a = i.sign(t.max);
                                n < 0 && a < 0 ? t.max = 0 : n > 0 && a > 0 && (t.min = 0);
                            }
                            var r = void 0 !== e.min || void 0 !== e.suggestedMin, o = void 0 !== e.max || void 0 !== e.suggestedMax;
                            void 0 !== e.min ? t.min = e.min : void 0 !== e.suggestedMin && (null === t.min ? t.min = e.suggestedMin : t.min = Math.min(t.min, e.suggestedMin)), void 0 !== e.max ? t.max = e.max : void 0 !== e.suggestedMax && (null === t.max ? t.max = e.suggestedMax : t.max = Math.max(t.max, e.suggestedMax)), r !== o && t.min >= t.max && (r ? t.max = t.min + 1 : t.min = t.max - 1), t.min === t.max && (t.max++, e.beginAtZero || t.min--);
                        },
                        getTickLimit: e,
                        handleDirectionalChanges: e,
                        buildTicks: function() {
                            var t = this, e = t.options.ticks, n = t.getTickLimit(), r = {
                                maxTicks: n = Math.max(2, n),
                                min: e.min,
                                max: e.max,
                                stepSize: i.valueOrDefault(e.fixedStepSize, e.stepSize)
                            }, o = t.ticks = a.generators.linear(r, t);
                            t.handleDirectionalChanges(), t.max = i.max(o), t.min = i.min(o), e.reverse ? (o.reverse(), t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max);
                        },
                        convertTicksToLabels: function() {
                            var e = this;
                            e.ticksAsNumbers = e.ticks.slice(), e.zeroLineIndex = e.ticks.indexOf(0), t.Scale.prototype.convertTicksToLabels.call(e);
                        }
                    });
                };
            },
            {
                34: 34,
                45: 45
            }
        ],
        55: [
            function(t, e, n) {
                "use strict";
                var i = t(45), a = t(34);
                e.exports = function(t) {
                    var e = {
                        position: "left",
                        ticks: {
                            callback: a.formatters.logarithmic
                        }
                    }, n = t.Scale.extend({
                        determineDataLimits: function() {
                            function t(t) {
                                return l ? t.xAxisID === e.id : t.yAxisID === e.id;
                            }
                            var e = this, n = e.options, a = n.ticks, r = e.chart, o = r.data.datasets, s = i.valueOrDefault, l = e.isHorizontal();
                            e.min = null, e.max = null, e.minNotZero = null;
                            var u = n.stacked;
                            if (void 0 === u && i.each(o, function(e, n) {
                                if (!u) {
                                    var i = r.getDatasetMeta(n);
                                    r.isDatasetVisible(n) && t(i) && void 0 !== i.stack && (u = !0);
                                }
                            }), n.stacked || u) {
                                var d = {
                                };
                                i.each(o, function(a, o) {
                                    var s = r.getDatasetMeta(o), l = [
                                        s.type,
                                        void 0 === n.stacked && void 0 === s.stack ? o : "",
                                        s.stack
                                    ].join(".");
                                    r.isDatasetVisible(o) && t(s) && (void 0 === d[l] && (d[l] = []), i.each(a.data, function(t, i) {
                                        var a = d[l], r = +e.getRightValue(t);
                                        isNaN(r) || s.data[i].hidden || (a[i] = a[i] || 0, n.relativePoints ? a[i] = 100 : a[i] += r);
                                    }));
                                }), i.each(d, function(t) {
                                    var n = i.min(t), a = i.max(t);
                                    e.min = null === e.min ? n : Math.min(e.min, n), e.max = null === e.max ? a : Math.max(e.max, a);
                                });
                            } else i.each(o, function(n, a) {
                                var o = r.getDatasetMeta(a);
                                r.isDatasetVisible(a) && t(o) && i.each(n.data, function(t, n) {
                                    var i = +e.getRightValue(t);
                                    isNaN(i) || o.data[n].hidden || (null === e.min ? e.min = i : i < e.min && (e.min = i), null === e.max ? e.max = i : i > e.max && (e.max = i), 0 !== i && (null === e.minNotZero || i < e.minNotZero) && (e.minNotZero = i));
                                });
                            });
                            e.min = s(a.min, e.min), e.max = s(a.max, e.max), e.min === e.max && (0 !== e.min && null !== e.min ? (e.min = Math.pow(10, Math.floor(i.log10(e.min)) - 1), e.max = Math.pow(10, Math.floor(i.log10(e.max)) + 1)) : (e.min = 1, e.max = 10));
                        },
                        buildTicks: function() {
                            var t = this, e = t.options.ticks, n = {
                                min: e.min,
                                max: e.max
                            }, r = t.ticks = a.generators.logarithmic(n, t);
                            t.isHorizontal() || r.reverse(), t.max = i.max(r), t.min = i.min(r), e.reverse ? (r.reverse(), t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max);
                        },
                        convertTicksToLabels: function() {
                            this.tickValues = this.ticks.slice(), t.Scale.prototype.convertTicksToLabels.call(this);
                        },
                        getLabelForIndex: function(t, e) {
                            return +this.getRightValue(this.chart.data.datasets[e].data[t]);
                        },
                        getPixelForTick: function(t) {
                            return this.getPixelForValue(this.tickValues[t]);
                        },
                        getPixelForValue: function(t) {
                            var e, n, a, r = this, o = r.start, s = +r.getRightValue(t), l = r.options.ticks;
                            return r.isHorizontal() ? (a = i.log10(r.end) - i.log10(o), 0 === s ? n = r.left : (e = r.width, n = r.left + e / a * (i.log10(s) - i.log10(o)))) : (e = r.height, 0 !== o || l.reverse ? 0 === r.end && l.reverse ? (a = i.log10(r.start) - i.log10(r.minNotZero), n = s === r.end ? r.top : s === r.minNotZero ? r.top + 0.02 * e : r.top + 0.02 * e + 0.98 * e / a * (i.log10(s) - i.log10(r.minNotZero))) : 0 === s ? n = l.reverse ? r.top : r.bottom : (a = i.log10(r.end) - i.log10(o), e = r.height, n = r.bottom - e / a * (i.log10(s) - i.log10(o))) : (a = i.log10(r.end) - i.log10(r.minNotZero), n = s === o ? r.bottom : s === r.minNotZero ? r.bottom - 0.02 * e : r.bottom - 0.02 * e - 0.98 * e / a * (i.log10(s) - i.log10(r.minNotZero)))), n;
                        },
                        getValueForPixel: function(t) {
                            var e, n, a = this, r = i.log10(a.end) - i.log10(a.start);
                            return a.isHorizontal() ? (n = a.width, e = a.start * Math.pow(10, (t - a.left) * r / n)) : (n = a.height, e = Math.pow(10, (a.bottom - t) * r / n) / a.start), e;
                        }
                    });
                    t.scaleService.registerScaleType("logarithmic", n, e);
                };
            },
            {
                34: 34,
                45: 45
            }
        ],
        56: [
            function(t, e, n) {
                "use strict";
                var i = t(25), a = t(45), r = t(34);
                e.exports = function(t) {
                    function e(t) {
                        var e = t.options;
                        return e.angleLines.display || e.pointLabels.display ? t.chart.data.labels.length : 0;
                    }
                    function n(t) {
                        var e = t.options.pointLabels, n = a.valueOrDefault(e.fontSize, p.defaultFontSize), i = a.valueOrDefault(e.fontStyle, p.defaultFontStyle), r = a.valueOrDefault(e.fontFamily, p.defaultFontFamily);
                        return {
                            size: n,
                            style: i,
                            family: r,
                            font: a.fontString(n, i, r)
                        };
                    }
                    function o(t, e, n) {
                        return a.isArray(n) ? {
                            w: a.longestText(t, t.font, n),
                            h: n.length * e + 1.5 * (n.length - 1) * e
                        } : {
                            w: t.measureText(n).width,
                            h: e
                        };
                    }
                    function s(t, e, n, i, a) {
                        return t === i || t === a ? {
                            start: e - n / 2,
                            end: e + n / 2
                        } : t < i || t > a ? {
                            start: e - n - 5,
                            end: e
                        } : {
                            start: e,
                            end: e + n + 5
                        };
                    }
                    function l(t) {
                        var i, r, l, u = n(t), d = Math.min(t.height / 2, t.width / 2), c = {
                            r: t.width,
                            l: 0,
                            t: t.height,
                            b: 0
                        }, h = {
                        };
                        t.ctx.font = u.font, t._pointLabelSizes = [];
                        var f = e(t);
                        for(i = 0; i < f; i++){
                            l = t.getPointPosition(i, d), r = o(t.ctx, u.size, t.pointLabels[i] || ""), t._pointLabelSizes[i] = r;
                            var g = t.getIndexAngle(i), m = a.toDegrees(g) % 360, p = s(m, l.x, r.w, 0, 180), v = s(m, l.y, r.h, 90, 270);
                            p.start < c.l && (c.l = p.start, h.l = g), p.end > c.r && (c.r = p.end, h.r = g), v.start < c.t && (c.t = v.start, h.t = g), v.end > c.b && (c.b = v.end, h.b = g);
                        }
                        t.setReductions(d, c, h);
                    }
                    function u(t) {
                        var e = Math.min(t.height / 2, t.width / 2);
                        t.drawingArea = Math.round(e), t.setCenterPoint(0, 0, 0, 0);
                    }
                    function d(t) {
                        return 0 === t || 180 === t ? "center" : t < 180 ? "left" : "right";
                    }
                    function c(t, e, n, i) {
                        if (a.isArray(e)) for(var r = n.y, o = 1.5 * i, s = 0; s < e.length; ++s)t.fillText(e[s], n.x, r), r += o;
                        else t.fillText(e, n.x, n.y);
                    }
                    function h(t, e, n) {
                        90 === t || 270 === t ? n.y -= e.h / 2 : (t > 270 || t < 90) && (n.y -= e.h);
                    }
                    function f(t) {
                        var i = t.ctx, r = a.valueOrDefault, o = t.options, s = o.angleLines, l = o.pointLabels;
                        i.lineWidth = s.lineWidth, i.strokeStyle = s.color;
                        var u = t.getDistanceFromCenterForValue(o.ticks.reverse ? t.min : t.max), f = n(t);
                        i.textBaseline = "top";
                        for(var g = e(t) - 1; g >= 0; g--){
                            if (s.display) {
                                var m = t.getPointPosition(g, u);
                                i.beginPath(), i.moveTo(t.xCenter, t.yCenter), i.lineTo(m.x, m.y), i.stroke(), i.closePath();
                            }
                            if (l.display) {
                                var v = t.getPointPosition(g, u + 5), y = r(l.fontColor, p.defaultFontColor);
                                i.font = f.font, i.fillStyle = y;
                                var b = t.getIndexAngle(g), x = a.toDegrees(b);
                                i.textAlign = d(x), h(x, t._pointLabelSizes[g], v), c(i, t.pointLabels[g] || "", v, f.size);
                            }
                        }
                    }
                    function g(t, n, i, r) {
                        var o = t.ctx;
                        if (o.strokeStyle = a.valueAtIndexOrDefault(n.color, r - 1), o.lineWidth = a.valueAtIndexOrDefault(n.lineWidth, r - 1), t.options.gridLines.circular) o.beginPath(), o.arc(t.xCenter, t.yCenter, i, 0, 2 * Math.PI), o.closePath(), o.stroke();
                        else {
                            var s = e(t);
                            if (0 === s) return;
                            o.beginPath();
                            var l = t.getPointPosition(0, i);
                            o.moveTo(l.x, l.y);
                            for(var u = 1; u < s; u++)l = t.getPointPosition(u, i), o.lineTo(l.x, l.y);
                            o.closePath(), o.stroke();
                        }
                    }
                    function m(t) {
                        return a.isNumber(t) ? t : 0;
                    }
                    var p = i.global, v = {
                        display: !0,
                        animate: !0,
                        position: "chartArea",
                        angleLines: {
                            display: !0,
                            color: "rgba(0, 0, 0, 0.1)",
                            lineWidth: 1
                        },
                        gridLines: {
                            circular: !1
                        },
                        ticks: {
                            showLabelBackdrop: !0,
                            backdropColor: "rgba(255,255,255,0.75)",
                            backdropPaddingY: 2,
                            backdropPaddingX: 2,
                            callback: r.formatters.linear
                        },
                        pointLabels: {
                            display: !0,
                            fontSize: 10,
                            callback: function(t) {
                                return t;
                            }
                        }
                    }, y = t.LinearScaleBase.extend({
                        setDimensions: function() {
                            var t = this, e = t.options, n = e.ticks;
                            t.width = t.maxWidth, t.height = t.maxHeight, t.xCenter = Math.round(t.width / 2), t.yCenter = Math.round(t.height / 2);
                            var i = a.min([
                                t.height,
                                t.width
                            ]), r = a.valueOrDefault(n.fontSize, p.defaultFontSize);
                            t.drawingArea = e.display ? i / 2 - (r / 2 + n.backdropPaddingY) : i / 2;
                        },
                        determineDataLimits: function() {
                            var t = this, e = t.chart, n = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;
                            a.each(e.data.datasets, function(r, o) {
                                if (e.isDatasetVisible(o)) {
                                    var s = e.getDatasetMeta(o);
                                    a.each(r.data, function(e, a) {
                                        var r = +t.getRightValue(e);
                                        isNaN(r) || s.data[a].hidden || (n = Math.min(r, n), i = Math.max(r, i));
                                    });
                                }
                            }), t.min = n === Number.POSITIVE_INFINITY ? 0 : n, t.max = i === Number.NEGATIVE_INFINITY ? 0 : i, t.handleTickRangeOptions();
                        },
                        getTickLimit: function() {
                            var t = this.options.ticks, e = a.valueOrDefault(t.fontSize, p.defaultFontSize);
                            return Math.min(t.maxTicksLimit ? t.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * e)));
                        },
                        convertTicksToLabels: function() {
                            var e = this;
                            t.LinearScaleBase.prototype.convertTicksToLabels.call(e), e.pointLabels = e.chart.data.labels.map(e.options.pointLabels.callback, e);
                        },
                        getLabelForIndex: function(t, e) {
                            return +this.getRightValue(this.chart.data.datasets[e].data[t]);
                        },
                        fit: function() {
                            this.options.pointLabels.display ? l(this) : u(this);
                        },
                        setReductions: function(t, e, n) {
                            var i = this, a = e.l / Math.sin(n.l), r = Math.max(e.r - i.width, 0) / Math.sin(n.r), o = -e.t / Math.cos(n.t), s = -Math.max(e.b - i.height, 0) / Math.cos(n.b);
                            a = m(a), r = m(r), o = m(o), s = m(s), i.drawingArea = Math.min(Math.round(t - (a + r) / 2), Math.round(t - (o + s) / 2)), i.setCenterPoint(a, r, o, s);
                        },
                        setCenterPoint: function(t, e, n, i) {
                            var a = this, r = a.width - e - a.drawingArea, o = t + a.drawingArea, s = n + a.drawingArea, l = a.height - i - a.drawingArea;
                            a.xCenter = Math.round((o + r) / 2 + a.left), a.yCenter = Math.round((s + l) / 2 + a.top);
                        },
                        getIndexAngle: function(t) {
                            return t * (2 * Math.PI / e(this)) + (this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0) * Math.PI * 2 / 360;
                        },
                        getDistanceFromCenterForValue: function(t) {
                            var e = this;
                            if (null === t) return 0;
                            var n = e.drawingArea / (e.max - e.min);
                            return e.options.ticks.reverse ? (e.max - t) * n : (t - e.min) * n;
                        },
                        getPointPosition: function(t, e) {
                            var n = this, i = n.getIndexAngle(t) - Math.PI / 2;
                            return {
                                x: Math.round(Math.cos(i) * e) + n.xCenter,
                                y: Math.round(Math.sin(i) * e) + n.yCenter
                            };
                        },
                        getPointPositionForValue: function(t, e) {
                            return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));
                        },
                        getBasePosition: function() {
                            var t = this, e = t.min, n = t.max;
                            return t.getPointPositionForValue(0, t.beginAtZero ? 0 : e < 0 && n < 0 ? n : e > 0 && n > 0 ? e : 0);
                        },
                        draw: function() {
                            var t = this, e = t.options, n = e.gridLines, i = e.ticks, r = a.valueOrDefault;
                            if (e.display) {
                                var o = t.ctx, s = this.getIndexAngle(0), l = r(i.fontSize, p.defaultFontSize), u = r(i.fontStyle, p.defaultFontStyle), d = r(i.fontFamily, p.defaultFontFamily), c = a.fontString(l, u, d);
                                a.each(t.ticks, function(e, a) {
                                    if (a > 0 || i.reverse) {
                                        var u = t.getDistanceFromCenterForValue(t.ticksAsNumbers[a]);
                                        if (n.display && 0 !== a && g(t, n, u, a), i.display) {
                                            var d = r(i.fontColor, p.defaultFontColor);
                                            if (o.font = c, o.save(), o.translate(t.xCenter, t.yCenter), o.rotate(s), i.showLabelBackdrop) {
                                                var h = o.measureText(e).width;
                                                o.fillStyle = i.backdropColor, o.fillRect(-h / 2 - i.backdropPaddingX, -u - l / 2 - i.backdropPaddingY, h + 2 * i.backdropPaddingX, l + 2 * i.backdropPaddingY);
                                            }
                                            o.textAlign = "center", o.textBaseline = "middle", o.fillStyle = d, o.fillText(e, 0, -u), o.restore();
                                        }
                                    }
                                }), (e.angleLines.display || e.pointLabels.display) && f(t);
                            }
                        }
                    });
                    t.scaleService.registerScaleType("radialLinear", y, v);
                };
            },
            {
                25: 25,
                34: 34,
                45: 45
            }
        ],
        57: [
            function(t, e, n) {
                "use strict";
                function i(t, e) {
                    return t - e;
                }
                function a(t) {
                    var e, n, i, a = {
                    }, r = [];
                    for(e = 0, n = t.length; e < n; ++e)a[i = t[e]] || (a[i] = !0, r.push(i));
                    return r;
                }
                function r(t, e, n, i) {
                    if ("linear" === i || !t.length) return [
                        {
                            time: e,
                            pos: 0
                        },
                        {
                            time: n,
                            pos: 1
                        }
                    ];
                    var a, r, o, s, l, u = [], d = [
                        e
                    ];
                    for(a = 0, r = t.length; a < r; ++a)(s = t[a]) > e && s < n && d.push(s);
                    for(d.push(n), a = 0, r = d.length; a < r; ++a)l = d[a + 1], o = d[a - 1], s = d[a], void 0 !== o && void 0 !== l && Math.round((l + o) / 2) === s || u.push({
                        time: s,
                        pos: a / (r - 1)
                    });
                    return u;
                }
                function o(t, e, n) {
                    for(var i, a, r, o = 0, s = t.length - 1; o >= 0 && o <= s;){
                        if (i = o + s >> 1, a = t[i - 1] || null, r = t[i], !a) return {
                            lo: null,
                            hi: r
                        };
                        if (r[e] < n) o = i + 1;
                        else {
                            if (!(a[e] > n)) return {
                                lo: a,
                                hi: r
                            };
                            s = i - 1;
                        }
                    }
                    return {
                        lo: r,
                        hi: null
                    };
                }
                function s(t, e, n, i) {
                    var a = o(t, e, n), r = a.lo ? a.hi ? a.lo : t[t.length - 2] : t[0], s = a.lo ? a.hi ? a.hi : t[t.length - 1] : t[1], l = s[e] - r[e], u = l ? (n - r[e]) / l : 0, d = (s[i] - r[i]) * u;
                    return r[i] + d;
                }
                function l(t, e) {
                    var n = e.parser, i = e.parser || e.format;
                    return "function" == typeof n ? n(t) : "string" == typeof t && "string" == typeof i ? v(t, i) : (t instanceof v || (t = v(t)), t.isValid() ? t : "function" == typeof i ? i(t) : t);
                }
                function u(t, e) {
                    if (b.isNullOrUndef(t)) return null;
                    var n = e.options.time, i = l(e.getRightValue(t), n);
                    return i.isValid() ? (n.round && i.startOf(n.round), i.valueOf()) : null;
                }
                function d(t, e, n, i) {
                    var a, r, o, s = e - t, l = k[n], u = l.size, d = l.steps;
                    if (!d) return Math.ceil(s / ((i || 1) * u));
                    for(a = 0, r = d.length; a < r && (o = d[a], !(Math.ceil(s / (u * o)) <= i)); ++a);
                    return o;
                }
                function c(t, e, n, i) {
                    var a, r, o, s = w.length;
                    for(a = w.indexOf(t); a < s - 1; ++a)if (r = k[w[a]], o = r.steps ? r.steps[r.steps.length - 1] : _, r.common && Math.ceil((n - e) / (o * r.size)) <= i) return w[a];
                    return w[s - 1];
                }
                function h(t, e, n, i) {
                    var a, r, o = v.duration(v(i).diff(v(n)));
                    for(a = w.length - 1; a >= w.indexOf(e); a--)if (r = w[a], k[r].common && o.as(r) >= t.length) return r;
                    return w[e ? w.indexOf(e) : 0];
                }
                function f(t) {
                    for(var e = w.indexOf(t) + 1, n = w.length; e < n; ++e)if (k[w[e]].common) return w[e];
                }
                function g(t, e, n, i) {
                    var a, r = i.time, o = r.unit || c(r.minUnit, t, e, n), s = f(o), l = b.valueOrDefault(r.stepSize, r.unitStepSize), u = "week" === o && r.isoWeekday, h = i.ticks.major.enabled, g = k[o], m = v(t), p = v(e), y = [];
                    for(l || (l = d(t, e, o, n)), u && (m = m.isoWeekday(u), p = p.isoWeekday(u)), m = m.startOf(u ? "day" : o), (p = p.startOf(u ? "day" : o)) < e && p.add(1, o), a = v(m), h && s && !u && !r.round && (a.startOf(s), a.add(~~((m - a) / (g.size * l)) * l, o)); a < p; a.add(l, o))y.push(+a);
                    return y.push(+a), y;
                }
                function m(t, e, n, i, a) {
                    var r, o, l = 0, u = 0;
                    return a.offset && e.length && (a.time.min || (r = e.length > 1 ? e[1] : i, o = e[0], l = (s(t, "time", r, "pos") - s(t, "time", o, "pos")) / 2), a.time.max || (r = e[e.length - 1], o = e.length > 1 ? e[e.length - 2] : n, u = (s(t, "time", r, "pos") - s(t, "time", o, "pos")) / 2)), {
                        left: l,
                        right: u
                    };
                }
                function p(t, e) {
                    var n, i, a, r, o = [];
                    for(n = 0, i = t.length; n < i; ++n)a = t[n], r = !!e && a === +v(a).startOf(e), o.push({
                        value: a,
                        major: r
                    });
                    return o;
                }
                var v = t(6);
                v = "function" == typeof v ? v : window.moment;
                var y = t(25), b = t(45), x = Number.MIN_SAFE_INTEGER || -9007199254740991, _ = Number.MAX_SAFE_INTEGER || 9007199254740991, k = {
                    millisecond: {
                        common: !0,
                        size: 1,
                        steps: [
                            1,
                            2,
                            5,
                            10,
                            20,
                            50,
                            100,
                            250,
                            500
                        ]
                    },
                    second: {
                        common: !0,
                        size: 1000,
                        steps: [
                            1,
                            2,
                            5,
                            10,
                            30
                        ]
                    },
                    minute: {
                        common: !0,
                        size: 60000,
                        steps: [
                            1,
                            2,
                            5,
                            10,
                            30
                        ]
                    },
                    hour: {
                        common: !0,
                        size: 3600000,
                        steps: [
                            1,
                            2,
                            3,
                            6,
                            12
                        ]
                    },
                    day: {
                        common: !0,
                        size: 86400000,
                        steps: [
                            1,
                            2,
                            5
                        ]
                    },
                    week: {
                        common: !1,
                        size: 604800000,
                        steps: [
                            1,
                            2,
                            3,
                            4
                        ]
                    },
                    month: {
                        common: !0,
                        size: 2628000000,
                        steps: [
                            1,
                            2,
                            3
                        ]
                    },
                    quarter: {
                        common: !1,
                        size: 7884000000,
                        steps: [
                            1,
                            2,
                            3,
                            4
                        ]
                    },
                    year: {
                        common: !0,
                        size: 31540000000
                    }
                }, w = Object.keys(k);
                e.exports = function(t) {
                    var e = t.Scale.extend({
                        initialize: function() {
                            if (!v) throw new Error("Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com");
                            this.mergeTicksOptions(), t.Scale.prototype.initialize.call(this);
                        },
                        update: function() {
                            var e = this, n = e.options;
                            return n.time && n.time.format && console.warn("options.time.format is deprecated and replaced by options.time.parser."), t.Scale.prototype.update.apply(e, arguments);
                        },
                        getRightValue: function(e) {
                            return e && void 0 !== e.t && (e = e.t), t.Scale.prototype.getRightValue.call(this, e);
                        },
                        determineDataLimits: function() {
                            var t, e, n, r, o, s, l = this, d = l.chart, c = l.options.time, h = _, f = x, g = [], m = [], p = [];
                            for(t = 0, n = d.data.labels.length; t < n; ++t)p.push(u(d.data.labels[t], l));
                            for(t = 0, n = (d.data.datasets || []).length; t < n; ++t)if (d.isDatasetVisible(t)) if (o = d.data.datasets[t].data, b.isObject(o[0])) for(m[t] = [], e = 0, r = o.length; e < r; ++e)s = u(o[e], l), g.push(s), m[t][e] = s;
                            else g.push.apply(g, p), m[t] = p.slice(0);
                            else m[t] = [];
                            p.length && (p = a(p).sort(i), h = Math.min(h, p[0]), f = Math.max(f, p[p.length - 1])), g.length && (g = a(g).sort(i), h = Math.min(h, g[0]), f = Math.max(f, g[g.length - 1])), h = u(c.min, l) || h, f = u(c.max, l) || f, h = h === _ ? +v().startOf("day") : h, f = f === x ? +v().endOf("day") + 1 : f, l.min = Math.min(h, f), l.max = Math.max(h + 1, f), l._horizontal = l.isHorizontal(), l._table = [], l._timestamps = {
                                data: g,
                                datasets: m,
                                labels: p
                            };
                        },
                        buildTicks: function() {
                            var t, e, n, i = this, a = i.min, o = i.max, s = i.options, l = s.time, d = [], c = [];
                            switch(s.ticks.source){
                                case "data":
                                    d = i._timestamps.data;
                                    break;
                                case "labels":
                                    d = i._timestamps.labels;
                                    break;
                                case "auto":
                                default:
                                    d = g(a, o, i.getLabelCapacity(a), s);
                            }
                            for("ticks" === s.bounds && d.length && (a = d[0], o = d[d.length - 1]), a = u(l.min, i) || a, o = u(l.max, i) || o, t = 0, e = d.length; t < e; ++t)(n = d[t]) >= a && n <= o && c.push(n);
                            return i.min = a, i.max = o, i._unit = l.unit || h(c, l.minUnit, i.min, i.max), i._majorUnit = f(i._unit), i._table = r(i._timestamps.data, a, o, s.distribution), i._offsets = m(i._table, c, a, o, s), p(c, i._majorUnit);
                        },
                        getLabelForIndex: function(t, e) {
                            var n = this, i = n.chart.data, a = n.options.time, r = i.labels && t < i.labels.length ? i.labels[t] : "", o = i.datasets[e].data[t];
                            return b.isObject(o) && (r = n.getRightValue(o)), a.tooltipFormat && (r = l(r, a).format(a.tooltipFormat)), r;
                        },
                        tickFormatFunction: function(t, e, n, i) {
                            var a = this, r = a.options, o = t.valueOf(), s = r.time.displayFormats, l = s[a._unit], u = a._majorUnit, d = s[u], c = t.clone().startOf(u).valueOf(), h = r.ticks.major, f = h.enabled && u && d && o === c, g = t.format(i || (f ? d : l)), m = f ? h : r.ticks.minor, p = b.valueOrDefault(m.callback, m.userCallback);
                            return p ? p(g, e, n) : g;
                        },
                        convertTicksToLabels: function(t) {
                            var e, n, i = [];
                            for(e = 0, n = t.length; e < n; ++e)i.push(this.tickFormatFunction(v(t[e].value), e, t));
                            return i;
                        },
                        getPixelForOffset: function(t) {
                            var e = this, n = e._horizontal ? e.width : e.height, i = e._horizontal ? e.left : e.top, a = s(e._table, "time", t, "pos");
                            return i + n * (e._offsets.left + a) / (e._offsets.left + 1 + e._offsets.right);
                        },
                        getPixelForValue: function(t, e, n) {
                            var i = this, a = null;
                            if (void 0 !== e && void 0 !== n && (a = i._timestamps.datasets[n][e]), null === a && (a = u(t, i)), null !== a) return i.getPixelForOffset(a);
                        },
                        getPixelForTick: function(t) {
                            var e = this.getTicks();
                            return t >= 0 && t < e.length ? this.getPixelForOffset(e[t].value) : null;
                        },
                        getValueForPixel: function(t) {
                            var e = this, n = e._horizontal ? e.width : e.height, i = e._horizontal ? e.left : e.top, a = (n ? (t - i) / n : 0) * (e._offsets.left + 1 + e._offsets.left) - e._offsets.right, r = s(e._table, "pos", a, "time");
                            return v(r);
                        },
                        getLabelWidth: function(t) {
                            var e = this, n = e.options.ticks, i = e.ctx.measureText(t).width, a = b.toRadians(n.maxRotation), r = Math.cos(a), o = Math.sin(a);
                            return i * r + b.valueOrDefault(n.fontSize, y.global.defaultFontSize) * o;
                        },
                        getLabelCapacity: function(t) {
                            var e = this, n = e.options.time.displayFormats.millisecond, i = e.tickFormatFunction(v(t), 0, [], n), a = e.getLabelWidth(i), r = e.isHorizontal() ? e.width : e.height;
                            return Math.floor(r / a);
                        }
                    });
                    t.scaleService.registerScaleType("time", e, {
                        position: "bottom",
                        distribution: "linear",
                        bounds: "data",
                        time: {
                            parser: !1,
                            format: !1,
                            unit: !1,
                            round: !1,
                            displayFormat: !1,
                            isoWeekday: !1,
                            minUnit: "millisecond",
                            displayFormats: {
                                millisecond: "h:mm:ss.SSS a",
                                second: "h:mm:ss a",
                                minute: "h:mm a",
                                hour: "hA",
                                day: "MMM D",
                                week: "ll",
                                month: "MMM YYYY",
                                quarter: "[Q]Q - YYYY",
                                year: "YYYY"
                            }
                        },
                        ticks: {
                            autoSkip: !1,
                            source: "auto",
                            major: {
                                enabled: !1
                            }
                        }
                    });
                };
            },
            {
                25: 25,
                45: 45,
                6: 6
            }
        ]
    }, {
    }, [
        7
    ])(7);
});
const PieChart = {
    props: [
        "height",
        "width",
        "title",
        "data"
    ],
    template: `<canvas :height="height" :width="width"></canvas>`,
    mounted () {
        const labels = this.data.map((item)=>item.label
        );
        const data = this.data.map((item)=>item.value
        );
        const colour = this.data.map((item)=>item.colour
        );
        new Chart(this.$el.getContext("2d"), {
            type: "pie",
            data: {
                labels: labels,
                datasets: [
                    {
                        label: this.title,
                        data: data,
                        backgroundColor: colour,
                        hoverOffset: 4
                    }
                ]
            }
        });
    }
};
const LineChart = {
    props: [
        "height",
        "width",
        "title",
        "data"
    ],
    template: `<canvas :height="height" :width="width"></canvas>`,
    mounted () {
        const groupedData = {
        };
        this.data.map((item)=>{
            const dataSet = groupedData[item.series];
            if (!dataSet) {
                groupedData[item.series] = [];
            }
            groupedData[item.series].push(item);
        });
        const dataSets = [];
        let labels = [];
        let countedLabels = false;
        for(const seriesName in groupedData){
            const series = groupedData[seriesName];
            if (!countedLabels) {
                labels = series.map((item)=>item.x
                );
                countedLabels = true;
            }
            dataSets.push({
                data: series.map((item)=>item.y
                ),
                label: series[0].series,
                borderColor: series[0].colour,
                tension: 0,
                fill: false
            });
        }
        new Chart(this.$el.getContext("2d"), {
            type: "line",
            data: {
                labels: labels,
                datasets: dataSets
            }
        });
    }
};
const HomePage = (db)=>({
        name: "HomePage",
        components: {
            "code-editor": CodeEditor,
            "pie-chart": PieChart,
            "line-chart": LineChart
        },
        data () {
            return {
                loading: true,
                error: false,
                errorMessage: "",
                query: "",
                results: [],
                url: ""
            };
        },
        template: `<div>
          <h1 class="title">UK Politics Database</h1>
          <div v-if="loading">
              Loading...
          </div>

          <div v-else-if="error">
              <code>{{errorMessage}}</code>
          </div>

          <div v-else>
              <p>Write your SQL(ite) queries into the below space and hit <code>Execute</code> to see results.</p>
              <div>
                <code-editor mode="sql" v-model="query"></code-editor>
              </div>

              <button class="button" v-on:click.prevent="execute">Execute</button>
              <button class="button" v-on:click.prevent="share">Share</button>

              <div v-if="url">
                <p>Share this URL for others to see your query:</p>
                <input class="input" type="text" disabled v-model="url"/>
                <button class="button" v-on:click.prevent="copyUrl">📋</button>
              </div>

              <div v-for="(result, idx) in results">
                  <div class="select">
                    <select :key="resultKey(idx, 'select')" v-model="results[idx].chartType">
                        <option disabled>-- Select Chart Type --</option>
                        <option value="table">Table</option>
                        <option value="pie">Pie Chart</option>
                        <option value="line">Line Chart</option>
                    </select>
                  </div>

                  <table class="table" :key="resultKey(idx, 'table')" v-if="result.chartType === 'table'">
                      <thead>
                          <tr>
                              <th v-for="column in result.columns">{{column}}</th>
                          </tr>
                      </thead>
                      <tbody>
                          <tr v-for="row in result.values">
                              <td v-for="field in row">{{field}}</td>
                          </tr>
                      </tbody>
                  </table>

                  <pie-chart :key="resultKey(idx, 'pie')" v-if="results[idx].chartType === 'pie'" :data="pieChart(result)"></pie-chart>
                  <line-chart :key="resultKey(idx, 'line')" v-if="results[idx].chartType === 'line'" :data="lineChart(result)"></line-chart>
              </div>
          </div>
      </div>`,
        mounted () {
            try {
                this.loadQueryFromUrl();
            } catch (err) {
                this.error = true;
                this.errorMessage = err.message;
                console.error(err);
            } finally{
                this.loading = false;
            }
        },
        watch: {
            "$route": "loadQueryFromUrl"
        },
        methods: {
            baseUrl () {
                return `${window.location.href.replace(window.location.hash, "")}`;
            },
            share () {
                this.url = `${this.baseUrl()}#/?query=` + encodeURIComponent(this.query);
            },
            copyUrl () {
                window.navigator.clipboard.writeText(this.url);
            },
            loadQueryFromUrl () {
                const values = this.$route.query;
                if (!("query" in values)) {
                    return;
                }
                const query = decodeURIComponent(values.query);
                if (!query) {
                    return;
                }
                this.query = query;
            },
            execute () {
                try {
                    this.results = db.exec(this.query);
                    this.results = this.results.map((result)=>{
                        this.$set(result, "chartType", "table");
                        return result;
                    });
                } catch (err) {
                    alert(`Failed to execute query: ${err.message}`);
                }
            },
            resultKey (idx, type) {
                return `result-${type}-${idx}`;
            },
            pieChart (result) {
                const valueIdx = result.columns.indexOf("value");
                const labelIdx = result.columns.indexOf("label");
                const colourIdx = result.columns.indexOf("colour");
                return result.values.map((item)=>({
                        label: item[labelIdx],
                        value: item[valueIdx],
                        colour: item[colourIdx] || "#cccccc"
                    })
                );
            },
            lineChart (result) {
                const xIdx = result.columns.indexOf("x");
                const yIdx = result.columns.indexOf("y");
                const seriesIdx = result.columns.indexOf("series");
                const colourIdx = result.columns.indexOf("colour");
                return result.values.map((item)=>({
                        series: item[seriesIdx],
                        x: item[xIdx],
                        y: item[yIdx],
                        colour: item[colourIdx] || "#cccccc"
                    })
                );
            }
        }
    })
;
const baseFileUrl = "https://raw.githubusercontent.com/lokothodida/uk-politics-db/gh-pages/";
const init = async (db)=>{
    await loadTables([
        "constituencies",
        "general-election",
        "eu-referendum",
        "parties", 
    ], db);
    await Promise.all([
        load2015Election(db),
        load2017Election(db),
        load2019Election(db),
        loadParties(db), 
    ]);
};
const loadTables = (tables, db)=>{
    return Promise.all(tables.map(async (table)=>{
        const resp = await fetch(`${baseFileUrl}/tables/${table}.sql`);
        if (resp.status >= 400) {
            throw fileNotFound(`${table}.sql`);
        }
        const script = await resp.text();
        db.exec(script);
    }));
};
const load2015Election = async (db)=>{
    const { data  } = await loadCsv("ge-2015");
    data.map((item)=>{
        db.exec(`INSERT OR IGNORE INTO constituencies(ons_id, ons_region_id, constituency_name) VALUES(?, ?, ?)`, [
            item.ons_id,
            item.ons_region_id,
            item.constituency_name
        ]);
        db.exec(`INSERT INTO general_elections(ons_id, date, party, candidate, votes) VALUES(?, ?, ?, ?, ?)`, [
            item.ons_id,
            "2015",
            item.party_abbreviation,
            `${item.firstname} ${item.surname}`,
            parseInt(item.votes, 10), 
        ]);
    });
};
const load2017Election = async (db)=>{
    const abbreviations = {
        con: "Con",
        lab: "Lab",
        ld: "LD",
        ukip: "UKIP",
        green: "Green",
        snp: "SNP",
        pc: "PC",
        dup: "DUP",
        sf: "SF",
        sdlp: "SDLP",
        uup: "UUP",
        alliance: "Alliance",
        other: "Ind"
    };
    const { data  } = await loadCsv("ge-2017");
    data.map((item)=>{
        for(const abbr in abbreviations){
            const votes = parseInt(item[abbr], 10);
            if (isNaN(votes)) {
                continue;
            }
            db.exec(`INSERT INTO general_elections(ons_id, date, party, candidate, votes) VALUES(?, ?, ?, ?, ?)`, [
                item.ons_id,
                "2017",
                abbreviations[abbr],
                `${abbreviations[abbr]}: TO ADD NAME`,
                votes, 
            ]);
        }
    });
};
const load2019Election = async (db)=>{
    const { data  } = await loadCsv("ge-2019");
    data.map((item)=>{
        db.exec(`INSERT INTO general_elections(ons_id, date, party, candidate, votes) VALUES(?, ?, ?, ?, ?)`, [
            item.ons_id,
            "2019",
            item.party_abbreviation,
            `${item.firstname} ${item.surname}`,
            parseInt(item.votes, 10), 
        ]);
    });
};
const loadParties = async (db)=>{
    const { data  } = await loadCsv("parties");
    data.map((item)=>{
        db.exec(`INSERT INTO parties(id, name, nickname, colour) VALUES(?, ?, ?, ?)`, [
            item.id,
            item.name,
            item.nickname,
            item.colour, 
        ]);
    });
};
const loadCsv = async (name)=>{
    const resp = await fetch(`${baseFileUrl}/data/${name}.csv`);
    if (resp.status >= 400) {
        throw fileNotFound(`${name}.csv`);
    }
    const blob = await resp.text();
    return Papa.parse(blob, {
        header: true,
        skipEmptyLines: true
    });
};
const fileNotFound = (file)=>new Error(`File ${file} not found`)
;
const examples = {
    "2019 General Election Vote Share": `SELECT
	sum(votes) as value,
    party as label,
    colour
FROM general_elections, parties
WHERE date = '2019' AND party = parties.id
GROUP BY party
ORDER BY value DESC;`
};
const ExamplesPage = {
    data () {
        return {
            examples
        };
    },
    name: "ExamplesPage",
    template: `<div>
      <h1 class="title">Examples</h1>

      <div class="content">
        <ul>
          <li v-for="(query, name) in examples">
            <router-link :to="url(query)">{{name}}</router-link>
          </li>
        </ul>
      </div>
    </div>`,
    methods: {
        url (query) {
            return {
                name: "home",
                query: {
                    query: encodeURIComponent(query)
                }
            };
        }
    }
};
gn.use(Mt1);
const SQL = await initSqlJs({
    locateFile: (file)=>`https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.6.1/${file}`
});
const db = new SQL.Database(new Uint8Array([]));
new gn({
    data () {
        return {
            loading: true
        };
    },
    template: `<div>
    <nav class="navbar" role="navigation">
      <div class="navbar-brand">
        <div class="navbar-item">
          <strong>UK Politics Database</strong>
        </div>
      </div>
      <div class="navbar-menu">
        <div class="navbar-start">
          <router-link to="/" class="navbar-item">Home</router-link>
          <router-link to="/about" class="navbar-item">About</router-link>
          <router-link to="/help" class="navbar-item">Help</router-link>
          <router-link to="/examples" class="navbar-item">Examples</router-link>
        </div>
      </div>
    </nav>
    <router-view v-if="!loading"></router-view>
    <div v-else>
      Loading...
    </div>
  </div>`,
    async mounted () {
        try {
            await init(db);
        } catch (error) {
            console.error(error);
            this.$router.push({
                name: "error",
                params: {
                    message: error.message
                }
            });
        } finally{
            this.loading = false;
        }
    },
    router: new Mt1({
        routes: [
            {
                name: "home",
                path: "/",
                component: HomePage(db)
            },
            {
                name: "about",
                path: "/about",
                component: AboutPage
            },
            {
                name: "help",
                path: "/help",
                component: HelpPage(db)
            },
            {
                name: "examples",
                path: "/examples",
                component: ExamplesPage
            },
            {
                name: "error",
                path: "/error",
                component: ErrorPage,
                props: true
            }, 
        ]
    })
}).$mount("#app");
